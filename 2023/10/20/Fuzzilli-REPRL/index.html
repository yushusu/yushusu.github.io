<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Fuzzilli采用了read-eval-print-reset-loop的方式运行，目标任务从管道或者共享内存输入脚本，再重置中间状态等待下一个脚本。目标任务从管道或共享内存输入脚本，并在重置中间状态后等待下一个脚本。参考了forkserver 优化的方法，旨在避免众所周知的缓慢的execve()系统调用和链接过程的开销。新进程通过copy-on-write方式保持在原始状态，从而实现持久性。持">
<meta property="og:type" content="article">
<meta property="og:title" content="Fuzzilli-REPRL">
<meta property="og:url" content="http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/">
<meta property="og:site_name" content="YUSHUSU">
<meta property="og:description" content="Fuzzilli采用了read-eval-print-reset-loop的方式运行，目标任务从管道或者共享内存输入脚本，再重置中间状态等待下一个脚本。目标任务从管道或共享内存输入脚本，并在重置中间状态后等待下一个脚本。参考了forkserver 优化的方法，旨在避免众所周知的缓慢的execve()系统调用和链接过程的开销。新进程通过copy-on-write方式保持在原始状态，从而实现持久性。持">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-20T14:03:43.000Z">
<meta property="article:modified_time" content="2023-10-20T14:05:05.619Z">
<meta property="article:author" content="yushusu">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Fuzzilli-REPRL</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/archives/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/yushusu">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/10/05/sec2023-mobile-1/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&text=Fuzzilli-REPRL"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&is_video=false&description=Fuzzilli-REPRL"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Fuzzilli-REPRL&body=Check out this article: http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&name=Fuzzilli-REPRL&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&t=Fuzzilli-REPRL"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Fuzzilli-REPRL
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">yushusu</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-20T14:03:43.000Z" class="dt-published" itemprop="datePublished">2023-10-20</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>Fuzzilli采用了read-eval-print-reset-loop的方式运行，目标任务从管道或者共享内存输入脚本，再重置中间状态等待下一个脚本。目标任务从管道或共享内存输入脚本，并在重置中间状态后等待下一个脚本。参考了<a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">forkserver 优化</a>的方法，旨在避免众所周知的缓慢的<code>execve()</code>系统调用和链接过程的开销。新进程通过copy-on-write方式保持在原始状态，从而实现持久性。持续的分叉和初始化循环是一个重要且可避免的瓶颈。底层API要么是无状态的，要么可以在不丢弃子进程的情况下可靠地重置为近乎原始的状态。在这种方案中，模糊器将测试用例提供给一个单独的、长期存在的进程，该进程读取输入数据并将其传递给要检测的API。该进程通过停止自己的执行来通知父级运行成功。最终，当父进程恢复时，该进程简单地循环回到开始处。</p>
<p>在<code>/fuzzilli/Sources/Fuzzilli/Execution/REPRL.swift</code> 中：</p>
<p>定义一个<code>REPRL</code>的类，实现<code>ScriptRunner</code> 来运行多个脚本并在执行之间重置全局状态。</p>
<p>1、首先调用libreprl库初始化相关的属性和上下文，注册监听Shutdown事件发生时销毁相关上下文：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">initialize</span>() &#123;</span><br><span class="line">        reprlContext <span class="operator">=</span> libreprl.reprl_create_context()</span><br><span class="line">        <span class="keyword">if</span> reprlContext <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.fatal(<span class="string">&quot;Failed to create REPRL context&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> argv <span class="operator">=</span> convertToCArray(processArguments)</span><br><span class="line">        <span class="keyword">let</span> envp <span class="operator">=</span> convertToCArray(env)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> reprl_initialize_context(reprlContext, argv, envp, <span class="comment">/* capture stdout */</span> <span class="number">1</span>, <span class="comment">/* capture stderr: */</span> <span class="number">1</span>) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            logger.fatal(<span class="string">&quot;Failed to initialize REPRL context: <span class="subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        freeCArray(argv, numElems: processArguments.count)</span><br><span class="line">        freeCArray(envp, numElems: env.count)</span><br><span class="line"></span><br><span class="line">        fuzzer.registerEventListener(for: fuzzer.events.<span class="type">Shutdown</span>) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            reprl_destroy_context(<span class="keyword">self</span>.reprlContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、设置环境变量的方法（setEnvironmentVariable）</p>
<p>3、实现run，根据最大执行数重新启动子进程，并在执行过程中处理错误和超时情况。通过记录脚本内容到缓冲区（scriptBuffer），支持启用诊断模式（enableDiagnostics），以便在后续执行中发现任何状态损坏的问题。通过使用libreprl库提供的函数来执行脚本和处理相关的上下文。最后返回一个Execution对象，其中包含了脚本执行的结果和相关的输出信息（stdout、stderr、fuzzout）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">run</span>(<span class="keyword">_</span> <span class="params">script</span>: <span class="type">String</span>, <span class="params">withTimeout</span> <span class="params">timeout</span>: <span class="type">UInt32</span>) -&gt; <span class="type">Execution</span> &#123;</span><br><span class="line">        <span class="comment">// Log the current script into the buffer if diagnostics are enabled.</span></span><br><span class="line">        <span class="keyword">if</span> fuzzer.config.enableDiagnostics &#123;</span><br><span class="line">            <span class="keyword">self</span>.scriptBuffer <span class="operator">+=</span> script <span class="operator">+</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastExecId <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> execution <span class="operator">=</span> <span class="type">REPRLExecution</span>(from: <span class="keyword">self</span>) <span class="comment">// 返回program的执行结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> script.count <span class="operator">&lt;=</span> <span class="type">REPRL_MAX_DATA_SIZE</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Script too large to execute. Assuming timeout...&quot;</span>)</span><br><span class="line">            execution.outcome <span class="operator">=</span> .timedOut</span><br><span class="line">            <span class="keyword">return</span> execution</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        execsSinceReset <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> freshInstance: <span class="type">Int32</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> execsSinceReset <span class="operator">&gt;</span> maxExecsBeforeRespawn &#123;</span><br><span class="line">            freshInstance <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">            execsSinceReset <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> fuzzer.config.enableDiagnostics &#123;</span><br><span class="line">                scriptBuffer.removeAll(keepingCapacity: <span class="literal">true</span>) <span class="comment">// 如果到达最大执行数需要清理重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> execTime: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">0</span>        <span class="comment">// In microseconds</span></span><br><span class="line">        <span class="keyword">let</span> timeout <span class="operator">=</span> <span class="type">UInt64</span>(timeout) <span class="operator">*</span> <span class="number">1000</span>        <span class="comment">// In microseconds</span></span><br><span class="line">        <span class="keyword">var</span> status: <span class="type">Int32</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        script.withCString &#123;</span><br><span class="line">            status <span class="operator">=</span> reprl_execute(reprlContext, <span class="variable">$0</span>, <span class="type">UInt64</span>(script.count), <span class="type">UInt64</span>(timeout), <span class="operator">&amp;</span>execTime, freshInstance)</span><br><span class="line">                        <span class="comment">// reprl_execute实现read-eval-print-reset-loop的方式运行           </span></span><br><span class="line">                        <span class="comment">// If we fail, we retry after a short timeout and with a fresh instance. If we still fail, we give up trying</span></span><br><span class="line">            <span class="comment">// to execute this program. If we repeatedly fail to execute any program, we abort.</span></span><br><span class="line">            <span class="keyword">if</span> status <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">                logger.warning(<span class="string">&quot;Script execution failed: <span class="subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>. Retrying in 1 second...&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> fuzzer.config.enableDiagnostics &#123;</span><br><span class="line">                    fuzzer.dispatchEvent(fuzzer.events.<span class="type">DiagnosticsEvent</span>, data: (name: <span class="string">&quot;REPRLFail&quot;</span>, content: scriptBuffer))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br><span class="line">                status <span class="operator">=</span> reprl_execute(reprlContext, <span class="variable">$0</span>, <span class="type">UInt64</span>(script.count), <span class="type">UInt64</span>(timeout), <span class="operator">&amp;</span>execTime, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> status <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Script execution failed again: <span class="subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>. Giving up&quot;</span>)</span><br><span class="line">            <span class="comment">// If we weren&#x27;t able to successfully execute a script in the last N attempts, abort now...</span></span><br><span class="line">            recentlyFailedExecutions <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> recentlyFailedExecutions <span class="operator">&gt;=</span> <span class="number">10</span> &#123;</span><br><span class="line">                logger.fatal(<span class="string">&quot;Too many consecutive REPRL failures&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            execution.outcome <span class="operator">=</span> .failed(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> execution</span><br><span class="line">        &#125;</span><br><span class="line">        recentlyFailedExecutions <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">RIFEXITED</span>(status) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> code <span class="operator">=</span> <span class="type">REXITSTATUS</span>(status)</span><br><span class="line">            <span class="keyword">if</span> code <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">                execution.outcome <span class="operator">=</span> .succeeded</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                execution.outcome <span class="operator">=</span> .failed(<span class="type">Int</span>(code))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="type">RIFSIGNALED</span>(status) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            execution.outcome <span class="operator">=</span> .crashed(<span class="type">Int</span>(<span class="type">RTERMSIG</span>(status)))</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="type">RIFTIMEDOUT</span>(status) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            execution.outcome <span class="operator">=</span> .timedOut</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Unknown REPRL exit status <span class="subst">\(status)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        execution.execTime <span class="operator">=</span> <span class="type">Double</span>(execTime) <span class="operator">/</span> <span class="number">1_000_000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> execution</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>fuzzilli/Sources/libreprl/libreprl-posix.c</code>中定义了read-eval-print-reset-loop的实现：</p>
<p>reprl_context结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">reprl_context</span> &#123;</span><br><span class="line">    <span class="comment">// Whether reprl_initialize has been successfully performed on this context.</span></span><br><span class="line">    <span class="type">int</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read file descriptor of the control pipe. Only valid if a child process is running (i.e. pid is nonzero).</span></span><br><span class="line">    <span class="type">int</span> ctrl_in;</span><br><span class="line">    <span class="comment">// Write file descriptor of the control pipe. Only valid if a child process is running (i.e. pid is nonzero).</span></span><br><span class="line">    <span class="type">int</span> ctrl_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data channel REPRL -&gt; Child</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* data_in;</span><br><span class="line">    <span class="comment">// Data channel Child -&gt; REPRL</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* data_out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Optional data channel for the child&#x27;s stdout and stderr.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* child_stdout;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* child_stderr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PID of the child process. Will be zero if no child process is currently running.</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arguments and environment for the child process.</span></span><br><span class="line">    <span class="type">char</span>** argv;</span><br><span class="line">    <span class="type">char</span>** envp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A malloc&#x27;d string containing a description of the last error that occurred.</span></span><br><span class="line">    <span class="type">char</span>* last_error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化相关上下文，就是保存和子进程通信要用到的fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> reprl_context* <span class="title function_">reprl_create_context</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &quot;Reserve&quot; the well-known REPRL fds so no other fd collides with them.</span></span><br><span class="line">    <span class="comment">// This would cause various kinds of issues in reprl_spawn_child.</span></span><br><span class="line">    <span class="comment">// It would be enough to do this once per process in the case of multiple</span></span><br><span class="line">    <span class="comment">// REPRL instances, but it&#x27;s probably not worth the implementation effort.</span></span><br><span class="line">    <span class="type">int</span> devnull = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_CTRL_IN);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_CTRL_OUT);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_DATA_IN);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_DATA_OUT);</span><br><span class="line">    close(devnull);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> reprl_context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reprl_initialize_context主要调用reprl_create_data_channel初始化并返回data_channel：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">data_channel</span>* <span class="built_in">reprl_create_data_channel</span>(<span class="keyword">struct</span> reprl_context* ctx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="comment">// memfd_create函数创建一个匿名的、可执行关闭的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">memfd_create</span>(<span class="string">&quot;REPRL_DATA_CHANNEL&quot;</span>, MFD_CLOEXEC);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;/tmp/reprl_data_channel_XXXXXXXX&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">mkostemp</span>(path, O_CLOEXEC);</span><br><span class="line">    <span class="built_in">unlink</span>(path);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span> || <span class="built_in">ftruncate</span>(fd, REPRL_MAX_DATA_SIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to create data channel file: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将文件映射到内存中，创建一段可读可写的共享内存区域</span></span><br><span class="line">    <span class="type">char</span>* mapping = <span class="built_in">mmap</span>(<span class="number">0</span>, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapping == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to mmap data channel file: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* channel = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> data_channel));</span><br><span class="line">    channel-&gt;fd = fd;</span><br><span class="line">    channel-&gt;mapping = mapping;</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reprl_spawn_child会启动子进程并调用pipe()进行进程间进行通信，它创建两个用于控制通信的管道，一个用于子进程向父进程发送消息，另一个用于父进程向子进程发送消息，并设置子进程的输入输出重定向，将管道和数据通道与子进程的输入输出关联。在子进程中执行指定的可执行文件，父进程等待并读取子进程发送的HELO message消息，回复子进程HELO message启动子进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">reprl_spawn_child</span><span class="params">(<span class="keyword">struct</span> reprl_context* ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is also a good time to ensure the data channel backing files don&#x27;t grow too large.</span></span><br><span class="line">    <span class="built_in">ftruncate</span>(ctx-&gt;data_in-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    <span class="built_in">ftruncate</span>(ctx-&gt;data_out-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stdout) <span class="built_in">ftruncate</span>(ctx-&gt;child_stdout-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stderr) <span class="built_in">ftruncate</span>(ctx-&gt;child_stderr-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> crpipe[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;          <span class="comment">// control pipe child -&gt; reprl</span></span><br><span class="line">    <span class="type">int</span> cwpipe[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;          <span class="comment">// control pipe reprl -&gt; child</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(crpipe) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(cwpipe) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(crpipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(crpipe[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;ctrl_in = crpipe[<span class="number">0</span>];</span><br><span class="line">    ctx-&gt;ctrl_out = cwpipe[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fcntl</span>(ctx-&gt;ctrl_in, F_SETFD, FD_CLOEXEC);</span><br><span class="line">    <span class="built_in">fcntl</span>(ctx-&gt;ctrl_out, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="comment">// Use vfork() on Linux as that considerably improves the fuzzer performance. See also https://github.com/googleprojectzero/fuzzilli/issues/174</span></span><br><span class="line">    <span class="comment">// Due to vfork, the code executed in the child process *must not* modify any memory apart from its stack, as it will share the page table of its parent.</span></span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">vfork</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dup2</span>(cwpipe[<span class="number">0</span>], REPRL_CHILD_CTRL_IN) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">dup2</span>(crpipe[<span class="number">1</span>], REPRL_CHILD_CTRL_OUT) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">dup2</span>(ctx-&gt;data_out-&gt;fd, REPRL_CHILD_DATA_IN) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">dup2</span>(ctx-&gt;data_in-&gt;fd, REPRL_CHILD_DATA_OUT) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;dup2 failed in the child: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unblock any blocked signals. It seems that libdispatch sometimes blocks delivery of certain signals.</span></span><br><span class="line">        <span class="type">sigset_t</span> newset;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;newset);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;newset, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;sigprocmask failed in the child: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(cwpipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(crpipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> devnull = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="built_in">dup2</span>(devnull, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;child_stdout) <span class="built_in">dup2</span>(ctx-&gt;child_stdout-&gt;fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dup2</span>(devnull, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;child_stderr) <span class="built_in">dup2</span>(ctx-&gt;child_stderr-&gt;fd, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dup2</span>(devnull, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">close</span>(devnull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// close all other FDs. We try to use FD_CLOEXEC everywhere, but let&#x27;s be extra sure we don&#x27;t leak any fds to the child.</span></span><br><span class="line">        <span class="type">int</span> tablesize = <span class="built_in">getdtablesize</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; tablesize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == REPRL_CHILD_CTRL_IN || i == REPRL_CHILD_CTRL_OUT || i == REPRL_CHILD_DATA_IN || i == REPRL_CHILD_DATA_OUT) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">execve</span>(ctx-&gt;argv[<span class="number">0</span>], ctx-&gt;argv, ctx-&gt;envp);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to execute child process %s: %s\n&quot;</span>, ctx-&gt;argv[<span class="number">0</span>], <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">fflush</span>(stderr);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(crpipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(cwpipe[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(ctx-&gt;ctrl_in);</span><br><span class="line">        <span class="built_in">close</span>(ctx-&gt;ctrl_out);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to fork: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx-&gt;pid = pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> helo[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(ctx-&gt;ctrl_in, helo, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Did not receive HELO message from child: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(helo, <span class="string">&quot;HELO&quot;</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Received invalid HELO message from child: %s&quot;</span>, helo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(ctx-&gt;ctrl_out, helo, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to send HELO reply message to child: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个reprl_execute实现流程：将脚本内容复制到数据通道，向子进程发送执行脚本的命令和脚本长度，等待子进程执行完成或崩溃，返回最终的子进程状态值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reprl_execute</span><span class="params">(<span class="keyword">struct</span> reprl_context* ctx, <span class="type">const</span> <span class="type">char</span>* script, <span class="type">uint64_t</span> script_length, <span class="type">uint64_t</span> timeout, <span class="type">uint64_t</span>* execution_time, <span class="type">int</span> fresh_instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx-&gt;initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;REPRL context is not initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (script_length &gt; REPRL_MAX_DATA_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Script too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; REPRL_MAX_TIMEOUT_IN_MICROSECONDS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Timeout too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> timeout_ms = (<span class="type">int</span>)(timeout / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Terminate any existing instance if requested.</span></span><br><span class="line">    <span class="keyword">if</span> (fresh_instance &amp;&amp; ctx-&gt;pid) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset file position so the child can simply read(2) and write(2) to these fds.</span></span><br><span class="line">    <span class="built_in">lseek</span>(ctx-&gt;data_out-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">lseek</span>(ctx-&gt;data_in-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stdout) &#123;</span><br><span class="line">        <span class="built_in">lseek</span>(ctx-&gt;child_stdout-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stderr) &#123;</span><br><span class="line">        <span class="built_in">lseek</span>(ctx-&gt;child_stderr-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Spawn a new instance if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx-&gt;pid) &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">reprl_spawn_child</span>(ctx);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the script to the data channel.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ctx-&gt;data_out-&gt;mapping, script, script_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell child to execute the script.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(ctx-&gt;ctrl_out, <span class="string">&quot;exec&quot;</span>, <span class="number">4</span>) != <span class="number">4</span> ||</span><br><span class="line">        <span class="built_in">write</span>(ctx-&gt;ctrl_out, &amp;script_length, <span class="number">8</span>) != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// These can fail if the child unexpectedly terminated between executions.</span></span><br><span class="line">        <span class="comment">// Check for that here to be able to provide a better error message.</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitpid</span>(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid) &#123;</span><br><span class="line">            <span class="built_in">reprl_child_terminated</span>(ctx);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Child unexpectedly exited with status %i between executions&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Child unexpectedly terminated with signal %i between executions&quot;</span>, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to send command to child process: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for child to finish execution (or crash).</span></span><br><span class="line">    <span class="type">uint64_t</span> start_time = <span class="built_in">current_usecs</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds = &#123;.fd = ctx-&gt;ctrl_in, .events = POLLIN, .revents = <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">poll</span>(&amp;fds, <span class="number">1</span>, timeout_ms);</span><br><span class="line">    *execution_time = <span class="built_in">current_usecs</span>() - start_time;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Execution timed out. Kill child and return a timeout status.</span></span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// An error occurred.</span></span><br><span class="line">        <span class="comment">// We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to poll: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Poll succeeded, so there must be something to read now (either the status or EOF).</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">ssize_t</span> rv = <span class="built_in">read</span>(ctx-&gt;ctrl_in, &amp;status, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to read from control pipe: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// Most likely, the child process crashed and closed the write end of the control pipe.</span></span><br><span class="line">        <span class="comment">// Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,</span></span><br><span class="line">        <span class="comment">// and we also don&#x27;t want to block here. So just retry waitpid() a few times...</span></span><br><span class="line">        <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            success = <span class="built_in">waitpid</span>(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid;</span><br><span class="line">            <span class="keyword">if</span> (!success) <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!success &amp;&amp; <span class="built_in">current_usecs</span>() - start_time &lt; timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?</span></span><br><span class="line">            <span class="comment">// Probably the best we can do is kill the child and return an error.</span></span><br><span class="line">            <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Child in weird state after execution&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cleanup any state related to this child process.</span></span><br><span class="line">        <span class="built_in">reprl_child_terminated</span>(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">            status = <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">            status = <span class="built_in">WTERMSIG</span>(status);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This shouldn&#x27;t happen, since we don&#x27;t specify WUNTRACED for waitpid...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Waitpid returned unexpected child state %i&quot;</span>, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The status must be a positive number, see the status encoding format below.</span></span><br><span class="line">    <span class="comment">// We also don&#x27;t allow the child process to indicate a timeout. If we wanted,</span></span><br><span class="line">    <span class="comment">// we could treat it as an error if the upper bits are set.</span></span><br><span class="line">    status &amp;= <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/archives/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/yushusu">Projects</a></li>
        
      </ul>
    </div>

    
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&text=Fuzzilli-REPRL"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&is_video=false&description=Fuzzilli-REPRL"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Fuzzilli-REPRL&body=Check out this article: http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&title=Fuzzilli-REPRL"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&name=Fuzzilli-REPRL&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yushusu.github.io/2023/10/20/Fuzzilli-REPRL/&t=Fuzzilli-REPRL"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    yushusu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/archives/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/yushusu">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
