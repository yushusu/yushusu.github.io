<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qiling framwork lab</title>
      <link href="/2023/06/29/Qiling-framwork-lab/"/>
      <url>/2023/06/29/Qiling-framwork-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="challenge1-操作内存"><a href="#challenge1-操作内存" class="headerlink" title="challenge1:操作内存"></a>challenge1:操作内存</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled.png" class title="Untitled"><p>可以看到程序需要读取内存地址0x1337的未映射全局变量，需要我们让内存0x1337上存放一个值为1337</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.mem.<span class="built_in">map</span>(<span class="number">0x1000</span>, <span class="number">0x1000</span>, info = <span class="string">&#x27;[challenge1]&#x27;</span>)</span><br><span class="line">    <span class="comment">#q1.mem.map(addr, size) 注意要4k对齐</span></span><br><span class="line">    q1.mem.write(<span class="number">0x1337</span>,q1.pack16(<span class="number">1337</span>)) <span class="comment"># pack16(value) == struct.pack(&#x27;H&#x27;, value)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&#x27;qilinglab-aarch64&#x27;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/arm64_linux&quot;</span> <span class="comment">#需要对应架构模拟的文件系统</span></span><br><span class="line">    q1 = Qiling(path,rootfs)</span><br><span class="line">    challenge1(q1)</span><br><span class="line">    q1.verbose = <span class="number">0</span> <span class="comment">#方便看输出</span></span><br><span class="line"><span class="comment">#q1.mem.show_mapinfo()</span></span><br><span class="line">    q1.run()</span><br></pre></td></tr></table></figure><img src="/2023/06/29/Qiling-framwork-lab/Untitled1.png" class title="Untitled"><h1 id="Chanllenge2-Syscall-return-hijack"><a href="#Chanllenge2-Syscall-return-hijack" class="headerlink" title="Chanllenge2:Syscall return hijack"></a>Chanllenge2:Syscall return hijack</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled2.png" class title="Untitled"><p>需要我们在返回之前hook uname系统调用，并修改uname的sysname变量为QilingOS、version变量为ChallengeStart才能过检查。</p><p>uname的结构体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">utsname</span> &#123;</span><br><span class="line">    <span class="type">char</span> sysname[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> nodename[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> release[<span class="number">65</span>];   </span><br><span class="line">    <span class="type">char</span> version[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> machine[<span class="number">65</span>];</span><br><span class="line">    <span class="type">char</span> domainname[<span class="number">65</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uname系统调用，接收一个buf，返回由buf指向的结构中的系统信息。</span></span><br><span class="line">        <span class="number">00100</span>d28 e0 <span class="number">03</span> <span class="number">01</span> <span class="number">91</span>     add        check,sp,#<span class="number">0x40</span></span><br><span class="line">        <span class="number">00100</span>d2c a1 ff ff <span class="number">97</span>     bl         &lt;EXTERNAL&gt;::<span class="function">uname                                <span class="type">int</span> <span class="title">uname</span><span class="params">(utsname * __name)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling.const <span class="keyword">import</span> QL_INTERCEPT</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_uname_on_exit_hook</span>(<span class="params">q1, *args</span>):</span><br><span class="line">    <span class="comment">#uname结构体存放在栈偏移0x40位置</span></span><br><span class="line">    out_struct_addr = q1.arch.regs.sp + <span class="number">0x40</span></span><br><span class="line">    sysname_addr = out_struct_addr</span><br><span class="line">    q1.mem.write(sysname_addr, <span class="string">b&#x27;QilingOS\x00&#x27;</span>)</span><br><span class="line">    version_addr = out_struct_addr + <span class="number">65</span>*<span class="number">3</span></span><br><span class="line">    q1.mem.write(version_addr, <span class="string">b&#x27;ChallengeStart\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">q1</span>):</span><br><span class="line">    <span class="comment"># QL_INTERCEPT.EXIT 可以在系统调用之后触发hook</span></span><br><span class="line">    q1.os.set_syscall(<span class="string">&quot;uname&quot;</span>,my_uname_on_exit_hook,QL_INTERCEPT.EXIT)</span><br></pre></td></tr></table></figure><h1 id="Challenge3-FS-amp-Syscall-hijack"><a href="#Challenge3-FS-amp-Syscall-hijack" class="headerlink" title="Challenge3:FS &amp; Syscall hijack"></a>Challenge3:FS &amp; Syscall hijack</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled3.png" class title="Untitled"><p>分别从&#x2F;dev&#x2F;urandom和getrandom提取0x20字节，必须满足提取的字节相同且从与从&#x2F;dev&#x2F;urandom读取的那一个字节都不相同。</p><ul><li>使用set_syscall可以劫持getrandom系统调用返回<code>00</code>字节</li><li>使用add_fs_mapper和Q1FsMappedObject参数定义一个&#x2F;dev&#x2F;urandom的自定义行为，使其返回<code>00</code>字节</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling.os.mapper <span class="keyword">import</span> QlFsMappedObject</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fake_urandom</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="comment"># 覆盖/dev/urandom</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self,size</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&#x27;\x41&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;\x00&quot;</span>*size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getrandom_hook</span>(<span class="params">q1, buf, buflen, flag, *args, **kw</span>):</span><br><span class="line">    q1.mem.write(buf, <span class="string">b&#x27;\x00&#x27;</span>*buflen)</span><br><span class="line">    q1.os.set_syscall_return(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">q1</span>):    </span><br><span class="line">    q1.os.set_syscall(<span class="string">&quot;getrandom&quot;</span>, getrandom_hook)</span><br><span class="line">    q1.add_fs_mapper(<span class="string">&quot;/dev/urandom&quot;</span>, Fake_urandom())</span><br></pre></td></tr></table></figure><h1 id="Challenge4-Hook-address-无用循环"><a href="#Challenge4-Hook-address-无用循环" class="headerlink" title="Challenge4: Hook address 无用循环"></a>Challenge4: Hook address 无用循环</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled4.png" class title="Untitled"><p>需要hook 0x100fe0处的条件比较才能进入for循环，直接把x0寄存器改掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge4</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    condition_loop_enter = base_addr + <span class="number">0xfe0</span></span><br><span class="line">    q1.hook_address(loop_hook, condition_loop_enter)</span><br></pre></td></tr></table></figure><h1 id="challenge5-hook外部函数-rand"><a href="#challenge5-hook外部函数-rand" class="headerlink" title="challenge5: hook外部函数 rand"></a>challenge5: hook外部函数 rand</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled5.png" class title="Untitled"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rand_hook</span>(<span class="params">q1, *args, **kw</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">0</span> <span class="comment"># 设置rand函数的返回值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge5</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.os.set_api(<span class="string">&quot;rand&quot;</span>, rand_hook)</span><br></pre></td></tr></table></figure><h1 id="challenge6-hook-address-突破无限循环"><a href="#challenge6-hook-address-突破无限循环" class="headerlink" title="challenge6: hook address 突破无限循环"></a>challenge6: hook address 突破无限循环</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled6.png" class title="Untitled"><p>和前面challenge4很像，直接hook比较的之前的结果就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_loop_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge6</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    add_addr = base_addr + <span class="number">0x1114</span></span><br><span class="line">    q1.hook_address(infinite_loop_hook , add_addr)</span><br></pre></td></tr></table></figure><h1 id="challenge7-hook外部函数-sleep"><a href="#challenge7-hook外部函数-sleep" class="headerlink" title="challenge7: hook外部函数 sleep"></a>challenge7: hook外部函数 sleep</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled7.png" class title="Untitled"><p>在sleep函数执行之前把参数改成0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sleep_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.arch.regs.x0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.os.set_api(<span class="string">&quot;sleep&quot;</span>, sleep_hook, QL_INTERCEPT.ENTER)</span><br></pre></td></tr></table></figure><h1 id="challenge8"><a href="#challenge8" class="headerlink" title="challenge8 :"></a>challenge8 :</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled8.png" class title="Untitled"><p>需要我们在堆上hook 结构体使得s→check &#x3D; 1，对着汇编窗口c一下d一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>1011d0 e0 <span class="number">17</span> <span class="number">40</span> f9     ldr        pvVar2,[sp, <span class="comment">#0x28] == 提取结构体所在的堆地址</span></span><br><span class="line"><span class="number">00</span>1011d4 e1 0f <span class="number">40</span> f9     ldr        x1,[sp, <span class="comment">#0x18]</span></span><br><span class="line"><span class="number">00</span>1011d8 01 08 <span class="number">00</span> f9     <span class="built_in">str</span>        x1,[pvVar2, <span class="comment">#0x10] == s-&gt;check = x1</span></span><br><span class="line"><span class="number">00</span>1011dc 1f <span class="number">20</span> 03 d5     nop                           == hook here</span><br></pre></td></tr></table></figure><p>方法1:直接读取栈上的堆地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_nop</span>(<span class="params">q1</span>):</span><br><span class="line">    heap_struct_addr = q1.unpack64(q1.mem.read(q1.arch.regs.sp + <span class="number">0x28</span>, <span class="number">8</span>))</span><br><span class="line">    heap_struct = q1.mem.read(heap_struct_addr,<span class="number">24</span>) <span class="comment"># 读取randomstruct结构体</span></span><br><span class="line">    some_string_addr, magic_addr, check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>,heap_struct)</span><br><span class="line">    q1.mem.write(check_addr, <span class="string">b&quot;\x01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    hook_addr = base_addr + <span class="number">0x11dc</span></span><br><span class="line">    q1.hook_address(hook_nop, hook_addr)</span><br></pre></td></tr></table></figure><p>方法2:内存搜索magic</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_mem</span>(<span class="params">q1</span>):</span><br><span class="line">    MAGIC = <span class="number">0x3DFCD6EA00000539</span></span><br><span class="line">    magic_addrs = q1.mem.search(q1.pack64(MAGIC))</span><br><span class="line">    <span class="keyword">for</span> magic_addr <span class="keyword">in</span> magic_addrs:</span><br><span class="line">        <span class="comment"># 验证是否找到正确的结构体地址</span></span><br><span class="line">        candidate_heap_struct_addr = magic_addr - <span class="number">8</span></span><br><span class="line">        candidate_heap_struct = q1.mem.read(candidate_heap_struct_addr, <span class="number">24</span>)</span><br><span class="line">        string_addr, _, check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>, candidate_heap_struct)</span><br><span class="line">        <span class="keyword">if</span> q1.mem.string(string_addr) == <span class="string">&#x27;Random data&#x27;</span>:</span><br><span class="line">            q1.mem.write(check_addr, <span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">q1</span>):</span><br><span class="line">    base_addr = q1.mem.get_lib_base(q1.path)</span><br><span class="line">    hook_addr = base_addr + <span class="number">0x11dc</span></span><br><span class="line">    q1.hook_address(search_mem, hook_addr)</span><br></pre></td></tr></table></figure><h1 id="challenge9-hook外部函数-tolower"><a href="#challenge9-hook外部函数-tolower" class="headerlink" title="challenge9 : hook外部函数 tolower"></a>challenge9 : hook外部函数 tolower</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled9.png" class title="Untitled"><p>简单set_api处理一下得了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tolower_hook</span>(<span class="params">q1</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge9</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.set_api(<span class="string">&quot;tolower&quot;</span>, tolower_hook)</span><br></pre></td></tr></table></figure><h1 id="challenge10-劫持fs"><a href="#challenge10-劫持fs" class="headerlink" title="challenge10: 劫持fs"></a>challenge10: 劫持fs</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled10.png" class title="Untitled"><p>和challenge3差不多，用QlFsMappedObject劫持</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fake_cmdline</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&quot;qilinglab&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge10</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.add_fs_mapper(<span class="string">&quot;/proc/self/cmdline&quot;</span>, Fake_cmdline())</span><br></pre></td></tr></table></figure><h1 id="challenge11-指令级别hook"><a href="#challenge11-指令级别hook" class="headerlink" title="challenge11 : 指令级别hook"></a>challenge11 : 指令级别hook</h1><img src="/2023/06/29/Qiling-framwork-lab/Untitled11.png" class title="Untitled"><p>需要我们hook 0x1013ec这条指令，并把x0寄存器的值改成0x1337 &lt;&lt; 0x10，使用hook_code对这条指令进行指令级hook</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_midr_el1</span>(<span class="params">q1, addr, size</span>):</span><br><span class="line">    <span class="keyword">if</span> q1.mem.read(addr, size) == <span class="string">b&#x27;\x00\x00\x38\xD5&#x27;</span>:</span><br><span class="line">        q1.arch.regs.x0 = <span class="number">0x1337</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">        q1.arch.regs.arch_pc +=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">q1</span>):</span><br><span class="line">    q1.hook_code(hook_midr_el1)</span><br></pre></td></tr></table></figure><p>也可以在主程序运行时hook，这样hook函数就不会在共享库的目标指令出发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">q1</span>):</span><br><span class="line">    mem_map = q1.mem.map_info</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> mem_map:</span><br><span class="line">        start, end, flags, label = entry</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [=]     555555554000 - 555555556000   r-x (5)    [redacted]/qilinglab-aarch64 </span></span><br><span class="line">        <span class="keyword">if</span> q1.path <span class="keyword">in</span> label <span class="keyword">and</span> flags == <span class="number">5</span>:</span><br><span class="line"><span class="comment">#5表示的是r-x属性，加这个判断也是为了缩小hook的范围，提高性能。</span></span><br><span class="line">            start_hook = start</span><br><span class="line">            end_hook = end</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Use begin and end parameters to specify the range of the hook</span></span><br><span class="line">    q1.hook_code(hook_midr_el1, begin=start_hook, end=end_hook)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
